{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"Junior Software Developer (Trainee)What we are looking forWe’re looking for enthusiastic developers, who enjoy learning and applying new technologies to solve complex business problems. You will join a small team of bright, talented developers and designers working hard to create phenomenal user experiences for our customers. Building and maintaining client relationships is vital – you’ll need to demonstrate that you can gain the respect of clients through your product and technical knowledge, and that you can successfully interpret clients’ needs. You are naturally technical, get excited about new technologies and you like to learn. You are detail oriented and willing to go the extra mile when the team needs you. ResponsibilitiesAs a key member of the software development and delivery team, you will: Work with other developers and project managers to develop and deliver software products and solution implementations. Participate in solution development/delivery Leverage Agile practices to incrementally and iteratively deliver. Job Requirements Fluent English 1+ years experience developing Web applications using OO languages (.NET, JAVA, Node.js) Strong JavaScript language fundamentals Experience with, and good understanding of at least one modern JavaScript frameworks(Angular, React, VUE) Strong HTML and CSS skills to follow design specifications and create excellent user experience Experience working within agile teams, preferably the scrum environment Experience with git, JIRA, or other set of agile development tools and workflows Experience building, troubleshooting, and debugging systems. Comfortable with the concepts of revision control, branch management strategy, and continuous integration, release management Strong communication skills, interpersonal skills Strong sense of ownership in delivering quality code Problem solver attitude and a drive to learn and grow professionally Education: Bachelors or Masters Degree in Computer Science or other relevant engineering field","link":"/recruit/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"}],"posts":[{"title":"敏捷实践系列(三)：沟通","text":"大话西游里有一段因为没有沟通的经典, 结局如何大家都知道。 唐僧：你想要啊？悟空，你要是想要的话你就说话嘛，你不说我怎么知道你想要呢，虽然你很有诚意地看着我，可是你还是要跟我说你想要的。你真的想要吗？那你就拿去吧！你不是真的想要吧？难道你真的想要吗？…… 悟空：… 敏捷项目沟通尤其重要敏捷开发多采用短迭代，要求尽快交付可以工作的软件，所以项目的需求文档就很难像原来的瀑布开发模式一样面面俱到。这就要求我们多进行沟通以确保双方的理解一致。根据以往很多项目的经验来看，失败的项目很多都是缺乏沟通，成功的项目必然是沟通做的比较好的。 敏捷经常出现的沟通问题你以为你以为的就是你以为的有时候，我们很多人做项目，拿到项目的需求以后，自己简单看了看，然后就开始做了，等到我们做完一个迭代以后，拿给客户看时，完全不是客户要的东西，因为我们对项目的需求的理解比较片面，就是自以为是。 不敢沟通还有的人，尤其是新入团队的人，客户写的东西或者说的东西，自己没有完全理解，然后又不问，他总觉客户已经说过了，已经写过了，然后再去问客户，是不是不妥？如果按自己的理解或者猜测万一对了呢？， 然后就碰运气。 事实上我们的猜测都常常都是错误的，尤其是在我们对项目没有更全局的了解的情况下。 拖延还有一类沟通的问题，就是我们自己也发现了问题，需求上的，或者客户的流程上的，但是我们总是心想等到明天沟通，明天再等明天，其实是希望这个问题自动消失，但最终的结果往往越来越严重。 不敢沟通客户的问题在我的一些项目里，比如我们团队觉得客户那边需要提高，比如需求都很碎片化，客户的UI改来改去，希望客户能提供一个比较接近Final Design的设计，但是总觉得说出客户的问题不好意思，或者对客户的不尊重，实际上我们提出问题和自己的想法才是对客户最大的尊重。 沟通方法单一我们很多人习惯了一种沟通方式，不管什么问题都是同一种，所有的问题都写邮件或者所有的问题都用语音，这也是很没沟通效率的方式。 敏捷项目如何沟通平等沟通的意识首先，我们要理解，敏捷项目里的沟通，不管是与客户还是与团队成员，大家都是平等的，沟通项目相关的问题都是平等的，尤其是把客户也当做自己团队的一部分，客户也是希望项目做好的那一个人, 只有这样，我们才能畅所欲言，无所顾忌，更不会有想法掖着藏着。 多种沟通方式结合小平说： “白猫黑猫，抓住老鼠就是好猫”，沟通也一样，下面是常见的几种沟通方式。 面对面 视频 语音 IM 文字沟通 邮件沟通 这几种沟通方式的效率一般情况下由高到低，所以我们尽量选择沟通效率比较高的方式， 因为当我们能看见对方的时候，我们可以根据对方的表情就可以看出来对方是否真的理解了自己所说的。 但是实际当中我们需要多种沟通方式的有效结合，比如离岸团队面对面的机会比较少，我们可以视频和语音，但是视频语音由于他强调及时性，需要大家的时间都合适，但是视频语音也有缺点，很难有文字记录，虽然可以录音，但是视频和语音很难搜索内容，也较难在组内传播。 那么文字沟通有时候就体现出了很多的优势，有历史记录，多人可以参与等。 但是IM得文字沟通也有一些不足，比如很难通过图形沟通，对图形标注等，除此之外，很多时候很难及时给出答案等，那么邮件的优势就是不需要客户立即回复，也给客户更多的时间思考，同时格式化的文档更容易把一件事情描述清楚。 所以，我们在沟通的时候，要结合情况选择最适合，最快速能够把问题沟通清楚的方式。 一图胜千言软件项目很多时候，图形化的沟通非常重要，我们很多项目的设计，以及架构，开发人员难以达到统一的认识，就是缺乏图形，设计图或者架构图。我们都知道，人对图形的记忆力要好于文字。 系统之间的交互，软件如何部署，项目的架构封层等，这些用图形来表示往往一页纸就可以，而且大家看后，很容易理解，很容易记住。因为只有别人对你的想法理解了，别人才能够发现你的问题，才能给出建议。我觉得软件项目，非常重要的两张图，一个是 Architecture Diagram, 一个是Use Case Diagram, 这两张图可以大大节省项目的开发沟通时间。 原型或者草图敏捷项目流行边做边改，但是我对这个是不太认可的，客户付钱是让我们把事情做对而不是把事情改对。那么怎么样能够在做之前尽量就明白要做什么？那就是先做一个原型，我说的原型是不需要花太多时间的，如果花太多时间就得不偿失了，比如UI我们可以先在开发之前先画出Wireframe, 如果需要交互，我们可以先做交互的Prototype. 现在有很多工具比如Invision都可以建立静态图形之间的交互，这样可以大大减少返工的时间。 提出问题时尽量给出方案很多人只问问题，所以导致客户回复的很慢，因为客户需要思考，但是有的时候客户思考后给我们的方案又不适合，所以一来二去就浪费了很多时间，那么好的方法是就是，我们给客户提的问题，想想是不是我们没有方案呢？ 还是我们有多个方案不能确定是哪一个方案呢？很多时候我们其实有方案的。 我们都知道我们上学的时候都喜欢做判断题，其次是选择题，其次是填空，最不想做的就是问答题，想想我们要想得到客户的快速反馈，我们是不是想想应该给客户出比较容易做的题呢？ 其实，凡是我们提的方案被客户采纳的，我们做起来也更顺手，也就更有效率。 总结最后，沟通最主要的两点： 如果你想要，就一定要说，不说，别人怎么知道你想要呢？ （敢于沟通） 要想尽一切办法， 让客户觉得：“你以为你以为的就是你以为的” （确认自己的想法)","link":"/2015/10/26/agile-2015-10-16-agile-communication/"},{"title":"敏捷实践系列(四)：代码管理流程","text":"本来没有这么快到流程以及技术部分，但是因为公司需要，所以就临时写了这一部分。 我们已经从SVN 切换到Git很多年了，现在几乎所有的项目都在使用Github管理。对与那些还在坚持使用SVN的，我实在想不出原因，权且称作守旧派吧。 Git的优点Git的优点很多，但是这里只列出我认为非常突出的几点。 由于是分布式，所有本地库包含了远程库的所有内容。 优秀的分支模型，打分支以及合并分支，机器方便。 快速，在这个时间就是金钱的时代，Git由于代码都在本地，打分支和合并分支机器快速，使用个SVN的能深刻体会到这种优势。 感兴趣的，可以去看一下Git本身的设计，内在的架构体现了很多的优势，不愧是出资天才程序员Linus (Linux之父) 之手 版本管理的挑战虽然有这么优秀的版本管理工具，但是我们面对版本管理的时候，依然有非常大得挑战，我们都知道大家工作在同一个仓库上，那么彼此的代码协作必然带来很多问题和挑战，如下： 如何开始一个Feature的开发，而不影响别的Feature？ 由于很容易创建新分支，分支多了如何管理，时间久了，如何知道每个分支是干什么的？ 哪些分支已经合并回了主干？ 如何进行Release的管理？开始一个Release的时候如何冻结Feature, 如何在Prepare Release的时候，开发人员可以继续开发新的功能？ 线上代码出Bug了，如何快速修复？而且修复的代码要包含到开发人员的分支以及下一个Release? 大部分开发人员现在使用Git就只是用三个甚至两个分支，一个是Master, 一个是Develop, 还有一个是基于Develop打得各种分支。这个在小项目规模的时候还勉强可以支撑，因为很多人做项目就只有一个Release, 但是人员一多，而且项目周期一长就会出现各种问题。 Git Flow就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范 Vincent Driessen 同学为了解决这个问题提出了 A Successful Git Branching Model 下面是Git Flow的流程图 上面的图你理解不了？ 没关系，这不是你的错，我觉得这张图本身有点问题，这张图应该左转90度，大家应该就很用以理解了。 Git Flow常用的分支 Production 分支 也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改 Develop 分支 这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支 Feature 分支 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release Release分支 当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支 Hotfix分支 当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release Git Flow如何工作初始分支所有在Master分支上的Commit应该Tag Feature 分支分支名 feature/* Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，但是我们也可以保留 Release分支分支名 release/* Release分支基于Develop分支创建，打完Release分之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于开发新的Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支) 发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。 维护分支 Hotfix分支名 hotfix/* hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag Git Flow代码示例a. 创建develop分支 git branch develop git push -u origin develop b. 开始新Feature开发 git checkout -b some-feature develop # Optionally, push branch to origin: git push -u origin some-feature # 做一些改动 git status git add some-file git commit c. 完成Feature git pull origin develop git checkout develop git merge --no-ff some-feature git push origin develop git branch -d some-feature # If you pushed branch to origin: git push origin --delete some-feature d. 开始Relase git checkout -b release-0.1.0 develop # Optional: Bump version number, commit # Prepare release, commit e. 完成Release git checkout master git merge --no-ff release-0.1.0 git push git checkout develop git merge --no-ff release-0.1.0 git push git branch -d release-0.1.0 # If you pushed branch to origin: git push origin --delete release-0.1.0 git tag -a v0.1.0 master git push --tags f. 开始Hotfix git checkout -b hotfix-0.1.1 master g. 完成Hotfix git checkout master git merge --no-ff hotfix-0.1.1 git push git checkout develop git merge --no-ff hotfix-0.1.1 git push git branch -d hotfix-0.1.1 git tag -a v0.1.1 master git push --tags Git flow工具实际上，当你理解了上面的流程后，你完全不用使用工具，但是实际上我们大部分人很多命令就是记不住呀，流程就是记不住呀，肿么办呢？ 总有聪明的人创造好的工具给大家用, 那就是Git flow script. 安装 OS X brew install git-flow Linux apt-get install git-flow Windows wget -q -O - –no-check-certificate https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | bash 使用 初始化: git flow init 开始新Feature: git flow feature start MYFEATURE Publish一个Feature(也就是push到远程): git flow feature publish MYFEATURE 获取Publish的Feature: git flow feature pull origin MYFEATURE 完成一个Feature: git flow feature finish MYFEATURE 开始一个Release: git flow release start RELEASE [BASE] Publish一个Release: git flow release publish RELEASE 发布Release: git flow release finish RELEASE 别忘了git push –tags 开始一个Hotfix: git flow hotfix start VERSION [BASENAME] 发布一个Hotfix: git flow hotfix finish VERSION Git Flow GUI上面讲了这么多，我知道还有人记不住，那么又有人做出了GUI 工具，你只需要点击下一步就行，工具帮你干这些事！！！ SourceTree当你用Git-flow初始化后，基本上你只需要点击git flow菜单选择start feature, release或者hotfix, 做完后再次选择git flow菜单，点击Done Action. 我勒个去，我实在想不到还有比这更简单的了。 目前SourceTree支持Mac, Windows, Linux. 这么好的工具请问多少钱呢？ 免费!!!! Git flow for visual studio广大VS的福音GitFlow for Visual Studio","link":"/2015/10/27/agile-2015-10-27-sourcecode-management/"},{"title":"敏捷实践系列(五)：迁移已有项目到Git flow","text":"上一篇 敏捷实践系列(四)：代码管理流程 给大家详细的讲解了一下Git flow, 本周我们就把一个客户的所有项目实施了Git flow, 如果说你详细看了那篇文章，那么你就能了解为何要进行Git flow 以及如何对一个新项目按Git flow的流程操作， 但是当我们整理已有的项目时，我们发现了以下几个问题需要一些方法处理。 错乱的分支名如何解决问题我们遇到的一个项目，一开始生产环境用的是master分支，突然客户提出他们有一个客户有特殊需求，让打一个分支出来，团队成员就打出了一个master-quickfix 分支，但是后来这个分支上功能越来越多，慢慢的团队成员就把这个分支当做master分支用了，此时develop和 master-quickfix 分支也早已分道扬镳。然后所有的客户又需要相同的功能，这样如果想合并会master将是非常难的，因为冲突太大。 经过沟通和核实，我们发现现在的master-quickfix其实承担了master的角色，所以我们要让master-quickfix当做master. 方案方案一 用master-quickfix 代码覆盖mastergit checkout master-quickfix merge master - ignoring master's changes git merge -s ours master git checkout master # finally merge all our stuff to new master - actually it replaces the master with master-quickfix git merge master-quickfix # now master-quickfix can be deleted git push origin: master-quickfix 然后我们就看到master上代码已经和原来master-quickfix上一样了，但是这个方法有一个问题就是 master-quickfix上的提交日志没有了，如果你不在乎提交日志那么就可以使用这个方法。 方案二 改分支名git branch -m master new_master # Rename branch locally git push origin :master # Delete the old branch git push --set-upstream origin new_master # Push the new branch, set local branch to track the new remote git branch -m master-quickfix master # Rename branch locally git push origin : master-quickfix # Delete the old branch git push --set-upstream origin master # Push the new branch, set local branch to track the new remote 使用这个方法，就可以看到master-quickfix上的分支的提交记录，过程当中会删除旧的远程master分支，以及master-quickfix分支，所以需要你确认要删除的分支有备份及没有问题，危险系数5星， 我在做这个操作的时候向别人确认了多次。我操作的时候手都抖呀！ 不同的客户不同的分支问题问题原来有一个项目，项目有不同的客户，导致不同的客户的代码在不同的分支上，这导致代码难以管理，功能散乱在各个分支，时间久了，开发人员都不知道每个分支上有哪些功能。 解决方案针对这个问题，我们的想法是不同客户使用同一套代码库，还是使用Git flow, 因为不同的客户需要不同的功能，这其实就是一个SaaS系统，所以我们把系统改为SaaS系统，代码用同一套，不同的客户使用什么功能使用SaaS管理端来配置。 这样做有很多好处，比如：给A客户做的功能很容易再卖给B客户，同时很容易给不同的客户做个性化的配置，例如界面样式等等。 当然，这个需要你的强大的沟通能力，因为改为SaaS需要时间哪，时间就是金钱嘛！ 如果你的客户不同意，或者你需要项目遵守一些”特殊规则或者某个国家特殊政策”，导致整套系统非常不同, 那么我的建议是你重新建一个代码库给这个特殊客户，而不要用分支来区分。 总结由于我们团队的敏捷程度还可以，所以推行Git flow的流程除了以上几个技术上的问题以外，其它的都很顺利。 如果你想实行Git flow，那么再次提醒务必完全理解这个流程再开始。请阅读：敏捷实践系列(四)：代码管理流程","link":"/2015/11/05/agile-2015-11-5-agile-gif-flow-practice/"},{"title":"敏捷实践系列(六)：Team Leader 你不再只是编码, 来炖一锅石头汤吧","text":"为什么软件项目需要 Team Leader多年以前，当我接触敏捷时，我接触到一个概念，叫做 “自组织的团队”，当时我看了一些估计从没做过敏捷的一些凭空捏造的很多文章（事实上，这类人现在越来越多），那些文章多见名猜意，提出了自组织的团队就是团队自己组织，不需要Leader, 一开始我也是这么认为，甚至想尽一切办法向这个方向靠拢，而且成功的提交了一些项目，甚至于连我自己都相信这是自组织的结果，但是后来一想，我在团队里的所想所做不正是一个Team Leader 需要做的吗？ 自组织团队的形成需要一个过程，而且目标只能无限靠近，难以完全达到就拿一个足球团队来说，就拿 “宇宙队” 巴萨来说，也是需要一个教练，同时也需要组建团队，买卖球员，队伍文化建设，战术打法等等，那么软件项目团队来说，自组织团队同样需要组建，文化建设，代码规范，Team Rule, 团队磨合，质量意识，技术交流，客户需求范围把控，会议组织，冲突解决，开发流程等等。 自我保护，害怕承担责任是大部分人的天性在没有一个好的敏捷文化的公司，大部分的程序员都不愿意做更多的事情，话句话说，更愿意做明确分配的事情，因为做的事情越少，自然问题越少，那么责任就越少，这是一种本能的自我保护，这也是大部分人难以成长的重要原因，所以必须要一个人来承担更多的责任，当然方法可以是把要做的事情分的更细，更明确，最终每个人做的事情更细，更多，更明确，那么每一个人要承担的责任就更多了。 ###被领导惯了 很多中国的孩子，尤其是很多现在正处于黄金时代的程序员，独立意识确实要差一些，从小被父母装在一个大 “笼子”里，比如去哪里都是大人在前面牵着后面的小孩，老师严格教条的作业却只有一个标准答案，甚至在我看了写错一个字要重写一百遍一样猪一样的惩罚还至今流传着，忘了教育的本质是要把字学会而不是把字写一百遍，等等类似的东西，使我们不敢去思考，习惯被别人领导。 比如，我爱爬山，和我一起爬山的大部分人去一个没有去过的地方，都喜欢走在我的背后，因为他对未知有恐惧！习惯别人牵着走。 这个问题，我以前以为对高智商的程序员来说应该很少，后来经过10几年，我发现这和其它行业的人一样多。 所以，如果没有Leader, 大家不知道怎么干！ 没有Leader组织，大家不知道干什么？ 软件团队Team Leader的诞生由于上面的原因，我们需要一个Team Leader, 但是由于太多人习惯被领导，害怕承担更多责任，我们就急需要一个Team Leader, 但是一个好的Team Leader是非常难找的，因为一个好的Team Leader要做很多事情才能把一个Team变成好的Team. 不懂技术的Team Leader在软件项目里成功的概率很小由于软件项目来说，一个不懂技术的人可以当一个Team Leader, 但是要想当一个好的Team Leader是难于登天，因为如果你不懂技术，那问题太多了，你怎么知道大家的评估时间靠谱？你如何向客户展示你的方案，你的优势？由于文人相亲，有技术的人一般会鄙视不懂技术的人瞎指挥，从技术人员喜欢鄙视技术人员这点就不难想象的出来。 请不要举马云的例子，你啥时间看到马云去直接领导一个技术团队了. 不懂管理的Team Leader 也难以成为优秀的Team Leader因为Team Leader难找，所以在中国又一个常见的事情不断上演，那就是 “学而优则仕”，同样这个在我的团队里也大量存在，这是没有办法的事情, 因为如果他不懂管理，他还至少是一个程序员，相比不懂技术的管理人来说，如果他管理做不好，那对公司就没有什么价值了。 学而优则仕在软件团队里，我们都知道一个Leader懂技术是多么的重要，那么我们唯一的选择就是沿用了中国多年的传统，那就是“学而优则仕”，比如上小学时，老师不都是让学霸的当班长吗？ 所以很多技术还不错的人，都在团队需要的时候 “被挺身而出”，“被临危受命” 成为了Team Leader，但是这样出来的Team Leader 由于由于没有太多的管理项目的知识，没有团队管理的经验，往往也有不少问题，请继续往下看！ Team Leader 你不再只是编码，请炖一锅石头汤由于“学而优则仕”，导致大部分软件团队Team Leader更多的专注于技术，就自然把更多的时间花在编码上，因为编码是立即可以看到的产出，而忽略了一个Team Leader要做的更重要的事情，比如团队文化建设，项目过程，质量保证，进度跟踪等等的事情。很多时候，我们缺少这些依然把项目做完了，但是实在很多加班，甚至是Team Leader卷起袖子一个定俩的情况下干完了，这样大部分情况就是客户感觉还OK, 但是难以达到满意。这还是自我保护的意识，害怕客户看不到自己实际的编码产出，实际上忽略了团队整体的目标的重要性。 关于技术团队Team Leader应该做什么，我本文就不想讲太多，有时间我会再写几篇关于Team Leader的文章，但是本文我强调的是技术团队的Team Leader不能只是编码，他要意识团队管理的重要性，哪怕这个“重要性”在别人看来什么都没有，不用害怕，因为我们只需要最终的项目成功来证明。 三言两语难以让大家明白Team Leader应该做什么，我就用一则寓言故事来告诉Team Leader 请炖一锅石头汤。 很多年前，有三个士兵，他们从战场回来既饥饿又疲倦，这时他们来到了一个小村庄。然而由于粮食遭遇欠收和连年的战争，村民们迅速的将它们的一小点粮食藏了起来，并在村子的广场中接待了士兵们，搓着双手，哀叹着他们是多么缺少食物。 士兵们平静地与村民们交谈着，第一个士兵对村庄的长老说道：“既然你们的土地收成不好，不能分给我们点吃的，那么我们将会与你们分享我们所有的：如何用石头做一道好汤的秘密。” 自然啦，村民们都十分好奇，很快他们就升起了火，架起了城里最大的一口锅，士兵们将三颗光滑的石子丢到了锅里。“这将是一锅好汤”第二个士兵说；“不过如果有一撮盐和一些欧芹那就更棒啦！”一个村民跳了起来，喊道“多幸运啊！我刚刚想起来家里还剩下些呢！”于是她跑回家，带着满满一围裙的欧芹和一根萝卜回来了。随着锅里的水渐渐煮沸，村民们的记忆力也变的越来越好，很快地，大麦，胡萝卜，牛肉还有奶油，统统被投入了这个大罐子里。 他们吃啊跳啊唱啊~直到深夜，美妙的宴会和新结交的朋友让每个人都感到焕然一新。当早上三个士兵醒来时，他们发现所有村民正站在他们面前。在他们脚边放着有一包这个村子最好的面包和奶酪。“你们把最好的礼物送给了我们：如何从石头里做汤的秘密”，一位长老说道，“这一点我们永远也不会忘记。”第三个士兵转身冲大伙说到：“这并没有什么秘密，但是有一件事是确定的：只有一起分享，我们才可能举办一次宴会。”说完，他们又踏上了路，慢慢走去了。 上面这个故事，我希望Team Leader能够明白虽然士兵并没有什么，但是他却让大家把好东西都拿出来一起做了一锅好烫，村民就是你的团队成员，一开始都把好东西藏起来不是吗？你需要做的就是拿出你的“秘密配方” 和大家一起炖上一个鲜美的石头汤吧！","link":"/2015/12/30/agile-2015-12-30-team-leader-should-not-only-coding/"},{"title":"敏捷实践系列(一)：什么是敏捷","text":"开篇： 悟空：师傅，为什么你写东西，喜欢写系列呢？ 师傅：因为很多东西需要长期的实践呀。 悟空：怎么又开始说敏捷了 师傅：就像一本好书，常读常新，人生不同阶段过的都是不同的人生呀。 悟空：师傅，为什么你原来用上、中、下呢？ 师傅：因为原来只写了个上中，别人一直问下，现在如果只写一二，别人要问，我就说写完了呀! 悟空：。。。。。。 敏捷是什么？其实别人问敏捷是什么？几年前我觉得很好回答，但是现在我觉得很难回答，就像你问天龙八部里的扫地僧：“功夫是什么？” 我觉得他可能真的会被问住的。你再问：功夫是“降龙十八掌”？， 是“九阴真经”？，是“一阳指”？他可能说不是，但是待会儿他可能会说：“也算”。 所以很多人问我什么是敏捷，我其实很难定义，用了SCRUM算吗？用了Kanban算吗？用了Target Process,Trello算吗？我也只能说：“也算，也不算”。 还有人觉得用了持续集成，用了测试驱动开发，用了结对这个应该算是敏捷了吧？ 我只能说如果你用了“轩辕剑”，“倚天剑”，“屠龙刀”，”莫问剑”,”游龙剑”，你就是高手吗？君不见，扫地僧一把扫帚就制服两大高手？ 由此我们可以看到功夫要好，更重要的是内功，是心法。 敏捷的心法是什么？这个心法其实就是武林高手总结的敏捷宣言 个体和交互 胜过 过程和工具 可以工作的软件 胜过 面面俱到的文档 客户合作 胜过 合同谈判 响应变化 胜过 遵循计划 这个其实就是：“九阴真经”，“易筋经”，“六脉神剑”，“葵花宝典”（正宗的是不需要自宫的） 知道了心法，其实每个人的修炼方法都不一样，但是前人为了后人节省时间，给出了自己修炼的一些经验和原则，那就是十二条原则。 最优先的目标是通过尽早地、持续地交付有价值的软件来满足客户 欢迎需求变化，甚至在开发后期。敏捷过程控制、利用变化帮助客户取得竞争优势 频繁交付可用的软件，间隔从两周到两个月，偏爱更短的时间尺度 在整个项目中业务人员和开发人员必须每天在一起工作 以积极主动的员工为核心建立项目，给予他们所需的环境和支持，信任他们能够完成工作 在开发团队内外传递信息最有效率和效果的方法是面对面的交流 可用的软件是进展的主要度量指标 敏捷过程提倡可持续发展。发起人、开发者和用户应始终保持稳定的步调 持续关注技术上的精益求精和良好的设计以增强敏捷性 简化——使必要的工作最小化的艺术——是关键 最好的架构、需求和设计产生于自我组织的团队 团队定期地对运作如何更加有效进行反思，并相应地调整、校正自己的行为 注意：上面我说的是这是前人根据自己修炼的过程总结出来的经验，那么也就是说只是经验，100%可以拿来自己用？那就不一定。 比如有一条原则说：情人节一定要给老婆买花？那么问题来了，没老婆怎么办？ 当然是先找个老婆。总不能买花送给别人老婆吧。 比如，上面有一条：“在整个项目中业务人员和开发人员必须每天在一起工作”， 很多时候很难，那么怎么办？第一创造条件能让业务和开发人员每天在一起工作，这个一起不一定是坐在一起，可以每天及时回复你的邮件，也可以你自己就当业务人员，那么你自己不就是每天和自己在一起？ 怎么样才算敏捷了？尽管公司实行敏捷也很多年了，这个问题，我想说我不知道怎么回答，因为我们也还在努力变得更敏捷，但是我理想中的敏捷，应该是这样子的：“草在发它的牙，风在摇它的叶，小鸟在唱他的歌，而敏捷团队的Leader静静的座在那里一句话也不用说”，此时敏捷就像空气一样充满了整个房间，知道有一天PM高了，这个时候大家说：“哎呦，最近是不是不敏捷了?” 怎么开始敏捷呢？重要的事情说三遍: 读书，实践! 读书，实践! 读书，实践!","link":"/2015/09/18/agile-2015-9-18-what-is-agile/"},{"title":"敏捷实践系列(七)：为什么你都听客户的，客户却不满意","text":"开篇 这样的场景你是不是很熟悉？客户让你做一个软件，你需要他给你写出需求，当它给你写出需求后，在你认为时间非常紧的情况下，你辛辛苦苦，加班加点，费劲九牛二虎之力，最后赶在最后时刻给客户提交了，你满怀希望等待客户给你的表扬，你万分坚信领导对你的辛苦会给予高度认可和鼓励，你觉得很快就要带一朵“小红花”时，最后你得到的是绵绵无绝期的等待，甚至是客户的不满意，这是为什么呢？这种情况在我的团队里也会出现，有时候我让改一个东西，经常得到的回复就是:”客户就是这么要求的，而且描述很清晰，不能改！”, 最后如果不改的结果就是客户不满意。 为什么我们听客户的，客户却不满意？ 客户如果说要一个 “杯子”， 我们是怎么做的？我们的很多程序员一般是这么工作的，客户说我需要一个 “杯子”，然后程序员就在网上或者生活中搜索杯子，于是程序员就得到了很多杯子，现在各种各样的茶杯，各种各样的酒杯等等，这时候程序员就按自己的喜好选中了一个杯子，聪明一点的程序员可能会衡量一下制造不同杯子的时间成本，选定以后就开始进行模仿，最后你没日没夜，加班加点终于把杯子做出来了，客户会说：怎么会做一个这样的杯子要这么久时间？ 因为市场上已经有人做出来过，所以客户就会觉得照抄应该很快，其次客户会觉得这个杯子不是他想要的，如果是抄一个别人一样的杯子，那为什么不直接买一个呢？ 客户如果说要一个”杯子”， 他要的不是一个”杯子”实际上，客户说要一个“杯子”， 他要的不是一个杯子，他要的不是用来装水的，这个就像我们对一个女孩说：“我想和你一起看明早的太阳”，我们都知道他要的不是白天而是夜晚，不是吗？ 所以，当客户说要一个“杯子”时，他要的不是一个“杯子”，因为“杯子”只是一个名词，显然客户要的不是一个名词，而是一个”动词”, 所以我们要想到的是这个杯子用来干什么？我们脑子里要想是不是几个老人在喝茶？一对情侣在喝咖啡？一个婴儿要用来喝奶？还是单身狗要用这个“杯子”？ 可见，当客户要一个“杯子”时，他要的是一种场景，一个动态的场景，一个有人使用的场景，这个场景就是用户体验，你想想老人喝茶的杯子和单身狗要用的杯子能一样吗？ 要自信的对客户说 “NO”这个还是那句话，就是“为什么你都听客户的, 客户却不满意？” 我举个简单的例子，你生病了，你到医院去看病，你告诉医生怎么给你治疗，有的人甚至是在网上查了查资料，或者曾经有别的医生给这个病开个药方，然后你给医生说你要吃什么药，还有的人拒绝血常规检查，最后他的病要么没好，要么拖的时间很长，最后你还对医生非常不满意。你想想你的客户给你提需求的时候，是不是有的时候就和这个病人一样？ 为什么医生会对你说 “NO” ，甚至不管你了呢？ 因为医生比你更知道怎么治疗，如果按你说的肯定是不行，那么回到程序开发，软件设计上，做一个程序员或者高级软件开发人员，为什么不能给客户说 “NO” 呢？因为我们比客户更知道怎么开发，我们比客户对软件更专业不是吗？ 协助客户改进需求当然，我们不能简单粗暴的对客户说 “NO”, 由于我们对软件更了解或者说更专业，我们就可以给客户一些更好的方案，由于客户对技术的不了解，经常会提出一些既耗时又非常“愚蠢”的方案，那我们需要利用我们的专业知识来告诉客户什么是更好更省时的方案，有的时候需求稍加改动会让客户体验更好，而且开发更快，我相信这样的场景在不同的项目里有很多。 最后所以，当我们拿到客户需求的时候，我们不是卷起袖子就开始编码，而是第一步想想客户要的到底是什么？他说的真的是他想要的吗？ 他想要的说了吗？我们需要知道客户的项目的远景是什么？我们需要站在整体的角度，站在更 High level的角度来看需求。 举个例子，我曾经做过的一个项目，客户说要做房间预订，还要分淡旺季，还要有Offer, 还有内部员工不同价，团队当时想的很复杂，想到了想艺龙那样的，但是当我去了客户那边了解后，他们只有5个公寓而已，而且只是给集团员工别的地方来的提供住宿从而计入别的分公司成本而已，我觉得hard code出来一个版本都够用好几年，而且这样的话，原来的估计至少得半年以上吧，当你清楚客户最终需要啥的时候最多两个礼拜就弄完了。 总之，听客户没错，但是无脑的听客户的，完全听客户的就有问题了，就像如果你完全听你媳妇的，然后她错了后，她会说：“我让你那样做，你就那样做吗？你自己脑子是干什么的!”","link":"/2016/01/01/agile-2016-1-1-why-fully-follow-customer-is-wrong/"},{"title":"敏捷实践系列(八)：单元测试及最佳实践","text":"前言 在工作中或者在面试中，我经常碰到的开发人员就是对单元测试不重视，这一类基本上都表现出了一种“无知的自信”，总觉得自己写的代码质量很高，直到一次次虫子(Bug)把自己咬的头破血流时，才发现原来自己的代码已经到了剪不断理还乱的状态，而每一次修改一个bug，都需要走一遍“墨镜迷宫” （看上图)。还有很多人知道单元测试或者写出了单元测试，但是就是写了一个方法，上面标注了一个[Test]属性而已，甚至很多的人单元测试上面标注的是[IgnoreTest], 每次看见这些，我都深深的感到推行单元测试之路是艰难的，是遥远的，但是我依然坚信是是渴望也可及的，只要有着深深的信念，坚强的意志，无谓的勇气，一头扎进去泥巴堆里，假以时日，当大雨来临，必将带走泥巴，从此你拔剑扬眉，哦，你不用拔剑了，因为你就是剑。。。 为了让更多人能够拔剑扬眉，也为了我们公司刚入职的新人做一些培训，我精心准备了单元测试的一些知识，在此为你奉上，我尽量用简短的语句来描述，如果你不清楚我说的某一些点，那么欢迎你发邮件给我 wangdeshui@outlook.com，我可以针对集中的点发篇文章，如果你想知道我说的所有点怎么实践，那就联系我，试试加入到我们公司来。 前言 什么是单元测试 为什么要使用单元测试 单元测试难以推动的原因 太花时间 测试不是我的工作 系统可测试性差 单元测试最佳实践 实践一: 三到五步 实践二： 运行快速 实践三：一致性 实践四：原子性 实践五：单一职责 实践六：独立无耦合 实践七：隔离外部调用 实践八： 自描述 实践九： 单元测试逻辑 实践十： 断言 实践十一：产品代码 最后，单元测试常用技术及工具 什么是单元测试单元测试是开发者编写的一小段代码，用于检验被测代码中的一个很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为。 执行单元测试，是为了证明某段代码的行为确实和开发者所期望的一致。因此，我们所要测试的是规模很小的、非常独立的功能片段。通过对所有单独部分的行为建立起信心。然后，才能开始测试整个系统。 为什么要使用单元测试 单元测试使工作完成的更轻松 单元测试使你的设计更好 大大减少花在调试上的时间 能帮助你更好的理解代码 没有单元测试 任何代码都是在假定其他代码是正确无误的情况下编写的。 修改一处代码时无法得知会对其他代码产生怎样的影响。 任何一处改动都需要进行功能级别的整体调试。 单元测试难以推动的原因太花时间很多人认为单元测试很花时间，但是想想我们在下面几点话的时间，我经常看到为了测试一个简单的API方法，我们很多人必须让前端跑起来，甚至自己写一个客户端才能调用 调试上花的时间 对自认为正确的代码，花了多少时间确认代码是正确的。 定位Bug所耗的时间 测试不是我的工作很多人认为测试不是自己的工作，但是想一想每次测试提出一个bug所花的时间，以及你改bug所化的时间，所以下面2点是很重要 内在质量的重要性 测试应该是辅助，好的软件是开发设计出来的，不是测试出来的 系统可测试性差 系统耦合度很高，我们需要提高我们的团队的设计能力。 单元测试最佳实践实践一: 三到五步 SetUp 输入 调用 输出 TearDown 实践二： 运行快速###为什么？单元测试运行很频繁，是辅助开发的，在开发过程中运行，如果慢影响很大 多快较好？ 单个测试小于200ms 单个测试套件小于10s 整个测试小于10分钟 实践三：一致性任何时候同样的输入需要同样的结果 Date date=new Date() Random.next() 这样的代码都需要Mock掉，不然时间每次都不同，结果就会不一样。 实践四：原子性** 所有的测试只有两种结果：成功和失败**不能部分测试通过 实践五：单一职责一个测试只验证一个行为 ** 测试行为，不要测试方法 ** 一个方法，多个行为 —–&gt; 多个测试 一个行为，多个方法 —– 一个测试 这里的一个行为，多个方法一般指这个方法调用private, protected, getters, setters 多个Assert只有在测试同一个行为时可以接受 实践六：独立无耦合单元测试之间无相互调用 单元测试执行顺序无关 不同的顺序无影响 单元测试之间不能共享状态比如一个测试里设置了一个属性值，然后在另外一个测试里用，如果必须共享可以放到Setup里 实践七：隔离外部调用 单元测试需要快速运行，且每次结果一致，所以需要隔离一切对外部的调用。 不使用具体的其它真实类，就是不要new 不读数据库 不读网络 不读外部文件 适当时候可以构造一个相同的内部文件来Mock 不依赖本地时间 不依赖环境变量 实践八： 自描述 单元测试是开发级文档 单元测试是方法的描述 实践九： 单元测试逻辑 单元测试必须容易读和理解的 变量名，方法名，类名 无条件语句,无Switch办法：分解if到多个测试，所有的输入都是已知的，所有的结果都是一定的（Mock） 无循环语句 无异常捕捉** 测试预知的异常，用ExpectedException方法 ** 实践十： 断言 断言信息最好包含Business Information 断言信息包含出错的具体信息如果失败 适当时候可以封装自己的Assert比如： Assert.IsProgrammer(Jack) Return Jack. Cancooking() &amp;&amp; Jack.CanCoding() 实践十一：产品代码 产品代码无测试逻辑 不能有： If(global.IsTest){…} 测试代码和产品代码要分离 不要在产品代码里有任何只供测试用的代码 使用依赖注入 最后，单元测试常用技术及工具下面是.NET程序常用的单元测试需要的技术和工具，其它语言请自信比对。 面向接口编程 依赖注入(Castle, Unity, Ninject) Moq 测试工具(xUnit) .Net Nunit 代码覆盖率测试工具Ncover 自动运行测试辅助工具NCrunch","link":"/2016/01/06/agile-2016-1-7-unit-test-best-practices/"},{"title":"拆书系列(一):《创业维艰》之简介","text":"做分公司已经快五年了 ，虽然离真正创业还十万八千里，但是从一开始做分公司的时候，我就以 “创始人” 的心态来做的，如果一开始”兴趣”和”冲劲”多一些，但是随着你经历的事情越来越多，越来越多经历一些你不曾想过的事情，你会发现兴趣或者冲劲和做好一个公司之间离着十万八千里，就拿最近一年公司的一些奇葩事情，让你对人性都有了更多的认识，这个时候，我发现作为一个公司的负责人，身上需要的修炼的品质太多了，这些包括心态、包容、冷静、激情、智慧、领导力等等，我面临着不小的压力，而一个负责人很多时候是孤独的，你的事情很难别人帮你或者思考，于是我开始读了不少书籍，**&lt;&lt;创业维艰&gt;&gt;这本书从标题上就让我找到了认同感，而且英文名是“The hard Thing About Hard Things”** 如何完成比难更难的事, 于是我就迫不及待的用了一个周末的时间读完了，下面就记录了我对本书的介绍和读书笔记。 作者简介本.霍洛维茨，硅谷最早一批做互联网的，1999年与网景之父马克.安德森共同创立Loudcloud公司，在互联网泡沫时，多次带领公司起死回生，最后把公司16亿美元高价没给了惠普。后来有成立了风险投资公司，投资了Skype, Facebook,Instagram, Twitter, Pinterest, Airbnb等等知名互联网企业，被称为”硅谷最牛的50个天使投资人”之一。 艰难创业书的第一部分讲述了作者艰难的创业，一开始加入网景，但是竞争对手是微软的IE浏览器，98年买给了AOL, 99年作者创办了Loudcloud, 融资，扩张，但是我们知道99年正是互联网泡沫时期，泡沫破灭后，难以融资，走途无路时，决定上市，但是上市后股价从6美元降到2美元，一系列努力让股价变好后，有来了911的事件，最后破产，LoudCould被卖掉，留下了Opsware软件，上市后估计跌至0.35,如果股价不能提到1美元，公司就完蛋了，作者经过了一些列的努力让股票回到了8美元，最终以14.25亿美元买给惠普赚取了第一桶金，随后作者和马克.安德森创办了风险投资公司，投资开头说了那些至今都依然闪耀万丈的互联网公司。 第一部分主要是创业故事，需要大家自己品读，下面我读书此书时记录的文中一些不错的文字。 对于一家企业来说，真正的难题是什么呢？真正的难题并不是设置一个宏伟的、难以实现的、大胆的目标，而是你在没有实现宏伟目标之时不得不忍痛裁员的过程。真正的难题不是聘请出色的人才，而是这些“出色的人才”逐渐滋生一种优越感并开始提出过分的要求。真正的难题不是绘制一张组织机构图表，而是让大家在你设计好的组织结构内相互交流。真正的难题不是拥有伟大的梦想，而是你在半夜一身冷汗地惊醒时发现，梦想变成了一场噩梦. 人们经常问我，我们两人在18年里更换了3家公司，却一直保持着极高的工作效率，这是怎么做到的。大多数合作关系要么过于紧张而令人难以忍受，要么紧张不足而缺乏效率。人们要么相互挑战，导致彼此交恶，要么陶醉于彼此的奉承之词而无所受益。就我和马克而言，即使是18年后的今天，他依然对我的想法吹毛求疵，让我感到烦恼，我对他亦是如此。但事实证明，这种方式对企业的发展有益无害。 无论是谁，你的人生需要两类朋友。第一类是当你遇到好事时，你可以打电话与之分享喜悦的朋友。他的喜悦不是那种蒙着羡慕、嫉妒面纱的虚假喜悦，而是发自内心的真诚喜悦。第二类是当你身陷困境时，你可以打电话与之分担、向其倾诉的朋友。 研发出好产品是创新者的职责，而不是客户的任务。 客户只知道根据对现有产品的体验来判断自己想要什么。 在每周的员工会议上，我加入了一个名为“我现在没有做什么？”的议程。通常，在员工会议上，大量的时间都用来进行回顾、评估以及改进员工们所做的事情，如研发产品、销售产品、服务客户、聘用员工等。然而有时候，你没有做的事却是你真正应该关注的事。 创业公司的CEO不应该计算成功的概率。创建公司时，你必须坚信，任何问题都有一个解决办法。而你的任务就是找出解决办法，无论这一概率是十分之九，还是千分之一，你的任务始终不变。 人们总是问我：“当一名成功的CEO的秘诀是什么?”遗憾的是，根本没有秘诀。如果说存在这样一种技巧，那就是看其专心致志的能力和在无路可走时选择最佳路线的能力。与普通人相比，那些令你最想躲藏起来或干脆死掉的时刻，就是你作为一名CEO所要经历的不同于常人的东西。 大多数管理书籍的重点都是如何正确地做事，不要将事情搞砸。但我的经验却是，把事情搞砸之后，如何深刻理解那些你必须要做的事。","link":"/2016/08/01/books-2016-08-01-book-the-hard-thing-about-hard-things/"},{"title":"拆书系列(二):《创业维艰》之创业中的挣扎","text":"创业中的挣扎创建公司之初，每一位企业家都怀揣着一个清晰明确的成功梦想。你会创造一个极其优越的环境，雇用最能干的人加入你的团队，你们会齐心协力，研发一款令客户满意的产品，让这个世界变得更美好。 为了使梦想成为现实，经过了无数个日夜的辛苦奋斗，你却发现，事情并没有按计划进行。从一开始，你的公司就没有跟上你所设想的步伐。你的产品出现了难以解决的各种问题，市场和你想象的大不相同，你的员工正在失去信心，有些人已经辞职。在辞职的员工中，有些人还是非常优秀的，他们的离去令剩下的人们开始怀疑继续留在公司是否明智。资金越来越少，风险投资家告诉你，由于近在眼前的欧洲经济危机，你的公司将很难筹集到资金。在一次竞争中，你输给了对手，失去了一个忠诚的客户，失去了一名极出色的员工。你的压力越来越大。究竟是哪里出问题了？你的公司为什么没有按预想的轨道运转？你真有足够的能力去实现梦想吗？当梦想变成了噩梦，你会发现，自己陷入了旋涡之中。 关于挣扎挣扎是你想知道自己为什么要创办公司时的状态。 挣扎是人们问你为什么不退出，你却不知怎么回答时的状态。 挣扎是你的员工认为你在撒谎，而你却认为他们也许说得对的状态。 挣扎是你食之无味时的状态。 挣扎是你认为自己不应该当公司CEO时的状态，是你明知自己力不从心、明知无人能取代你时的状态，是所有人都认为你是白痴却没有人会炒你鱿鱼的状态，是自我怀疑变成自我憎恶时的状态。 挣扎是你在和别人谈话却听不到对方在说什么时的状态，因为你一直在挣扎。 挣扎是你想结束痛苦时的状态。挣扎就是痛苦。 挣扎是你去度假，想放松心情却使心情更差时的状态。 挣扎是你周围簇拥着一大群人，你却感到茕茕孑立、形影相吊时的状态。挣扎是冷酷的。 挣扎是违背承诺、粉碎梦想的地狱，是一身冷汗、五内俱焚的感觉。 挣扎不是失败，但会导致失败。如果你孱弱不堪，你更容易失败。 大多数人都不够强大。史蒂夫·乔布斯到马克·扎克伯格，所有出色的企业家都会经历挣扎，而且是苦苦挣扎，因此，人人都会挣扎。不过，这并不意味着你一定能挣扎成功。你也许会挺不过去，这就是挣扎的恼人之处。 挣扎是成就伟大的竞技场。 #如何走出挣扎 不要扛下所有责任。人们很容易想当然地认为，令自己烦恼的事情一定会令自己手下的人更加烦恼。事实恰恰相反。除了负有最大责任的人以外，没有人会把损失当回事，没有人比责任人更感同身受。当你无法分担所有负担时，你要将某些负担分担出去，找尽可能多的人来共同解决问题，即使这些问题事关企业的生死存亡。 这不是国际跳棋，而是国际象棋 科技行业往往极其复杂。底层技术只要一有变动，竞争就会发生变化，市场也会随之发生改变，而人们则会使出各种招术，以求自保。因此，就像《星际迷航》中下三维国际象棋一样，总有一步棋可走。你认为自己已经无路可走了吗？你觉得这步棋怎么样：作者凭着200万美元的后续收益以及340名员工的阵容带领公司上市，计划在下一年实现7500万美元的收益？作者走的就是这步棋。那是2001年，人们普遍认为，对一家要上市的科技公司而言，这是有史以来最糟糕的时机。走这步棋时，作者手头只剩下能维持公司运营6周的资金。天无绝人之路，总有一步棋可走。 只要坚持下去就有转机。在科技型竞争当中，明天和今天看起来完全不同。如果你能坚持到明天，也许就会发现，在今天看来似乎毫不可能的解决办法会赫然出现在眼前。不要过分苛责自己。公司身陷困境也许都是你的错，因为人是你雇来的，决定是你做的，而且接受任务时，任务的风险性你是知道的。每个人都会犯错，每位CEO都会犯无数错误。要正确评估自己，过分苛责自己于事无补。 请记住，这是区分男人和男孩的方法如果你想成就一番事业，这就是挑战。如果你不想，那你根本不应该开办公司","link":"/2016/08/02/books-2016-08-02-book-the-hard-thing-about-hard-things-2/"},{"title":"拆书系列(三):《创业维艰》之CEO必须实话实说","text":"鼓励式管理造成的错觉作为公司的最高管理者，我以为我能从容应对坏消息。但事实刚好相反，面对坏消息，我比任何人都紧张。让我彻夜难眠的事，工程师们却并不在意。毕竟，我是创办公司的CEO，是那个和公司息息相关的人。一旦发生可怕的差错，他们可以一走了之，我不能。因此，面对损失，员工们会更加冷静。 更愚蠢的是，我以为我唯一的职责就是为公司解决问题。如果我早就想明白这一点，我就会意识到，只有我一个人操心，根本没有任何意义。例如，担心这个产品不够完善，但实际上，编写代码修复产品的人不是我。 更好的办法是，将问题交给不仅有能力修复产品，而且对修复产品充满兴趣和动力的人。假如我们失去了预期的一笔大交易，整个公司必须搞清楚其中的原因，这样才能共同解决我们在产品、营销和销售流程中出现的各种问题。如果坚持将问题留给自己，那么问题就很难被解决。 为何要实话实说？对公司出现的问题做透明化处理很重要，主要原因有三： 信任没有了信任，沟通就会中断。具体来讲就是： 在人类的所有交往之中，沟通量与信任程度成反比。 请考虑下述情况。如果我完全信任你，我就不需要你对自己的行为或其他举动进行解释，因为我知道，你所做的一切，无论什么，都符合我的最大利益。反之，如果我不信任你，那么再多的谈话、解释或说理对我都没有任何影响，因为我不相信你说的是真话。 在公司里，这一点十分重要。随着公司的成长，沟通成了公司最大的挑战。如果员工完全信任CEO，沟通的效率就会大大提高。实话实说就是建立这种信任的关键。一名CEO在一段时间内拥有这种被信任的能力，往往是一家管理良好的公司和一家管理混乱的公司之间最大的差别。 参与解决问题的人越多越好为了创建一个出类拔萃的技术公司，你必须雇用大量的精英人才。而不让这些精英人才参与解决公司最大、最棘手的问题完全是一种浪费。一个人，无论多么出色，他都无法解决自己不了解的问题。正如开源社区所倡导的：“只要有足够多的眼睛，就可让所有问题浮出水面。” 健康的企业文化就像过去的路由信息协议：好事不出门，坏事传千里允许自由并公开讨论问题，公司才能迅速解决问题。企图掩盖问题只会令所有员工感到灰心。因此，CEO应该采取的做法是：建立一种奖励文化，而不是惩罚文化，对那些公开提出问题并为其找到解决办法的人予以奖励。 最后一点想法：只有经营过公司，你才会体验到那种巨大的心理压力，才不会过于乐观。作为CEO，你要勇敢面对压力，直面恐惧，实话实说。","link":"/2016/08/03/books-2016-08-03-book-the-hard-thing-about-hard-things-3/"},{"title":"拆书系列(四):《创业维艰》之如何解雇员工","text":"如果非要让我说一件事情是可以让管理者水平有明显提升的事情，那就是学会解雇员工，今年我解雇了一个”伪工作者”，这件事我做的不够好,如果让我之前仔细研读了这本书，那么我相信结果或者说过程会有大有不同。 要想保持企业文化的延续性，留住最优秀的员工，我们要在裁员时采取了正确的方式。下面是我从本书学习到的如何解雇员工 保持头脑清晰如果公司没能实现自己的财政计划，形势严重到了必须辞退那些不惜重金聘请而来的员工的地步，这对CEO而言，无疑是巨大的压力和沉重的负担。在这样的时刻，我们很难顾及未来，因为过去会将你压得毫无喘息之机，而这正是你必须要面对的。 当机立断一旦决定解雇，那么必须尽快执行。如果走漏消息，就会横生枝节，麻烦不断。员工会质询管理者，公司是否要裁员。如果管理者不知情，员工就会认为他愚蠢。如果知情，他要么不得不向员工撒谎，令消息进一步走漏，要么保持沉默，令群情更加激愤。 对解雇的原因要有清晰的认识不管是因为经营不善，还是员工绩效表现不佳，都必须实话实说。 对管理人员进行培训整个裁员过程中最重要的一步就是培训管理团队。如果将未经培训的管理人员置于裁员这一极为尴尬的情境之中，他们大部分都会无法应对。 对管理人员的培训需遵循一条黄金法则：自己的员工要自己亲自辞退，不能将这项工作推卸给人力资源部门或某个更严厉的同事，不能像电影《在云端》中那样雇用一家外包公司来完成。 为什么这么严格？为什么不能找些强势的管理者出面，替你完成这一棘手任务？公司的声誉和管理人员的声誉都取决于你的表现 解雇时说话要果断，这是一次解雇行为，使用”我已经决定” 而不是”我认为”这样含糊不清的话。 向公司全体人员发表讲话在执行辞退决定之前，CEO必须向公司全体人员发表讲话。CEO必须为管理者们解释辞退的合理性。如果这一点做得好，管理人员在辞退时就会更加容易。务必牢记财捷集团前CEO比尔·坎贝尔告诉我的一句话：话是说给那些留下来的人听的。这些人会非常关心你对待他们同事的方式。你辞掉的员工之中，有很多人都和留下来的人关系亲密，因此，你一定要给予他们足够的尊重。毕竟，公司还要向前发展，因此你必须把握尺度，不要过度表达歉意。 一定要让大家看见你，你一定要在公司出现在向公司全体人员发表讲话、告诉大家许多人将被辞退之后，你也许会不愿意在公司里四处走动，和大家交谈，而更愿意去喝几杯酒。千万别这样。一定要在公司出现，一定要让大家看见你，一定要积极参与公司事务。","link":"/2016/08/04/books-2016-08-04-book-the-hard-thing-about-hard-things-4/"},{"title":"拆书系列(五):《创业维艰》之为何要解雇高管","text":"这里的 “高管” 我们也可以理解为重要项目中重要的人。 解雇”高管”，我们可以说他们表现糟糕，但是既然要解雇，说这些已经于是无补，事实上出现这种情况是因为自己很差劲，解雇高管是因为公司面试和整合系统出了问题，我们必须找出原因，才能避免以后这类事情的发生，可能的原因如下： 对高管的职责定位不清。连自己想要什么都不知道，更别说招聘高管的标准了。很多时候，CEO们仅凭自己对高管这一职位不切实际的想法和主观感觉来进行招聘。这种错误的做法往往导致所招高管缺乏关键的、必要的才能。 招聘高管时，看中的不是对方的长处，而是对方没有弱点。在进行群体面试时，这种做法尤为普遍。招聘小组往往在应聘者身上吹毛求疵，并不关注他是否具备你所需要的、作为一名世界一流的管理者的特质。因此，以这样的方式招来的高管也许没有明显缺点，但在你需要他大显身手时却表现平庸. 如果你招聘的人不具备你所需要的世界一流的实力，你的公司也就成不了世界一流的公司。 大和小庙偏招尚。一直以来，风险资本家和高管招募人员给CEO们的错误建设是：要按高于招聘的原则招人。他们会说，“想想未来的3~5年，公司规模将会有多大”。如果公司规模很大，那么能招到一个有本事运作大规模公司的人，这当然再好不过。如果打算快速壮大公司规模，那么能招到一个内行的人也很有必要。但是，如果公司规模不大，而且你也没打算壮大公司规模，那么招的人只要能胜任接下来的18个月的工作即可。如果你要招的人在18月后才会崭露锋芒，那么还没等他有机会一展才华，公司就会将其拒之门外。因为公司其他员工肯定会心有不平：他有没有做出任何贡献，我们凭什么要给他优先认股权？这类问题会频频出现。 事实证明，风险资本家和高管招聘人员说的也有一定道理，他们只是从以前的失败中吸取了错误的教训而已。 对招聘职位一概而论。世界上并没永远了不起的CEO、营销负责人或销售负责人。这名销售负责人的了不起之处仅限于在你的公司，在接下来的14~24个月之内。他的这一职责和微软公司或脸谱网（Facebook）的同一职位并不相同。不要招那种类型化的应聘者，这不是拍电影。 管理人员个的人抱负和公司目标相悖。如果人员的个人抱负和公司目标相悖，就算他的才华再出众，公司也应该将其拒之门外。 没能令管理人员融入公司。将新人引入公司并委以重任非常困难。其他员工很快会对其评头论足，该新人的期望也许和你不同其对工作在很大程度上也许并不明确。因此，在解雇高管之后，一定要检查并改进公司的人才招聘计划。 有关公司规模的特殊情况解雇高管的一个相当普遍的理由是，当公司规模扩大到原来的4倍，高管的工作效率就会变低。因为在这时，管理工作就会变成全新的工作，每个人都需要重新定位自己，以适应新的工作。经营一家有着200多名员工的全球性销售公司和一个只有25人的本地销售团队大不相同。幸运的话，你雇来的25人团队的人也许会慢慢学会了管理200人的团队。如果不走运，你就要为新的工作任务另聘合适的人选。这既不是管理人员无能，也不是公司系统错误，这是现代社会的真实生活。不要试图避免这种情况，这只会让事情变得更糟。 有关公司快速扩大规模的特殊情况如果你研发出一款非常棒的产品，市场也很需要这款产品，你就会发现，自己迫切希望公司以极大的速度发展壮大。要想成功实现这一愿望，除了聘用合适的管理人员之外，别无他法。所谓合适，是指这个人曾有令其他规模相当的公司迅速壮大的成功经验。请注意，这与直接继承一个规模很大的公司或以你自己的方式运行一个规模很大的公司完全不同。一定要确保你聘用的是有快速发展能力的管理者。此外，如果你还没有准备给他们大量的预算去发展他们的组织机构，那就不要聘用他们，让他们保持当前状态即可。经验丰富的、有快速发展能力的管理者对建设成功的创业公司来说非常重要，以至于招聘者和风险资本家往往还没有等公司准备好，就极力建议CEO们将他们招进公司。","link":"/2016/08/05/books-2016-08-05-book-the-hard-thing-about-hard-things-5/"},{"title":"拆书系列(六):《创业维艰》之员工培训","text":"我们都知道，员工培训是非常重要的，可以让员工尽快具备岗位技能，也对员工个人成长大有帮助，不过风险就是，在中国这个市场环境里，培训很可能就是为别人做嫁衣，好不容易你辛辛苦苦带人，投入大量精力和成本培养人，最后别的公司直接拿去用，比如你付出了巨额的成本，但是别的公司仅用你培养成本10%的涨薪就可以轻松把有些人挖走，虽然被挖走的人N年后还是一样继续原来的那点积累（因为不想自己培养的，也别指望你去了会培养你），但是公司却实实在在遭受的损失，所以对那些还在花力气培养人才的公司，我们要怀着一份敬意，如果所有的公司都不愿意培养人，而是直接去挖，那么行业将慢慢无人可用，我今年招了几个社会实习生，有几个就是来蹭培训的，后来意味自己学了很多东西，在我看来只是刚刚学了几个API，还没入门就要远走高飞，我只能祝他们在新的岗位上能大放异彩吧。 为什么要进行培训？ 培训确实能够提高公司的生产力，也更容易推进绩效管理，提高产品质量。 培训非常有利于员工留任。 员工离职，排除一下经济原因，公司的业务原因，工资原因之外，下面有两个常见的原因： 第一，他们讨厌自己的管理者。 缺乏指导、 职业发展前景不明朗、 收到的反馈多为负面的，这些因素通常会令员工感到惊恐不安。 第二，学不到东西：公司没有投入资源，帮助员工学习新的技能。 如何对员工进行培训？最好的培训导师是CEO本人，作者写的很多培训文件至今还在被人们使用。比如：好的产品经理和坏的产品经理。 1.职能培训。最好从与员工最密切的话题开始：胜任自己工作所需要的知识和技能。培训具有强制性。 2.管理培训。为管理团队设定期望时，管理培训是最佳着手点。这些课程会告诉管理者如何按照你的期望办事。 3.其他培训机会：邀请各路精英，分享自己的拿手技能。与谈判、面试和财务等相关的培训不仅能加强公司在这些方面的能力，还能鼓舞员工的的士气。 管理者只有两种方法可以提高员工的产出：激励和培训。","link":"/2016/08/06/books-2016-08-06-book-the-hard-thing-about-hard-things-6/"},{"title":"拆书系列(七):《创业维艰》之招聘","text":"可以从朋友的公司挖人吗？这里的朋友是直： 重要的生意伙伴 朋友 从朋友公司挖人的一个理由经常是：反正他们也在找新工作。 替你的朋友想想，这个时候他肯定在为公司的生死存亡而奋战，没有什么比失去一个优秀员工而让人伤心，而且其它员工会把这当做公司没落的征兆，更让你朋友觉得打击的时，他其它员工会认为连他的朋友都挖他的墙角。 思考这种动态关系有一个简单的方法：如果你丈夫离你而去，你希望自己最好的朋友和他约会吗？他肯定会和其他女人约会，所以，让你的朋友得到他难道不好吗？这看似符合逻辑，但其实并非如此，你肯定会失去朋友。 1.除非该员工极其出色，否则你无论如何也不要从朋友的公司挖人。 2.“挖人的反身性原则”：某公司挖走你的几名员工，会让你惊恐震惊，那么你就不应该挖他们公司的任何员工。 3.制定政策：将那些规定未经CEO（或高级主管）同意，不得雇佣其员工的公司名单列举出来。在录用前，要保持公开，并与其所在公司的CEO进行沟通，对他进行背景调查。 4.当你告诉你的朋友从他公司挖人了，就意味他都不如这名员工对你重要，别指望你们还能继续做朋友。 处理这种情况的最佳方式就是公开透明。看清了雇用出色员工和背叛珍贵友谊之间的矛盾之后，你就应该将事情公开，告诉员工，你和他现在所属的公司有重要的生意往来，在录用他之前，你必须和他所在公司的CEO进行沟通，对他进行背景核查。告诉他，如果他不同意，你会立即中止录用，并对此保密。在录用之前，要和朋友进行交谈，这样才能更好地判断录用他的员工对你们的关系所带来的影响。此外，你还有可能避免用人不当，因为往往有些应聘者在面试中表现极佳，但进入公司之后，表现却不尽如人意。 如何避免大公司主管难以胜任小公司工作的情况发生？第一，在面试过程中将具有破坏性的不匹配情况筛选出来。雇用一名大公司主管之后，你会面临两种危险的不匹配情况： 节奏不匹配。这样的主管已经习惯于等待邮件到达，等待电话铃声响起，等待会议被安排得井井有条。在你的公司里，他会长时间处于等待状态。 如果这位新主管总在等待（根据他自己的受训经验），其他员工就会充满疑虑。你会听到这样一些言论，如那家伙整天都在干什么？ 技能不匹配。管理大公司需要的技能和创建新公司大不相同。管理大公司时，你往往对这些任务比较擅长，例如复杂的决策制定、次序优先、机构设计、流程改进，以及部门交流。创建公司时，没有机构需要设计，没有流程需要改进，部门之间的交流非常简单。但同时，你必须能够非常熟练地实施高质量的招聘流程，具备丰富的专业领域知识（你自己负责质量控制），懂得如何从零开始创建流程，而且在把握新方向、制定新任务方面要非常有创造力。 如何筛选？ 你可以询问如下几个问题： 1.“你上班第一个月会干什么？”——如果答案是要用一个月去适应和了解，那么这样的人不要聘用，因为小公司没有那么多需要了解的。 2.“这份新工作和你目前的工作有什么不同？”——挑选那些能意识到工作差异的应聘者。 3.“你为什么要加入一个小公司？”——想加入你的公司的正当理由是渴望变得更加有创造力。 将新人的融入和面试看得同等重要。积极帮助新人融入公司。1.促使他们积极创造。每日、每周，甚至每天给他们制定目标，确保他们做出相应的贡献。 2.确保他们明白自己的职责所在。如果30天后，你觉得他们还没有掌握情况，就要毫不犹豫地解雇他们。 3.把他们放入集体。给他们列一份他们需要认识并向其学习的员工名单，并要求他们提交一份汇报，汇报自己从这些人身上学到了什么。 在没有招聘经验的时候，怎样才能招到优秀的人才？知道自己要什么**你必须意识到自己非常无知，不要妄想仅靠面试应聘者就能学会如何招聘。虽然面试过程对你可能很有启发意义，但将其当作唯一的知识来源却很危险 **。这样做会让你很容易落入下面的陷阱： 第一，凭外表和感觉聘人。 第二，挑选与众不同的人才。你会想象一个完美的主管形象，然后把实际应聘者和你理想中的形象进行对应。这一观点之所以错误有以下几点原因：首先，你不能雇用一名想象中的主管来管理一个充满可能性的公司。你必须为处在其次，你想象中的主管形象往往都是错误的。你设想的这个形象的基础是什么？最后，让招聘团队理解这么抽象的一套标准极其困难。其结果是，每一个人都想在应聘者身上寻找与众不同的东西。 第三，看重的是应聘者身上没有弱点，而不是其长处。经验越丰富，就越清楚公司里的每个员工都有严重的缺点（包括你自己）。金无足赤，人无完人。因此，招聘时要看重应聘者的长处，而不是其身上没有弱点。每个人都有弱点，只不过有些人身上的弱点比较明显而已。因为其人没有弱点而对其加以聘用意味着你将愉快感作为优先考虑的因素。当然，你必须清楚自己需要应聘者具备什么能力，然后找出具备这种能力的人，忽略他在其他方面的弱点。, 当然人品差的人就不要录用了。 想知道自己需要什么样的人才，最好的方法是在该职位上亲自体验一番。 不是名义上的，而是真正履行职责。 CEO往往不愿意干职能性工作，因为他们担心自己缺乏相应的知识。这种担心恰恰是你应该干这类工作的原因——学会相应的知识。的确，亲自体验是获得招聘所需要的所有知识的唯一方式，因为你要为公司寻找合适的主管，而不是普通主管。 第四，引进专家也十分有益。 如果你认识一位出色的销售主管，先和其进行面谈，了解他获得成功的原因，搞清楚他的哪些能力最符合你公司的需要。如果可能，将该领域专家纳入面试流程。不过，要注意，这些专家并不完全符合招聘条件。也就是说，他对你的公司缺乏了解，不知道公司的运作模式以及公司的需要。因此，不能将决定都推给专家来做。最后，你心里要清楚自己对加入公司的人有什么期许。这个人在第一个月会做什么？你期望他加入公司的动机是什么呢？你想让他立刻扩大部门规模，还是在下一年只招一两个新人？ 控制招聘流程1.写下你想要的能力，以及你愿意忍受的缺点 一名主管很可能收到其它团队成员的喜欢，但工作起来却毫无效率，同时他也可能工作十分高效，影响十分深远，却受到大家的鄙视，但是后者明显要很多。 2.设置检验招聘标准的问答题目 3.组成面试小组 4.秘密调查和公开调查 单独做决定只有CEO能全面了解招聘标准，制定招聘标准的基本根据，面试官和应聘者推荐人反馈回来的所有意见，以及各类持股人的相对重要性。","link":"/2016/08/07/books-2016-08-07-book-the-hard-thing-about-hard-things-7/"},{"title":"拆书系列(八):《创业维艰》之有效的人力资源管理","text":"具有讽刺意义的是，管理技术部门最先懂得：一个管理出色的质量控制部门无法生产一款高质量的产品，却能告诉你产品研发团队何时生产了一款质量低劣的产品。类似情况是，一个高质量的人力资源机构无法给你创造一个管理完善、企业文化成熟的公司，却可以告诉你，你和你的管理者何时没有尽到职责。 招聘 你非常清楚每一个公开职位所需要的技能和才干是什么吗？ 你的面试官准备得充分吗？ 你的管理者和员工有没有向求职者积极介绍公司的情况？ 面试官们能按时到场吗？ 管理者和招聘人员会及时联系应聘者吗？ 你能和最强的公司展开强有力的人才竞争吗？ 报酬 就你公司的统计数据而言，你享受的福利合理吗？ 和与你展开人才竞争的公司相比，你的薪水和股票期权福利如何？ 相对于你的薪酬制度，你的绩效排名如何？培训与融合 聘用员工之后，从该员工及其同事，以及管理者角度而言，他需要多长时间才能体现出生产力？ 加入公司之后，员工需要多长时间才能清楚公司对他的期望？绩效管理* 你的管理者会给予自己的员工前后一致、清晰明确的反馈吗？* 你公司的书面绩效评价报告质量如何？ 你公司所有的员工都能按时收到自己的绩效评价吗？ 你能有效地管理工作表现不佳的员工吗？ #工作动机 你的员工来上班时激动兴奋吗？ 你的员工对公司使命怀有坚定的信念吗？ 他们每天喜欢上班吗？ 有没有员工消极怠工？ 你的员工清楚公司对他们的期望吗？ 员工们是安心留在公司还是辞职人数比往常更多？ 员工们为什么辞职？ 有效人力资源的几项要求流程设计师人力资源主管颇有点儿像质量监察部门的主管，他必须精通流程设计。准确衡量重要管理流程的一个关键是，看其是否具备出色的流程设计和严格的流程管理。 真正的外交官没有人喜欢打小报告的人。如果管理团队对其缺乏完全信任，人力资源部门不可能有效地开展工作。管理者必须相信，设立人力资源部的目的是帮助自己改进工作，而不是对自己进行监管。优秀的人力资源主管会真心实意地为管理者提供帮助，不会因为发现了问题而大肆表功。他们会直接找管理者解决问题，提高管理质量。 如果人力资源主管将自己的知识深藏不露，玩弄权术，或搞阴谋诡计，那他就毫无用处。 行业知识专家薪酬、福利、最佳招募方法等变化极快，人力资源主管在行业之中必须建有深厚的关系网，对所有最新情况了如指掌。 CEO信任的智慧顾问感觉灵敏的人当公司管理质量开始下滑，所有人对此毫无觉察，但感觉极其敏锐的人却能察觉出公司正在走下坡路。你需要这样一个人。","link":"/2016/08/08/books-2016-08-08-book-the-hard-thing-about-hard-things-8/"},{"title":"拆书系列(九):《创业维艰》之关注眼前的麻烦","text":"如何最大限度减少办公室政治 我所说的政治，是指员工在职场进阶的过程中，依靠手段，而非业绩和贡献为自己谋取空间。 几乎所有的办公室政治都是由公司老板开的头。你可能会觉得委屈：“我讨厌政治，不爱耍手腕，但是我的员工们却乐此不疲，这跟我他妈没有一点关系。” 其实你错了，公司内部的办公室政治并不在于你本人是否爱耍手段。而事实上，正是那些缺乏政治头脑的老板们却常常带出一支善于勾心斗角的队伍，因为他们常常在不经意间助长了公司内部激烈的政治斗争。 办公室政治是如何产生的？公司CEO无意间对政治行为的鼓励或放任，往往是办公室政治的源头。 就拿给管理人员定薪酬为例来说吧，如果那些资深员工时不时地找你要求加薪，示意你他们的所得远远低于应得，甚至暗示你他们手头还有别家公司伸出的颇具诱惑力的橄榄枝，你会怎么办？ 如果对方的要求合情合理，你也许会酌情考虑，然后给他加薪。这种做法听起来无可厚非，但其实你已经就此为办公室政治的蔓延埋下了祸根。 这样说吧，你对员工的加薪对促进公司的发展没有任何作用。员工获得加薪是因为他提出了加薪的要求，而并不是因为他真的工作十分出色。 你这样做的后果有三个，我们来一一分析一下。 1.公司里其他跃跃欲试的员工很快就会照葫芦画瓢，因为没有不透风的墙。无论是这一轮竞争者还是那个先吃螃蟹的人，加薪与否都与工作表现和能力无关。你花时间考虑的，不是对方的工作业绩，而是政治问题。最终，这些资深员工的加薪标准将演变为：先到先得。 2.仅仅因为对政治手腕不敏感，公司里那些默默奉献的员工将无缘这份计划外加薪。这对他们来说，是一种极大的不公平，轻则忍气吞声，重则直接炒你鱿鱼。 3.你的员工从此次事件中总结出：会哭的孩子有奶吃，会耍手腕的员工有钱赚。于是乎，你手下的员工都开始跟你玩手段、耍手腕了，准备做好听他们的集体嚎哭吧。 如何将办公室政治的发生率降到最低？招聘员工时，要衡量对方的野心有多大。每个人都有野心，但并不是每个人都是天生的野心家。那些以公司的发展为依托，从而实现个人职业发展的野心是恰如其分的，是无可厚非的。与此相反，那些只关注个人成功而将公司利益置之不顾的人拥有的野心却是非常的不当的。 建立严格的流程来防范潜在的办公室政治，并认真执行。 业绩评估与业绩奖励 机构设置和职权划分 你需要做的，是定期考量公司的机构设置，搜集所需的信息，在下属还没发现任何预兆的时候就做出决策。决策既出，立即执行，不给小道消息和流言蜚语留一丁点儿机会。 员工提拔 在提拔某个员工的时候，他的同事肯定会揣摩他受重用的原因。究竟是因为业绩好呢，还是会耍手腕呢？如果答案是后者的话，那么他们很容易产生这样的反应：觉得自己不受重视，从而跟被提拔的员工对着干。 当心道听途说 所以，作为公司的一把手，你必须考虑到自己的言行在全公司的影响和可能会引发的蝴蝶效应。千万不要因为自己的言行，而助长公司的不良风气。 适度的野心在组建管理团队时，大多数新创业的公司都倾向于把“智商”作为选拔人才的主要标准。然而，一支智商出众但野心过盛的团队却不会对公司发展做出积极的贡献。 从宏观的角度来看，只有当资深主管们把集体成就放在个人成就之上，从全局角度而非个人角度来考虑问题时，这个公司才有可能实现利益最大化。公司利益的最大化就意味着个人利益的最大化。不然，零的1%还是零。 主管的野心指数应保持在适当的范围内，这一点相当重要，因为这是维系员工工作积极性的一个重要前提。如果一个主管对于个人前程的关注超过了对公司业绩的关心，那他手下的员工一定会想：我干吗要加班加点地为这家伙卖命？最能激发员工积极性的做法莫过于让他们怀揣使命感去工作，让他们相信这份崇高的使命值得他们把个人抱负暂放一边。所以说，能将理想抱负控制在合理范围内的主管比那些野心勃勃的家伙更有价值。 以“团队”为出发点来考虑问题的人说话时很少使用“我”，哪怕是在谈论其个人成就。在面试中，他们总会把功劳推到从前的合作伙伴身上。相对于工作待遇和职业发展，他们更关心这家公司的实力。如被问及为何离开上一家公司，他们往往会把责任归咎于自身，检讨自己判断力不佳而做出的错误决策。 彼得定律和坏榜样法则彼得定律：意即在一个集团中，员工只要表现出众，就能获得提拔，直至被提拔到一个他不能胜任的岗位。 坏榜样法则：依据该法则，一个团队内部无论哪个层面出现了滥竽充数的人，他们都会像蛀虫一样影响其他成员，最终使得能力出众的人也渐趋平庸。这条法则的原理就是：员工会拿他们上级中能力最差的那个人做参照物。 超级混蛋只有聪明还远远不够。出色的员工同样还要能吃得了苦，担得住事，并且善于和团队成员和睦共处。 公司需要选拔大量头脑灵活且责任心强的员工来发现机构运作中的漏洞，并协助解决这些漏洞。然而，有些头脑灵活的员工不但帮不了公司，反而会给公司制造更多的麻烦。出现问题时，他们不是立即找出其中亟待修复的漏洞加以解决，而是拼命挑毛病，以凸显自己的高明。具体来说，他会质疑公司的前景，贬低公司的领导者，以此来衬托自己。有这种习惯的员工越聪明，产生的破坏力就越强。也就是说，聪明人产生的危害性会达到最高点，因为人们对聪明人往往坚信不疑。 他们为什么这么做呢？ 寻求关注 天生叛逆 思想不成熟 一个公司是由集体的力量造就的，员工如果不能成为这个集体中值得信赖的力量，那么无论他的个人能力有多强，对于公司来说都是没有价值的。 恶狗咬人咬得才狠。如果你跟前有这样的恶狗，你就必须早做了断。 （这个我深有体会，今年就碰到了一个CW的恶狗） 该不该招资深人士创办技术型公司，意味着你自此开始了一段和时间赛跑的艰难旅程，这段旅程将持续至你生命的最后一刻。没有哪一家刚刚创业的技术型公司能摆脱产品“保质期”这个魔咒。再伟大的想法过了期就会一文不值。 任用那些曾有过相关创业经验的人可以加速成功的进程。 聘请资深人士加盟新创业的公司，有点儿像运动员为提高比赛成绩服用兴奋剂。如果使用得当，你有可能刷新纪录；如果使用不当，你就会一败涂地。 首先，要求他们顺应公司的企业文化。他们来自不同的公司，拥有不同的企业文化，而且有些企业文化的确比你公司的更胜一筹。但要记住，现在他们是在你的公司就职，那就必须接受你这里的文化，适应你这里的办事风格。 在这个问题上，不要因为对方资格老而轻易让步。坚持你的原则，推行你的企业文化。 其次，制定一个清晰明确的高标准工作要求。 你要先确保自己的员工出类拔萃——不管是新人，还是老将。不能只满足于对方比你更胜任这份工作，因为你聘用他们就是为了让他们做你不擅长的事。","link":"/2016/08/09/books-2016-08-09-book-the-hard-thing-about-hard-things-9/"},{"title":"拆书系列(十):《联盟》","text":"《联盟》这本书被很多人追捧，我个人看完以后觉得也不错，提出了一个雇主和员工的一种新型关系，全书一直围绕这一观点，个人觉得略显啰嗦，也许是受我程序员的性格影响的原因吧。和这本书相比， 显然《创业维艰》这本书对我影响更大，《创业维艰》这本书直击我的心灵，而且很多场景我都似曾相识。 感悟《联盟》强调的是重建雇主和员工的关系，让雇主和员工之间达成联盟，新的忠诚观允许公司和员工对彼此做出承诺，把过去的商业交易转变为互惠关系的框架。雇佣关系可以转换为一个联盟：一份由独立的双方达成的，有明确条款的互惠协议。 我个人对这个是认同的，原来我们也强调我们希望和员工签订的合同是一份”心里契约”，但是在中国目前这种环境，这种关系是否凑效，我觉得还需要观察，为什么这么说？我和员工建立过不少次”心里契约”，比如我们和客户一起给我们员工做了培训，我们付出了大量的精力给实习生做了培训，甚至我们每个年初都和大家谈了新一年的薪水等等，但是却多次被部分员工单方打破这个 “契约”，甚至有的人告诉我：”我知道这样很不应该，但是我违反法律了吗？”，为什么？我个人觉得是因为”信誉观”不同。 个人信誉，很多人不重视，这个从小或者教育中体现的并不多。 信誉代价，在中国，不守信誉的人付出的代价太少。欧美国家如果个人信誉差，在贷款，找工作很多方面都有影响，在中国，你这个银行办不了信用卡，却可以在另外一个银行办，你在一个公司表现很差，不是很容易被别的公司知道，原因很简单，因为你去一个新的公司，别人只是把你当个”物品”使用，依然可以能带来收入，不过好在很多好的公司，开始做一些背景调查了。 所以说，我觉得联盟是我们追求的一个方向，但是现在实际的还是需要有制定一些约束，比如如果培训如果付出了不小成本，必须签订对应的合同规定相关的义务。 不过比较好的是，越来越多的人，眼界越来越宽，格局在提升，不再只是追求暂时多点收入的不择手段，我相信联盟在中国会有适应的空间。 本书内容几乎没有公司会直截了当地提供有保证的职位；这种保证会被员工们认为是幼稚、虚伪的，或者兼而有之。相反，雇主会含糊其词地谈论录用和任期问题：他们的目标是留住“优秀”员工，而时限是——不确定的。这种模糊性实际上破坏了信任基础——公司要求员工向其做出承诺，但不会报以相同的承诺。 许多员工的对策是做两手准备，一有机会就跳槽，不管他们在面试过程或年度考核中如何表忠心。 双方的行为方式与其官方立场公然矛盾。 由于这种相互的欺骗，双方互不信任。自然，也没有哪方会从这种关系中充分获利。雇主不断失去有价值的人才，而员工无法充分投入目前的工作，因为他们正不断地在市场上寻找新机会。 与此同时，管理者被夹在中间。他们连承认这个问题都十分谨慎，更不用说解决它了。他们不是思考如何以有远见的方式促进员工发展，而是担心如何在完成重要项目之前保证团队的完整性。 没人想冒被抛弃的风险，因此没人投资于长期关系。 许多人力资源主管和高管在培训和开发项目上花了重金却眼睁睁地看着员工在几个月后离职，难免感到沮丧。如果你认为员工是自由人，自然的反应就是削减培训预算。为什么要为竞争对手培训新员工呢？ 雇主、管理者和员工需要一个新的关系框架，一个他们彼此承诺可以真正保持的关系框架。 通过联盟重建信任与忠诚双方的承诺雇主和员工建立的关系基于他们为对方增加价值的能力。 雇主需要告诉员工：“只要你让我们的公司更有价值，我们就会让你更有价值。”换句话说“我们将让你更抢手！” 员工致力于帮助公司取得成功，而公司致力于提高员工的市场价值。 我们是一个团队，不是一个家庭你会开除你的家庭成员吗？不会。但你会开除员工。所以不要再告诉员工我们是一个大家庭了。相反，企业更像是一支球队,有明确的目标，队员们为了这个目标和自己的发展聚在一起，有人不合适就离开了，有人留了下来, 球队经理可以决定裁减或者交易球员 硅谷真正的成功秘笈：员工拥有创始人思维拥有创始人思维的人会推动变革、激励人心、出色地完成任务。具备创始人思维并不一定意味着你要开办自己的公司，开创性思维在市场变化剧烈的今天尤为重要，过去的高绩效员工总是在重复着自己的工作，一旦市场变化，这些技能都将变成负债。 只需要几个开创性员工，就能带来巨大影响。 我们要鼓励员工在公司进行开创新工作，约翰拉赛特是一个被迪士尼开除的动画设计师，理由是他的疯狂想法让他无法专心工作。乔布斯雇佣了他，制作了玩具总动员。后来皮克斯被迪士尼用70多亿美金收购，约翰拉赛特成为迪士尼首席创意官。 任期制：培养开创性员工的利器将员工在你的公司职业生涯规划为一系列连续的任期，你可以更好地吸引和留住开创性员工。 在每一段任期中，管理者和员工都要制定一个任务目标，让双方都能长期受益。任期代表雇主和员工对某项具体任务的道德承诺，任期制让雇主和员工建立信任、相互投资，也保留了雇主和员工适应变化的灵活性。 诚实地谈论任期向他们说明，先有工作将如何为他们创造改变职业轨迹的机会，他们的责任是利用在这里的工作经验抓住这种机会，为自己创造长期价值，这种价值将在他们离职后的职业生涯中体现的最明显。 公司里的三类任期轮转期：针对高度可换的岗位，提供标准化培训，通常针对入门级员工。 转变期：个性化设计的一个时期，核心承诺是员工将有机会改变自己的职业生涯和公司，一般来讲一个任期2-5年。 基础期：雇主与员工保持高度一致性，员工认为这是他最后一份工作，雇主也希望这名员工一直干到退休。 协调员工的目标和公司的目标你的任务是根据员工的具体任务目标而不是他的全部生活进行协调， 你不需要无条件地支持员工的价值观和理想，但你必须尊重他们。目标协调的三个步骤是： 1.建立和传播公司的使命和价值观。 2.了解每位员工的核心理想和价值观。 3.合作协调员工、管理者与公司的使命和价值观。 最终，一致的兴趣、价值观和目标将增加公司与人才之间维持长期稳固联盟的概率。 如何执行转变期计划1.开始对话，确定目标。 ——任期的整体目标是什么？ ——成功的任期将给公司带来什么？ ——成功的任期将给员工带来什么？ 2.定期检查以交流反馈。至少每个季度要进行一次双向对话，既检查员工的贡献，也考量公司的帮助。 3.在任期临近结束前，开始制定下一个任期计划。管理者和员工制定公司内的新任期计划，或者，双方都认为员工应该去另一家公司任职。 如何处理任期中的意外如果员工愿意在公司内部换一个岗位？那就通过对话安排好交接，结束一段任期。 投资在员工的人脉上1.聘用有人脉的人。问问面试者“除了你，你认为我们还应该招入哪位重要人才？” 2.教会员工如何通过交谈和社交媒体从人脉中发掘情报。 3.执行有助于员工建立人脉的计划和政策。包括：鼓励员工使用社交媒体展示自己；为员工建立人脉基金；为员工社交参会提供方便；在公司办公室举行活动。 4.让员工与公司分享他们了解的信息。比如每周有半天时间交流各种信息。 打造终身联盟：前同事联络网投资于同事联络网的成本远远低于想象，而回报则远远高于想象。同事联络网能帮你雇到优秀人才；前员工能提供有用的情报；前员工能推荐客户；前员工是你的品牌大使。 1.决定同事联络网的成员。删除掉存在纠纷和法律道德风险的前员工。 2.明确定义与前员工关系的期望和收益。常见的方法有：员工推荐奖金、产品折扣和测试白名单、举办活动、为前员工颁发荣誉、向前员工通报最新消息等。 3.建立周详的离职机制。在离职面谈中与员工巩固终身关系，收集信息进入数据库。","link":"/2016/09/03/books-2016-09-03-book-the-hard-thing-about-hard-things-10/"},{"title":"斯德哥尔摩30天-第一个周末","text":"第一个周末，我们都非常着急的想看看这个北欧最大的城市。 我们决定沿着我们住得岛–国王岛走一圈。 建筑 车大街上看到的车基本上都是两厢车，而且都是大屁股的，这个和国内还是很不一样的。 信号灯Stockholm的每一个路口都有很多的路灯，而且路灯都相对比较矮，基本不用抬头就可以看到。问题是，为什么一个路口要那么多路灯呢？ 千岛之城这个只是城市的一角，可见全被河流环绕和分割成很多岛。 河边风景 艺术瑞典的艺术真是直白呀，到处都是这样的广告。 跑步跑步的人无处不在，街道上有人跑步，河边有人跑步，天黑在跑，天亮在跑，年轻人在跑，老年人还有拄着登山杖跑，更厉害的，很多推着婴儿车带着小孩一起跑。所以男男女女看着都比较健康，美女帅哥比较多呀。 自力更生的小孩好冷的天，小孩在卖东西。 免费得儿童活动区域很多公园里都有免费小孩活动的地方 免费的足球场 地铁地铁的人好少, 要是北京也这样，改多幸福！ 做客晚上去Richard家做客，带花是必须的礼节。","link":"/2014/11/15/life-2011-11-15-stockholm-first-weekend/"},{"title":"梦想的实现需要时间","text":"梦想从我记事后，在郝海东那段时间，中国足球在亚洲也算是风生水起，但是从那以后再也没有对中国足球有任何的梦想。教练换了又换，从外国教练换到国内，从国内换到国际，足球每况愈下。 这次亚洲杯，又一次燃起了中国球迷对中国足球的希望和梦想。 梦想是需要时间的这次国足亚洲杯小组赛赢了沙特，赢了乌兹别克斯坦，然后中国球迷和媒体说，既然赢了两场，那么就全胜出线，打朝鲜，上半场踢的不错，主持人就说中国队是顶级时候的巴萨。可是大家难道没看到朝鲜下半场变成了顶级时候的皇马？ 然后侥幸三场全胜出线了，球迷和媒体有开始说：“既然出线，那就夺冠”， 这让我想起02年世界杯的时候 “赢哥斯达黎加，平土耳其，小输巴西”，最后结果是三场比赛全输，丢了9个球，让我们认识到自己还是“三教九流” 从这件事情上， 我们可以看到大部分的球迷呀，媒体呀都想一口吃个胖子，我猜中国足球的现状和中国球迷以及媒体也有很大的关系，教练想干点实事，但是大家都要赢，有进步，大家其实很难看到，所以我猜每一个教练都只能是赌博式的，不然输了就得下课。如此下去，就像我们把程序功能做的看起来不错，但是代码里面千疮百孔，经不起时间的考验。 我觉得，我们都要有梦想，但是梦想都需要一个因素，那就是时间，那就是脚踏实地。那就是科学，每次国足输了，大家都说没拼，拼了就能理解，但是我想说，现代体育光靠拼是不行的，越是体育类比赛越是要靠脑子才能上一个台阶。 给国足时间，明天的比赛输赢有何重要？五星巴西没输过吗？ 有梦想，有信心，但是务实更重要，持续进步才是最重要的。 明天彩票买澳大利亚赢吧，看球的时候就不那么紧张了，如果中国赢了，权当买酒庆祝了，如果中国输了，至少彩票还能赚点，你呢？","link":"/2015/01/21/life-2014-1-21-football-dream/"},{"title":"新起航","text":"自从开始做分公司后，就没怎么写博客，总觉得自己太忙，或者写得东西要么网上有了，要么觉得别人没必要看，然后就再也没有然后了。 但是人类都善于给自己找借口，时间就像腹肌一样，其实每个人都有，只不过我们看不见而已。 所以，从今天起，没有借口，坚持写博客，分享技术，分享所思，所悟，所活！不求别人看过，问过，关心过，只求自己闻过，思过，行过，记录过。 我们总是在走前人走过的路，也一直在开辟新的路。 我，开始起航，走自己的路！","link":"/2014/10/20/life-2014-10-20-new-blog/"},{"title":"青楼聚会","text":"讨论团队活动项目我们的一个6人团队从分公司成立开始就在做一个项目，到今年已经做了3年多了。 之前我希望团队能够定期活动，不知是不是大家想给我省钱，也一直没活动，花钱这种事还要我亲自来? 在一段激烈的讨论，爬山，吃饭，唱歌等项目后，大家一直同意喻同学的，吃铜锅，去“青楼”. 看来程序员的爱好就是不一样。 青曲社青曲社 位于陕西省西安市的一个相声社团，成立于2007年。社团名称蕴含“青云直上，曲故情长”的意思。相声演员苗阜、王声的《满腹经纶》让青曲社火了起来。 社团以西北五省资历最深的老艺人三名（郑小山、张常泰、张常锁）为首，以收纳的年轻力量为主体，在老曲艺精髓的基础上开拓创新，已在国内占有一席之地。 网友戏称情趣社。 活动吃下午5点大家集合，然后去了牛逼的 ”火药库“ 街吃了铜锅，尽然是用碳的，感觉很不错，不过由于大家平时生活都太好，战斗力不强，6个人才喝了8瓶酒。还第一次吃了 ”牛喉舍“，晕，原来中国人真是啥都能吃。 笑我定了青曲社最好的位子，8点正式开始，2个小时的相声真是过瘾呀，说过瘾的意思就是你能听到春节联欢晚会上绝对听不到的段子，陕派相声有特点，比如说你是我的搭档，就说：”你是我的大裆!“ 2个小时笑得真爽，强烈推荐大家去看，唯一的遗憾就是场地有点挤，而且后面的几个女生，笑点太低，每一秒都在笑，一看都是平时没在网上看过段子的。","link":"/2014/10/20/life-2014-10-20-qinqushe/"},{"title":"你的时间比你想象的多","text":"#前言由于要去办签证，就必须到北京进行面签，所以21号晚上座卧铺，22号办面签，22号晚上座卧铺回来。 回来后我总结了一下这一天干得事情，发现我们时间远比我们想象的多，我原本只干面签这件事情的。 #过程 火车上我在火车上看了2个电影，还和同事聊了聊领域驱动设计。 第二天白天下车后，带大家吃了个主席套餐。 然后去办了面签，后来发现还有时间，我就待兄弟们去了趟雍和宫，雍和宫门票只有25元，真心不错，不愧是北京最大的藏传佛教之地。（稍后上图) 还有我们顺路参观了一下，我们之前经常带客户去得一个餐厅，里面是有美女跳舞的。 中午带同事去了趟西单，吃了个麻辣诱惑，喝了喝久违的燕京纯生，感觉比当年在北京的时候好喝多了。 下午去总公司见了COO, 见了几个其他的同事，此次之行，觉得和COO的聊天非常有收获，给我遇到的几个困扰找到了一些解决的办法。看来以后还得多沟通交流，面对面的效果就是不一样呀。 原本的一起和同事女朋友晚餐，但是由于在公司聊的太久，同事一个人找女朋友射箭去了，我和另一位同事一起吃了个晚饭。给家人买了些北京小吃。 遗憾唯一的遗憾就是返回西安这个故乡时，我们的一位同事iPhone6在西安火车站被偷了，可恶的小偷呀！！！ 总结所以，我们看一下，我们干了多少事，我的感慨就是时间总是比我们想的多！ 美图","link":"/2014/10/24/life-2014-10-24-beijing-visa/"},{"title":"爱上跑步，突破100公里","text":"爱上跑步很早都有跑步的计划，2013年时就想开始坚持跑步，记得当时去青岛开会时为了沿海边跑一跑，还专门买了双跑鞋，然后和两个同事一起跑了几次，那两个同事早早就放弃了，后来由于雾霾，大家说跑步不好，再加上客户来访，就彻底的放弃了。 重新开始过完年后，发现自己有点小肚子了，这是我极其反感的事，我一直不喜欢男人有个大肚子，这说明这个男人要么懒，要么就是花天酒地，要么就是个纯粹的吃货，所以从4月份就计划开始跑步了。 4月1号，3公里， 6分27秒/公里 但是跑完了后，发现脚痛，然后就觉得自己是不是适合跑步，犹犹豫豫当中，4月份过去了。 过了一个多月后，还想再试试 5月20号，3公里，6分01秒/公里 跑完后，发现还是脚痛，于是又放弃了。 有过了将近一个月，不甘心，还是想试试 6月13号， 2公里，5分48秒/公里 跑完后感觉还可以 6月16号， 3公里， 6分/公里 然后感觉虽然脚痛，但是第三天感觉还凑合 6月18号，5公里，6分11秒/公里 然后，这次就彻底的伤了。 然后，就一直休息到8月25号。 再次重新开始，思考科学的跑步这一个多月，让我开始怀疑我适不适合跑步，直到这个时候，我才开始认真的思考跑步这个事情，之前每次想跑就跑，而屡屡受伤，我觉得心里有一个东西在作祟，那就是跑步这么简单的事情，谁还不会？期间看到个一个书名 《天生会跑步》，我根本没看内容，就对书名感到深深认同，这也让我后来对自己这种肤浅的认识付出了深深的代价。于是我开始渐进的方法来跑步，就是每次增量一点。 8月25号， 3公里，7分每公里 8月27号， 3公里， 6分30秒每公里 8月29号，准备继续跑3公里，但是跑到两公里，因为吃过早饭跑得，觉得不舒服，所以2公里就停下了，所以 2公里， 6分10秒/公里，这一天我开始意识到我跑步不是为了比赛，是为了坚持，是为了形成一个习惯，按计划只要我来了，多远多快已经不重要，只要还在跑就可以了。 这一天，是心理突破的一次。 然后计划每天跑一次 9月2号，3公里 9月3号，3.5公里 9月4号，4公里 然后有受伤了。 于是就又思考了下，发现每天一次不适合。这次主要是停大家鼓吹某某人每天早晨都跑步，现在想想别人的不一定适合自己。 休息以后 9月18号， 4.25公里 9月20号， 5公里 9月25号， 6公里 9月30号， 7公里 此时，感觉有点累，但是由于是渐进的，而且每次活动前，我进行了身体拉伸，还好，并没有感觉到明显痛疼。 看来9月份的锻炼，让我体质有了明显的提高。 忘了说了，现在肚子早就平了. 有了之前的锻炼，国庆才让我有体制开车开了几千公里，而且登上了中国第一谷红河谷的凌云栈道。有人觉得没什么，可以我说我身上有50斤的负重，你下次就可以去挑战下了。 10月份，这次冲动了一下，觉得既然我能跑7公里了，那就挑战一下10公里吧。 10月11号 10公里 6分23秒每公里 正是这一次，差点让我腿废了，跑完后，第二天，我在家直接直接拄拐杖了。 人总是等到生病了，才发现身体是如此宝贵，自此我开始深深的思考跑步了，我查阅了大量资料，此时才意识到，跑步真得不是那么简单。所有对一件需要长期坚持的运动或者学习报轻视的态度，都会被现实狠狠的打击的。 至此，我才觉得我开始科学的跑步。 10月14号，3公里。 感觉膝盖有点痛，但是这时候我知道，初学者跑步痛是必然经历的，只要在合理范围之内。然后，就继续坚持，合理的控制距离和步速，慢慢的就不痛了。 经过多次感觉，觉得目前自己的合理承受跑步的距离是6公里， 6分15秒的配速。我会在这个基础上逐步增加。 100公里昨天看到自己今年的累计距离是快到100公里，于是准备今天挑战一下，就到了大学操场，因为一直在公园跑，第一次在橡胶地跑，发现脚上非常舒服，很轻松的跑完了5公里，发现速度竟然到了5分30秒每公里。 不过操场跑圈是非常无聊的和枯燥的，坚持初学者2公里以内在操场跑，超过2公里还是去公园，这样才能容易坚持下去。 跑步的路还很长，但是我觉得100公里是一个坎，能到100公里，很多东西你就经历过了，然后到1000公里就是一个时间的问题了。 不止是跑步本篇文章说的都是跑步，但是跑步过程中会让我们学到很多东西，所以跑步不止是跑步，因为路就在那里，前方是可以跑到的，所以跑步。 跑步会让我有很多想法，思考出很多问题，希望以后有机会大家一起交流。 跑步记录","link":"/2014/11/10/life-2014-11-01-love-running-100km/"},{"title":"南湖","text":"曾几何时，蓝天已成为大家越来越奢求的东西。那些在我们小时候天天都很自然的事情，儿时只会说今天是个大晴天，雾霾还是最近几年才听说过。 于是乎，我们很多人就被天气挡住了脚步，不跑步，因为雾霾了。不出门，因为雾霾了。 但是，据我在西安待的几年，雾霾目前还远没有我们相像的严重，尤其是我大秦岭山青水秀。所以我们周末还是别宅在家里，没有雾霾的时候可以在市内玩玩，有雾霾的时候可以去看看我八百里秦川风光无限。 南湖西安说要“八水绕长安”，我还是非常期待的，我看过汉城湖，浐河，灞河以及护城河也越来越清了，说实话，相对北京，我个人还是更喜欢西安一些。 上周末，去了一趟南湖，立即被南湖的美景吸引了，我觉得就算坐在湖边发发呆，也是很不错的。 更巧的是，我们竟然遇到了我们班仅有的成的两队，“缘”来是你! 废话少说，上图！","link":"/2014/11/11/life-2014-11-11-xian-beauty/"},{"title":"斯德哥尔摩30天--第一天","text":"下了飞机已经是当地下午16:30, 由于我们是商务签证，出镜是就简单的问了几句就出来了，比我当年去London的时候简单多了，然后就取了行李。 客户派了公司的一个帅哥一个美女来开车接我们，让我们感觉很是温馨。 然后一路高速送我们到我们住的Hotel, 下午16:30天已经全黑了(我勒个去), 所以基本上看不到多少东西，Stockholm的高速穿过整个城区，所以很快就到了住处。 沿路我们就开始对瑞典人开车的文明产生了称赞，真的是一条路开到黑，边上再远没车都没见变道呀。 Check In 后，我的好朋友Fredrik开完会很快就来了，然后就带我们去吃饭，由于正是吃饭的时间，去了好几个餐馆人都比较多，后来去了个稍远的地方招到了一个有位子的。沿途给我们介绍些一些标志建筑，不过只能看到个轮廓。 餐馆坐下，一看菜单都是200多了，感觉太贵了。由于没有英语，只有瑞典语，就让Fredrik推荐了个250块的。上来后感觉量比较少，味道一般，可能一路没怎么吃东西，比较饿，感觉没吃饱。 总之，当晚的感觉就是东西太贵，而且味道一般，就开始想念中国菜了。（所以，中国人还是很幸福的，至少在吃上）。 然后，由于太累了，就回来早早睡了。","link":"/2014/11/13/life-2014-11-13-first-night-of-stokholm/"},{"title":"斯德哥尔摩30天-我来了","text":"早就想来斯德哥尔摩转转，这次终于得偿所愿。 由于西安没有直接到斯德哥尔摩的飞机，所以需要到北京转机 （后来才知道如果到芬兰转机，整个行程会少两个小时)。 6：30就到了机场T2航站楼，然后就办登记手续，开始还排错队了，需要到国际联程专门柜台，由于我们给别人带了礼物，所以就多出了一个箱子，但是我的拉杆箱较小，为了省钱就只能随声携带了。 然后安检，由于我穿了马丁靴，每次都要脱鞋，搞的很不方便，而且把我随声携带的一些日用品，比如牙膏等超过100ml的全都截下来了。 很快，2个多小时就到北京了，由于联程，中间不用出机场，就吃了份牛肉面，一个字，贵！另外看到了传说中的APEC 蓝 下午一点多，就座上了CA911去往斯德哥尔摩的飞机，这个飞机很大，但是里面的座位貌似小一些，没有西安到北京的飞机舒服。由于需要9个小时，飞机上还是比较难受的，还好可以看看电影，我就看了个&lt;建党伟业&gt; 重温一下建党史，陈独秀，李大钊，胡适，孙中山等，以及五四运动这些历史让我对当年这代人的崇敬。 终于熬过了9个小时的飞机，飞机平安的降落在阿兰达机场。 当地时间下午4：30一下飞机，就赶紧给家里打了个电话报了下平安。 APEC 蓝 等机中…","link":"/2014/11/13/life-2014-11-13-go-to-sweden/"},{"title":"斯德哥尔摩30天-第一天上班","text":"来斯德哥尔摩第一天主要是见了我们客户A，上午A客户那里和他们见了个面，听听早会，寒暄了一会就到中午了。 中午A客户的老板带我们去一个看着不错的餐馆吃了午餐，反正啥也不认识，就招一个最贵的点，不好吃也不难吃。（就不明白很多人为什么觉得西餐很好吃）。 下午去我们去B客户那里，和很多熟悉的人见了个面，聊了聊。 虽然A客户是500强，但是明显B客户看着更气派，文化上我更喜欢。 晚上客户安排了一些人带我们座地铁去一个比较远点得地方（他们自己觉得很好的餐馆）吃了晚餐，他们安排了人给我们买了交通月卡（这个不错，一个月公交和地铁随便坐），不过去的都是客户里的一群屌丝，最后还是我买的单。 明天是星期六，斯德哥尔摩，走起！","link":"/2014/11/14/life-2014-11-14-stockholm/"},{"title":"斯德哥尔摩30天-吃饭喝酒","text":"今天客户的大Boss请我们去吃饭。 喝酒首先去了一个酒店，说是麦当娜当年来得时候住的，喝了一些香槟和酒，客户说很好喝，我时唱不出来啥区别，感觉没我大中国的太白和茅台好喝。原以为要吃饭，结果这只是喝酒的。 吃饭 （更多的酒）喝完酒来到著名的老城区Gamla Stan, 原来吃饭就是点一个菜，剩下全是各种各样的酒呀，在国内是没有混着喝的，一下子喝了太多种类的酒了，感觉有点晕呀，看下酒瓶子都是一个人的呀！","link":"/2014/11/20/life-2014-11-20-drink-dinner/"},{"title":"斯德哥尔摩30天-客户现场","text":"Stockholm的楼层都相对较低，客户所在的大楼稍微高一些，所以能看到城市的楼顶。楼等果然和国内的不同呀，典型的欧式建筑。 清一色的苹果电脑，可升降的桌椅站立和坐着办公自由切换，这个很不错。 工作了一天，讨论需求和设计，面对面的沟通，辅助白板效率是相当的高。 周五的下午可以喝着啤酒办公，这个不错，感觉我们是否也可以引进？（我的Surface其实也蛮霸气！）","link":"/2014/11/21/life-2014-11-21-work-friday/"},{"title":"斯德哥尔摩30天-瓦萨博物馆","text":"今天是周六。 朋友带我们一起去VASA博物馆，由于朋友的老婆一个人带俩小孩不方便，所以我们就一起带了一个出来。 瓦萨博物馆VASA乘船的故事早就知道了，这个对一个管理者或者一个产品经理来说都很有教育意义 瓦萨王朝统治时期，瑞典是欧洲的强国之一。为了与劲敌丹麦、波兰对抗，称霸波罗的海，瑞典国王古斯塔夫·阿道夫斯二世要求建造一批新的战舰，并要求战舰航速要快、火力要强、装饰要华丽，因为这样才足以显示瓦萨王朝的权力、财富和战斗力。1626年初，作为其中最大的战舰“瓦萨”号在国王的亲自监督下正式开始建造。 瓦萨号内部国王总是有太多要求。在“瓦萨”号建造期间，他不断下令依照他的旨意改变设计和建造要求。在“瓦萨”号的骨架已经安装好的时候，他下令增加战舰的长度。面对以性情暴躁闻名的国王，经验丰富的主造船师亨里克·哈伯特备感无奈，只得奉命行事。1627年，亨里克·哈伯特病逝。他的助手、没有太多经验的海因·雅各布森接替他主持建造。而此时，国王得知了丹麦建成双层炮舰的消息，于是他又决定，为原计划修建单层炮舰的“瓦萨”号增加一个枪械甲板，把它改建成“双层”炮舰。这样一来，“瓦萨”号便拥有了双排共64门舰炮，全长达到了69米，成了当时装备最齐全、武装程度最高的战船。但对于横梁和压舱物来说，在一个并不稳固的平台上安装的这些装备显得过高过长了，而且与平台的功能极不相称。但国王的命令没人敢违抗。对“瓦萨”号进行的稳定性测试试验更像一场闹剧：让30个船员从船一端跑到另一端，以此检测船的摇动情况。试验中“瓦萨”号发生了危险的摇动，但对这个预警信号，海因·雅各布森却视而不见，还是决定取消试验，准备航行，结果—首航沉成绝唱。 瓦萨沉船不亲身见vasa号是绝对感受不到这个船的霸气，高大，金色的船体，木雕堪称一绝。 圣诞来临了回来时已经晚上，整个街道已经该是感觉到圣诞的气氛了。","link":"/2014/11/22/life-2014-11-22-vasa/"},{"title":"斯德哥尔摩30天-船岛","text":"今天是周日，由于星期中间都是相当的忙，今天决定自己转转，准备出发去船岛。 天气非常晴朗。 走了一段，就被一个户外的溜冰场给吸引了，那是真的冰，太酷了。 然后竟然走到了那天晚上喝酒的酒店 很快就到了船岛，美景无法言表，天很清，水很清，空气很fresh. 最后，偶遇瑞典皇家歌剧院","link":"/2014/11/23/life-2014-11-23-ship-island/"},{"title":"斯德哥尔摩30天-一日游","text":"昨天周六赶工了一天，今天周日决定好好休息一下，把瑞典的几个主要的旅游经典参观一下。 市政厅 建于1911年，历时12年才完成，是瑞典建筑中最重要的作品。建筑两边临水，一座巍然矗立着的塔楼，与沿水面展开的裙房形成强烈的对比，加之装饰性很强的纵向长条窗，整个建筑犹如一艘航行中的大船，宏伟壮丽。斯德哥尔摩市政厅位于瑞典首都市中心的梅拉伦湖畔，是斯德哥尔摩的形象和代表，也是该市市政委员会的办公场所。斯德哥尔摩市政厅是一座宏伟壮观，设计新颖的红砖砌筑的建筑物，800万块红砖砌成的外墙，在高低错落、虚实相谐中保持着北欧传统古典建筑的诗情画意。市政厅的右侧是一座高106米，带有3个镀金皇冠的尖塔，代表瑞典、丹麦、挪威三国人民的合作无间。据说登上塔顶部，可一览整个城市的风貌。市政厅内有巨大的宴会厅。宴会厅也有“蓝厅”的誉称。每年的12月10日是诺贝尔逝世日。这一天，诺贝尔奖金颁发后，瑞典国王和王后都要在宴会厅，为诺贝尔奖金获得者举行隆重盛大的宴会，表示热烈的祝贺。 瑞典皇宫 瑞典皇宫是国王办公和举行庆典的地方，斯德哥尔摩主要旅游景点。坐落在斯德哥尔摩市中心。建于17世纪，是瑞典著名建巩学家特里亚尔的作品。皇宫方正宽敞，中间有一个很大的场院，楼房围着场院而建，共有608个房间，比英国的白金汉宫还多4间。如今瑞典王室并不住在这里，而是住在在郊区的皇后岛，国王每天开车到皇宫来上班。 诺贝尔博物馆这里能看到莫言的图像和介绍，还是很骄傲的！ 斯堪森斯堪森的介绍很好，但是去了确实没意思，比起我大秦岭野生动物园差太多了。 下面是修女吗？ 一首 《we wish you a merry christmas》甚是好听。","link":"/2014/11/30/life-2014-11-30-scene-spots/"},{"title":"斯德哥尔摩30天-参加客户的年会","text":"很有幸参加了客户的年会，听说大家都带家属，帅哥美女云集，所以我们都迫不及待。 年会的逼格还是非常高，先是大Boss讲话，然后请了个长的像瑞典王子的人讲话，一开始大家都被骗了，后来才知道是演员。 每一个人都端着红酒杯，风度翩翩的和别人聊天，我们当然作为嘉宾也受到了分外的照顾。 我们也和很多人聊了会儿天，对大家有更多的了解。 随后就是表演，晚餐。 晚餐过后，就是跳舞，虽然有位美女极力邀请我跳舞，可惜我不会，只好找个借口溜之大吉了。 还是上图片吧。 晚会的地方 酒 正装 我们的帅哥，也是我们的朋友 三个屌丝，中间是我 高朋满座 假瑞典王子，骗过不少人呀 他们最佳员工，和我们密切合作的，主要是与外包团队协作，我们是不是也骄傲一下？ 美女们，其中一个来机场接我们，谢谢了。 真心不错的合唱，天籁之音的感觉 姑娘，你的衣服真的穿好了吗？ 和我一起做项目的帅哥，看看人家，以后你们再叫我帅哥，我就知道你们是违心的。","link":"/2014/12/05/life-2014-12-5-attend-winter-party/"},{"title":"国足亚洲杯小组赛","text":"好久没看国家队比赛，上大学时，那几年球市比较火，当时陕西队还在甲B, 那个时候陕西国力踢的很不错，我也几次买了最便宜的票去现场加油，陕西球迷的热情几次搞得比赛不得不移到宝鸡。 但是中国进入2002年世界杯后，那些熟悉的老将郝海东，范志毅，李明，李铁，李金羽等等都相继老去，而且国家队每每关键时刻给你顶不住最后3分钟，慢慢的我就不怎么看中国队了。 虽然不看中国比赛，但是新闻还是看的，之前知道中国队预选赛输了尽然都能进亚洲杯。 这次亚洲杯我正好休假，看了一场中国对沙特的比赛，感觉中国队和之前不太一样了，感觉有拼劲。确实看到了一些亮点，至于是不是佩兰执教带来的一些变化，这个还有待检验。第一场整体感觉上还是运气，因为沙特点球没进，而且我们进的球也很诡异，所以第一场比赛下来，感觉踢的还可以，但是还是觉得中国队有些侥幸。 今天打乌兹别克斯坦，这个球队实力确实不错，从历史交锋上，中国队就处于下风，观看了前30分钟，感觉中国队踢的不错，从传球到控球都有章法，但是上半场最后15分钟，感觉中国队的球员明显想法不一致，有些想进攻，有些不敢进攻，控球明显不如乌兹别克斯坦，而且失误增多，最后别对手攻入一球。 但是，我也并没失去希望，因为中国队前半个小时都占优势，回到休息室，我相信教练一定会做出调整，只要球队思路一致，找回之前的感觉，就一定有机会，果然下半场一开始，中国队就打的不错，后来佩兰果断的换人，起了非常重要的作用，大家可能觉得换人是神来之笔，但是我觉得换人后明显中场的球员敢于控球，而且前腰的队员明显敢于突破，这样就让球大部分时间都在对方战场，最终果然2比1逆转。 这次中国队赢球，着实也让我激动一把，因为看到中国队逆转的足球比赛太少了，听到主持人说：“留给乌兹别克斯坦斯坦的时间不多了”，我相信大部分中国球迷都是无比的激动，感觉压抑多年的一口气终于可以释放一次了。 中国足球要想提高，除了提升球员个人能力之外，球队的团结，技战术的提高，以及球队的信息和意志是更重要的。 期待中国足球越来越好。 写下此片日记的目的，就是中国足球的胜利了，都逆袭了，我还有什么不努力呢？ 加油！ 更令人高兴的时，今天心血来潮，堵了一把求，买中国赢，小赚了一把。","link":"/2015/01/14/life-2015-1-14-china-football/"},{"title":"跑步，不止于跑","text":"加注：本来是想记录跑步，给那些爱跑步的人看，但是当我写完，我发现我们平时做事其实也是如此，做项目也是如此，这就是所谓的 道理的 “道” 其实都是相同的吧，希望此文能够对您有共鸣吧。 万事开头难，开头了坚持更难！ 今天看自己的跑步记录已经到400公里了，总跑步次数已经82次。相比于总里程，我更看中跑步的次数，因为跑步次数才代表了坚持的程度。 我觉得是时候写篇跑步的记录了，一个是记录一下跑步，另一个也是给自己点个赞。 不跑步，借口总是很好找从去年11月份开始，中间有很长一段时间没跑。 11月13去了瑞典，12月12号回来，中间一个月只是跑了3次，而且距离都很短，当时给自己找的原因主要是以下几点。 斯德哥尔摩白天太短，早上9点多天亮，下午4点多天黑 斯德哥尔摩不熟悉，天黑跑步不安全 工作太累了，回国补上。 回来以后，几个月基本跑得次数也很少，主要借口如下 陪客户 （注：有一个客户在这边工作半年，确实花了几乎自己所有的周末） 空气质量太差，雾霾！ 项目太忙，太累了！ 下雨，没法跑 今天就算了，明天再跑。 上面的借口，是不是我们很多人很熟悉呢？可见找借口太容易了，几乎不用思考，每个人都能找出一堆理由，我相信很多人比我能找更多更”合理”的借口。 我是如何坚持下去的？从4月份开始，我就思考如何让跑步坚持下去， 下面是我这将近半年的总结 到跑步的地方去很多人没跑步，最主要的原因就是没有动身，所以我想到的一个方法，就是不管我跑不跑，先要求自己穿好衣服，穿好跑鞋，到跑步的地方去。 由于我这边有一个公园，我要跑步时候就先到这个公园里来。 实际上，我每次如果能坚持到跑步的地方去，基本上都跑了，因为你就会想，“衣服都换了，人都来了，不跑太亏了”， 这个就像我们有的时候学东西给别人交了钱，不管别人有没有用心教，自己都能学到东西，哪怕是自学， 因为我们会想：“花了这么多钱，不学点东西太亏了”。 所以，第一招就是： 动起来，到跑步的地方去。 不要设置跑步的目标可能很多人觉得这一点很奇怪，但这个真的是我实践的，因为很多跑步的软件，让你设置的目标是5公里，那么明天可能就是要你5.5公里，后天就是要你6公里等等。甚至在你快达到目标的时候，语音鼓励你等等，但是任何的软件，他都是针对的所有人来设计的，而且设计软件的人真的懂跑步吗？ 我一开始也是跟着Nike+设置的目标，经常搞得很累，以至于很多时候想放弃。 为什么呢？ 因为你今天跑步和你今天的状态，你今天的身体，甚至你今天穿得鞋子有关系，而这些都会影响你跑步的目标。 所以，没有任何一个软件，比你自己更了解你自己。我经常举个例子，就是“红灯停，绿灯行”，但是如果你开车的时候现在是绿灯，但是前面有人在过马路挡着呢，你还不停吗？ 因此，现在我就只使用用一个模式，那就是“自由跑步”模式。就是自己想跑多远就跑多远， 自从使用了这个模式，跑步就没有任何压力了，从结果来看跑步的次数明显增加了。 我到底该跑多快？刚开始跑步时，总想跑的更快，尤其是看到有女生比自己跑的还快的时候，不有自主就加快了脚步。 这样的结果就是，要么受伤，要么坚持不了多久。 经过一段时间摸索，我找到了一个适合自己的配速的方法，而且我认为这个是应该适合所有人的一个黄金法则。 重要的事情说三遍！ 跑步的时候不要张嘴呼吸!跑步的时候不要张嘴呼吸!跑步的时候不要张嘴呼吸! 大道至简“大道” 一般都是很简单的，但是得到上面三条经验，却需要将近一年的时间。 自从坚持上面三点以后，跑步对我来说是轻松，是快乐的。 没有目标让我没有时间上压力，如果时间快到上班了，那我就不跑了，不管我今天开始跑步的多晚。 降低速度，跑步的时候，不张嘴呼吸，让我很轻松，让呼吸自然发生，那么我可以边跑边欣赏耳朵里的音乐，边看看周围的树，闻一闻路边的桂花香等等。 若能如此，焉能不喜欢跑步呢？ 附录下面是月度统计图，平均5公里，最近一段时间7月份和9月份跑得最多。跑过的地方有 西安、青岛、瑞典的斯德哥尔摩。希望下一次跑步的地点里有美国。 配速基本上还是保留在6分30秒左右，希望下一次统计时平均配速能到6分以内。 目前跑得最远的还是10公里，其中大部分的时间都是周内，以及早晨。","link":"/2014/09/24/life-2015-9-24-running-400km/"},{"title":"加班有罪","text":"前言加班在很多行业司空见惯，于是 “过劳死” 开始为更多的人关注，IT行业尤为严重，但是普通职员再关注也起不了多大的作用，老板让你加班，或者是潜规则让你加班。我们从几年前就开始不提倡加班，我们也基本没加班，但是最近做了一个项目，出现程序员加班，甚至我自己本人都投入了很多下班后的时间，让我又一次思考加班的问题。作为一个分公司经理，我鼓起勇气写下此文。 脑力劳动不应该加班加班无非就是增加工作时间来增加工作产出，比如机器制造，我们让机器多转几小时，肯定多生产一些产品，比如我们让人搬砖，多搬几个小时，虽然最后比较累，无非就是搬的慢了，但是还是能多搬一些。但是这些可以说基本都是机械性的工作。 但是，软件行业其实是创造性的，同时很多时候依赖高度的抽象，加班会持续破坏创造力，我们想想，我们让孩子连续学8个小时的数学课试试，显然我们知道那不合理。而且我们知道脑力劳动比体力劳动很多时候更累，更需要休息，这个本来是显而易见的，我们每个人都切身体会，但是我们很多老板，很多客户都想不明白。 加班的恶性循环这个场景是否遇到过？ 晚上加班到11点，然后感觉很饿，然后外面饭店都关门了，只剩下肯德基了，于是打了个车去肯德鸡，由于好饿，买了个全家桶, 然后回家太累了立即上床睡觉，然后你发现吃的太撑了，睡不着，最后迷迷糊糊的睡着了，此时已经是半夜三点了，然后你做了个梦，梦见周末你在玩，老板打电话让你赶紧回去加班，这个时候闹铃想了，第二天该上班了，由于昨晚吃的太撑，早饭实在不想吃了，你飞一样赶上公交车或地铁，座位别人坐完了，车上全是人，一个女的挤了你一下，你抬了一下头用你那睁不开的眼睛看了一下他，那个女的觉得你很猥琐，恶狠狠瞪了你一眼，你心里正想着，老子眼睛都睁不开了，都累成马，还有心情看你？ 你正郁闷，听到一声：”软件园站到了”，你就又开始了下一天的循环。 我们看到，如果上面的场景持续发生，先从你的身体开始，你的肚子开始圆了，作为男人的你胸部开始变大，头发开始变少，颈椎病也来了，同时，因为你天天加班，你反而不习惯周围的人不加班了，你开始觉得你的家人都很懒，你的客户都很懒，你的朋友都很懒，你的同事都不错，因为和你一样。最后你挂了，留下了大千世界给其他人。 加班导致创造力低下我们看到很多人工作勤勤恳恳，看似非常努力，但是却很难做有创造性的工作，我们看到很多学生学习很幸苦，但是最近几百年中国都没有颠覆新的发明和创新，我们一直引以为傲的 “四大发明”，离我们都比较远了。当然国外也好不到哪里去，最近30年几乎没有什么大的创新。 飞机让我们飞上了蓝天，蒸汽机使我们有了火车，电话让我们更快的交流，互联网让我们有了更多的信息互通，等等这些都快一百年了。 我们人什么时间可以自己飞上天？ 我们生命如何延长100年？ 我们可以不睡觉吗？ 我们如何只吃少量的食物能够存活？我们必须用大规模使用石油和天然气？ 我觉得至今没有解决的原因，就是我们没有那么多的时间来思考和创造。 回到软件行业，加班使我们不段的做机械工作，不断的复制拷贝，我们大脑被这些东西塞的慢慢的，我们哪有时间去思考更好的解决问题的方法？我们哪有时间去学习何成长？ 为什么说加班解决不了问题？加班的主要目的是增加产出，但是我们大家最终选择了这种简单粗暴的方式，就是加班来增加产出，但是想一想，我们每天工作8个小时，就算一天不吃不喝不上厕所，我们也就是24个小时，产出最大也就三倍。 我们都知道，一个优秀的工程师是一个普通工程师效率的10倍，甚至百倍。那么我们就需要考虑的是，我们其实是要提高工作效率，也就是8个小时之内提高效率，比如，我们使用自动化，我们使用快捷键，我们使用持续集成等等这样的方式都可以提高效率，而加班却给大家造成了恶意引导，让大家觉得我总是可以通过加班来完成工作，而忽略了我们本质是要提高效率。如果我们一开始的出发点就是我们不要加班，我们提高效率，工程师自然就会更多的考虑8小时之内的效率，比如使用番茄工作法，比如不要写会儿代码，看会儿微信，就会想到单元测试保证质量避免返工等等，而真正提高了效率，我们个人才算是成长了。 不加班不代表下班后不学习当我强调不加班的时候，很多人开心的露出了笑容，但是如果这样，那可能就完了，不加班不代表你不提高自己，不加班需要我们提高效率，如何提高效率，那就要不断找新的方法，不断的去学习，不断的提升解决问题的方法，不但的反思回顾。 下班后需要看书，IT人员，比如英语是不是需要学习？ 技术需不需要学习？工程实践是不是需要学习？ 架构，算法，设计模式，Clean Code等等都需要学习。同时，也需要看一些非技术之外的书，我们可以看到很多技术图书作者使用大量的比喻来描述问题，如果你不观察生活，你不读书，如何用这些简单的生活场景描述复杂的技术呢？ 不加班不代表你的表的闹钟定到下午6点，我们提倡不加班，但是不代表你一分钟都不多干，你和单位划清界限，你是不是把今天的工作任务完成了，或者你至少把手上的单元测试通过了，你至少要把你今天的代码Commit了吧。所以，一般你一个月加班总时间不超过8个小时，我觉得应该是OK的。 今天不加班，各位老板你敢吗？不加班需要勇气，需要能力，我们大家都顶着各样的压力在加班，但是我想说，我们这个世界不是东西太少而是太多了，美其名曰我们选择多，实际上我们得到的东西质量都下降了，企业之间相互抄袭，导致价格不但下降，利润不断降低，整体服务质量不断下降。各种创新越来越少。 一个没有创造力的行业是不长久的，总之，我觉得越来越多的公司会开始主要到提高员工工作效率，而避免加班，尤其是软件行业，谁敢抛弃短期利益（可能会丢掉一些项目），但是长远来看会大大增加企业的竞争力，因为员工成长，全员创造一定会极大提升企业的价值，最终一定是名利双收。 如果你觉得我文章写的很有道理，请推荐给你的老板。","link":"/2015/04/16/management-2015-04-16-why-we-should-not-work-overtime/"},{"title":"欧美软件外包系列 (一)： 正确看待外包","text":"前言做欧美外包8年了，积累了很多对欧美外包的一些经验和认识。由于看到很多人对外包产生了很多误解，有很多发包方也在大家的误解中错误的看待外包团队，所以想让大家对外包有一个正确的认识。 由于我一直做的都是欧美外包，所以主要是在谈欧美外包。 欧美外包简介欧美外包其实就是欧洲和美国的软件外包，主要是欧美发达国家和离岸顾团队的一种软件协作。 对外包的误解国内很多的程序员一谈到外包就色变，什么没完没了的加班，做完项目就走人等等，最主要的是说外包项目没技术。 传言我个人觉得这个不能全怪程序员，由于早期的外包，以及项目管理的方式都违背了一些软件开发的本源，导致出这样的一个结果，其实这些问题，在非外包公司里更严重，也同样存在，而软件行业又是外包的主要一个领域，就显得大家格外关注，而且程序员又是喜欢上网的一群人，所以对一个事情的传播非常快，而且年轻人居多，不乏一些FUD的人员。 国内某些不良外包公司我们公司确实有一些程序员的上一家公司里是这样的，这样的公司大概是这样的： 这个公司主要是做国内的外包，老板对软件没有什么概念，认为做软件跟盖楼是一样的。所以，有项目就堆人，找最便宜的人，项目不能按时完成就加人，我时常对这种情况，想说：“老板，你是黑色会吗？ 做项目还是打架，靠人多？” 这样的公司做项目时，第一要素是最大的利润，也就是最大化的从客户那里赚取利润，赚自己的钱，让客户无钱可赚，赚员工的钱，让员工够活命就行了。 由于是搞房地产的，或者是有几个搞房地产的朋友，觉得自己也要搞个软件业的房地产，找一个技术好点的，剩下的都是能多便宜就多便宜，是不是像建筑行业从设计院设计个图纸，找个监理，剩下全都是找便宜的人？ 但是软件行业是不一样，每一个软件就像每一片茶叶一样，哪那么容易相似，就算茶叶一样，泡茶的人也不同呀，亲！ 我把这样的架构师叫做海鸥，在海上拉一坨翔后，飞走后你再也找不到了（你想想你会在一个地方看到同一个海鸥两次吗？）。 所以我们很多人就基于已有的设计来填空，不管尺码合不合适，也要硬往里面塞，结果能好吗？ 我想个中痛苦你们经历过的人有共鸣。 欧美外包其实欧美外包在这几年已经有了很大的进步，也越来越多的人愿意做欧美的外包，进步如下： 发包方对软件的意识提高，不在把软件看做简单的一个产品发包出去，而是当做一个软件。 敏捷开发的流行，在欧美国家有更好的认识，更多的发包方知道软件写作的重要性，而不是只是一开始给个需求。 发包方愿意花更多时间参与，我们知道软件开发客户更多的协作的重要性，因为很多东西在开发过程中才能发现和改进。 发包方里有更多人了解软件开发，开始接受重构这样的一些工作并且愿意为之付费。 SCRUM或者Kanban让异地的团队更好的协作 所以和欧美软件公司合作，你可以学到很多正确的做软件或者产品的方法。 总结根据我的经验，欧美的软件公司更早，更多的开始使用正确的软件开发方式和对软件行业的正确认识，欧美很多国家软件从业者很受其它工作者的尊重，而中国很多的程序员还被称为 “程序猿”，“码农”，“IT男”，非诚勿扰你要敢说你是程序员，我想肯定是关上灯留下一屋子黑。（不过很多姑娘被别人留下一屋子黑后，还是觉得程序员挺好的）。","link":"/2015/02/11/management-2015-2-11-outsourcecorrect/"},{"title":"微软程序员最好的时代来了","text":"每过一段时间就有人跳出来说微软不行了，.NET不行了，然后就去舔Java, 但是一直让我觉得比较奇怪的是，几年以后那些人还在用.NET,而且继续喷着.NET, 舔着JAVA, 在我看来，这些人和那些天天喷自己的公司，却依然在那个公司，天天喷中国，却依然在中国的那些人是一样的。 语言只是工具因为我不是非常熟习JAVA, 所以我不知道JAVA擅长做什么，但是我觉得.NET能做的事，基本上JAVA应该都能做，就像我认为JAVA能做的事.NET基本也都能做一样。但是奇怪的是我经常看到的是.NET人员喷.NET, 很少听到JAVA人员喷.NET, 不过我估计很多JAVA人员应该也忙着去喷JAVA吧。这个其实和语言没关系，只是和人的心理有关系，因为人总觉得“碗里的没锅里的好”。 语言之争已经持续很多年了，其实这个大家都知道没什么意义，网上不是流传一个语言的鄙视链吗？我觉得大家把他当个玩笑罢了，千万别当真，因为不管怎么鄙视，我们毕竟要吃饭的。 本来我也觉得写这篇文章没什么意义，但是看到那些喷.NET文章，基本上句句说的都没理，但是却可能对初入行的人带来很大的误解，就像骗子很容易骗小孩，因为小孩涉世未深。 我做开发已经10多年了，学过很多语言，但是真正用来吃饭的最主要的语言其实是Visual Basic和.NET, 当然还有”汉语”. 当初也学过Java, JSP, SSH. 但是最后选择了.NET，为什么，一是因为.NET技术真的入门很快，当年入门快的好处之一就是你立马就有一定的生产力，也就是你能很快开始干活，这样就有公司愿意给你付薪水了，也就意味着你可以更早从父母那里断奶了，另外一个原因就是当时面试的要.NET比要JAVA的多呀。 C# 语言我学习过C, Java，Visual Basic, Ruby，Node.js等，但是我还是觉得C#是生产力非常高的一门语言，比如一些非常优秀的语言特性，你刚刚才能从其它语言里看到一点点，比如自动属性，LINQ, Lamda表达式，Action等，另外C#对多线程的封装让我们在多线程编程时极其方便,比如TPL. 还有令大家头疼的异步回调的问题，C#用非常优雅的Async, Await来解决，我们看到ES7里面已经开始实现类似的东西，是不是借鉴了C#呢？ 多语言混用对一个稍微复杂一点的程序来说，我们为什么一定要只使用一个语言呢？比如我们前端可以使用ASP.NET MVC, 后端可以使用Java 甚至是别的任何一个语言，服务我们可以使用WCF, 搜索我们可以使用Solar等等，我们甚至是WEB层，业务层都是用.NET, 而数据库可以使用MySQL或者MongoDB. .NET或者JAVA只是系统的一部分我们知道一个WEB程序，除了后端以外，很多其它的东西比如HTML, CSS，JavaScript,数据库这些不管你做Java还是.NET都是一样需要的。也就是前端技术都是相同，另外HTTP协议，TCP/IP这些也不分语言吧。不管你是JAVA还是.NET, AngularJS, ReactJS, HTML5, Bootstrap, Bower, Grunt, Gulp这些东西对你都是一样的吧？ 微软技术能做什么我没有做过JAVA程序，但是我使用微软技术10多年了，我就说一说微软技术能做什么。 桌面程序Visual Basic当年我毕业没多久，就加入一家马来西亚在中国的软件公司，这个公司主要是做门票系统，当时我们选择了Visual Basic, 做过VB的人都知道VB是多么的强大，除了极其方便的可见即所得的Form外，而且有几乎一切你想要的组件，另外我们都知道Windows是桌面系统中当之无愧的的霸主, 我不知道JAVA在这方面的优势是什么，如果有些人说要跨平台，但是我做了这么多年的企业软件，没有几个企业软件是需要跨平台的。当时在这个公司里做了售票系统，还有闸机系统，POS系统，我估计很多人不知道闸机系统原来用Visual Basic也可以做。广州，北京最大的游乐园都是我们当年做的，而当年整个乐园的信息系统都是使用的微软的技术。 WPF微软推出的WPF, 我觉得是对桌面开发程序的极大的进步，几乎所有的桌面程序的展示都可以使用WPF来呈现，而通过WPF可以让我们非常方便快速的做出非常炫的桌面程序，WPF的XAML方式给了我们非常方便的写桌面窗体。 同时模板，动画等在WPF都是极其容易实现，另外MVVM在WPF的应用里非常盛行，WPF可是比Angular早出现了很多年。 UWP不久前，微软推出了Windows 10, 这使一套系统可以运行在桌面，平板以及手机上，而我们可以使用XAML,甚至是JavaScript来开发一套程序就可以运行在多个终端，这个对个人用户可能没有什么，但是对企业用户太重要了，具体的细节我觉得大家可以去看一下MSDN或者Channel9 WEBASP.NET WEB Forms我觉得很多人对微软的误解可能主要是这一部分，当年的ASP.NET WEB Forms由于是快速拖控件，导致界面生成很多难以认识的代码，大量的ViewState等，但是这并不能说ASP.NET WEB Forms不好，第一我们可以使用ASP.NET WEB Forms快速完成一些小型的WEB程序，加上有大量的第三方控件，是开发一些常规的程序快如闪电。第二我们可以尽量使用客户端的控件比如Repeater等，现在仍然有很多网站都是ASP.NET WEB Forms做的，难道这些网站都没有用户?! ASP.NET WEB MVC由于很多人对ASP.NET WEB Forms充满抱怨，而且WEB开发技术不断地革新，微软也顺应潮流及时的推出了ASP.NET MVC, 使用MVC可以写出非常清爽的代码，我们团队从ASP.NET MVC1.0 beta就开始使用，由于我也学习过Ruby On Rails，基本上这两个框架非常相似，极其方便的路由管理，View, Controller, Model的分层，使我们可以很好的使用强类型类开发，我们已经使用ASP.NET MVC成果提交过很多项目，还从来没有遇到过问题是出自.NET本身的。 WEB 服务WCF使用统一的模型，让我们开发WEB服务极其方便，大部分情况下我们只需要定义一个接口，配置相关的Binding和EndPoint就可以了，可以很方便的使用Http, TCP, Https，可以非常方便的使用各种安全策略，而这些就只需要简简单单的几行配置而已，WCF极大的简化了WEB服务的开发。 ASP.NET WEB API除了WCF, 微软又推出了ASP.NET WEB API, 使得我们开发轻量级的WEB 服务极其容易，使用ASP.NET WEB API 我们可以非常容易实现服务的Restful. 而使用OWEN我们可以以任何方式来部署我们的API。 Azure 微软云微软的云非常的强大，使用过微软云的都知道，微软云几乎可以满足我们一切对程序的要求，我们可以使用Azure web apps很方便的创建一个WEB, Webjob, 我们可以使用Azure SQL, 使用Azure storage, 可以极其方便的使用云的Queue, Bus等等，而且云集成了很多优秀的第三方程序，比如我们可以使用Redis作为Cache. 另外微软的Cloud Services让我们可以极其方便的管理我们的部署。这让我们很多程序员从一个程序员可以快速成为可以运维企业整套系统的人，而你只需要学习一些Azure的管理知识，比如自动扩展等等，而这些在云里面都可以快速简单的配置。我们几乎一半客户的系统都运行在Azure里面，而且我们可以一键部署，如果有问题，我们甚至可以使用Visual Studio来直接Debug云里面的网站。 移动开发由于Mono，现在可以使用.NET来开发移动的应用程序，使用Xamarin可以使用C#开发出和原生性能一模一样的iOS和Android程序，我也熟悉Objective-C, 而且用Objective-C开发过程序，虽然说Objective-C 在某些方面很优秀，但是开发效率实在不敢恭维，不然Apple也不会推出Swift来革自己的命，另外当你既需要iOS,又需要Android的时候，你至少需要一个熟悉Objective-C的，又需要一个熟悉Java. 而同样地东西需要做两遍。而使用Xamarin做企业级APP，大量的业务逻辑可以共享，更别说可以直接使用效率非常的C#语言了，我们已经成功提交了好几个基于Xamarin的程序。 另外，Xamarin推出的Xamarin.Forms可以使用XAML及C#用一套代码来开发iOS, Android以及Windows Phone的程序，而且性能和原生的一模一样，我们也顺利开发过基于Xamarin.Forms的程序。 游戏开发现在已经有很多程序基于Unity开发，而你可以选择C#来作为基于Unity的游戏的主要语言。可以搜索一下，已经有大量的上架游戏是使用.NET开发的。 小结当然，以上只是我使用的微软相关技术，目前来说，除了客户明确选择其它语言以外，还真的没有多少是Java能做而.NET做不了的。 桌面，WEB, 移动开发 都可以使用.NET，简单点说，就是你都可以使用一门语言，那就是C#来开发 开发工具Visual Studio做.NET开发，配套的开发工具是Visual Studio, 我觉得Visual Studio是最好的IDE之一，你几乎可以使用做任何语言的开发，这个使用过的人都非常清楚，虽然说Vim是编辑器之神，而Emacs是神的编辑器，但是显示世界能有多少个神？ ResharperResharper是每个.NET程序员的必备工具之一，基本上可以让我们的开发效率提高三分之一，设个谁用过谁知道。 领域驱动设计如果我没有记错的话，虽然Eric Evans较早写了领域驱动设计一书，但真正推动领域驱动设计的是有很多做.NET开发的，比如Greg Young, 我们可以看看NServicebus. 可以看看 NServicebus 我们已经使用领域驱动设计提交了一个非常大型的项目，这个项目是一个世界500强的主要系统。而这个系统就是使用的.NET C#，使用了CQRS, NServicebus, ASP.NET MVC, ASP.NET WEB API，SQL Server等等，系统已经运行了好几年了，还没有发现什么问题。 有兴趣的可以关注一下我的领域驱动系列。 长尾理论很多人说大型的一些系统都没有用.NET, 比如BAT, 比如新浪微博，他们是不是一点都没有用.NET我不知道。我想说的第一那些系统都比较庞大，使用JAVA或者PHP很多时候是基于历史的选择，另外这些系统就那么几个，而且并不是所有的软件都是电商，都是微博？ 我在这里想说的长尾，就是第一中小企业几乎占据所有的企业的80%, 而这些企业需要各种各样的系统，而这些企业不论是国内还是国外，都是Windows占大部分。虽然我也非常喜欢苹果的产品，但是企业是需要赚钱的。 也就是说80%的企业都不会像BAT那么大，那么至少这80%的系统使用.NET开发没有任何问题，再加上.NET有着很高的开发效率，我们有什么理由不选择呢？ 使用.NET应该是企业或者客户项目的第一选择如果只做WEB系统，或者只做电商之类，那么使用其它任何语言都没问题，但是一旦做企业系统，往往.NET是一开始非常安全的选择，为什么？ 因为很多企业使用的系统是Windows， 使用的办公软件是Office, 使用的服务器是Windows Server，使用的是AD, 使用的邮件系统是Exchang Server， 我不知道你们使用JAVA和PHP和这些系统集成时是否方便，但是使用.NET是非常方便的。目前来看，.NET几乎可以满足企业应用的所有的现有的需求以及潜在的需求。 关于开源，关于免费现在.NET很多东西都开源了，.NET CORE 和 ASP.NET VNext已经可以跑在Mac和Linux上了，我相信会越来越多的.NET程序将来会跑在Linux服务器上，另外大部分程序根本就用不了那么多服务器，如果我们真的需要那么多服务，证明公司已经很有钱了，还买不起几个Windows？而且如果真的需要那么多服务器，我们可以使用Microsoft Azure, 买几个Windows总比要请几个Linux运维工程师要便宜很多吧。 最后，没有人限制你只会.NET没有谁能限制.NET程序员学习其他的语言，.NET程序员可以学习Java, Ruby, Node.js， 可以学习Event Driven, Message Queue, Solar, 学习MongoDB, Redis, 学习分布式缓存，学习任何其它语言需要学习的东西。 关于薪水我不相信一个人学两个月JAVA, 不学习其它东西就可以立马成为一个优秀的程序员，就可以拿到很高的薪水，因为在我看来，要成为一个优秀的.NET程序员，需要学习大量的知识，我相信JAVA程序员也是一样。如果说.NET程序员年薪几百万我没见过，但是把.NET学好可以拿到相对不错的薪水还是没有问题的。 我们就是使用.NET的技术，如果你觉得你.NET技术还可以而没有地方发挥的，欢迎联系我 wangdeshui@outlook.com","link":"/2015/11/22/management-2015-12-22-best-time-of-microsoft-tech-developers/"},{"title":"欧美软件外包系列 (二)： 谁说外包不需要技术","text":"前言由于之前一些外包公司对外包行业造成了一些不良的印象，其中很多程序员对外包的误解是就是外包缺乏技术，或者说外包行业里面学不到技术，我不知道别的外包公司，但是在我们公司，我觉得外包很多的项目对技术要求都不低。 技术其实不管是外包还是非外包，都是要做项目，说到底就是产品，这些产品可以是一个商务网站，可以是一个企业内部的系统，也可以是是一个APP等，从我接触的项目来说，形形色色的项目都可以外包，要么是全包，要么是半包。 我们想想只要是一个软件产品，怎么会不需要技术呢？ 总不能动动嘴皮子就出软件了？站在最终客户的角度，一个好的软件产品怎么样，他们需要的就是怎么样。当然，有的情况下，没有找到好的合作方式或者没有合适的价格，会经常出现一些凑合的产品或者失败的产品，这个后面我们会谈到如何避免，这里我们就是要说外包不是没技术。 外包（或者说软件项目）常常驱动一些技术拥抱变化更快的拿到 “WHAT TO DO”软件业里流行一句话，就是：“不变就是变化本身”，所以需求会经常变化，尤其是外包或者是离岸外包，业务人员没有和开发人员座在一起，这样导致变化的成本就更加增加，另外我们需要把业务人员把需求转给开发人员这之间的时间尽量缩短，就像TCP/IP一样，我们需要两端数据传输 “快速、完整、准确”，那么我们就需要像很多办法，比如我们就用到比如BDD(Behaviour Drive Development), 我们就需要用到像NSpec, NUnit这样的东西。 更快的反馈 “What We Did Is Right Or Not”同时，我们需要客户尽快的反馈，我们就需要用到自动集成的技术，我们就要用到Build系统，所以我们就用到了比如TeamCity, Jekins, Grunt, NAnt等等。我们需要解决 “防火墙”等问题，我们需要使用云比如Azure, Amazon等。 适应变化更好的架构为了支撑变化，我们需要根据不同的项目来设计好的架构，什么是好的架构呢？ 就是“一点也不多，一点也不少”，每当增加新功能的时候，我们不用改太多代码，甚至我们只增加代码，不影响原来代码，这不就是OCP（开闭原则）吗? 我们希望写过的代码能够更多的重用，已有的代码能够更稳定，于是我们就需要分层设计，我们就需要多层的架构，我们就需要解耦，因此我们就用到了比如 MVC, MVVM, Domain Driven Design, Event Driven, CQRS, Event Soruce, Message Queue等等。 可靠的质量为了提交高质量，我们除了需要一定的过程保证之外，同样需要很多技术的支撑，我们如何对我们提交的代码质量有信心呢？我们需要Unit Testing, 我们甚至需要引入TDD, 我们需要引入一些自动化测试工具来做回归测试，比如Selenium, Watin 等。为了很好的进行单元测试，我们必须要面向接口编程，我们需要去掉系统里的New. 我们因此需要使用依赖注入比如Castle, NInject, 或者Unity等。 整洁的代码为了更方便增加新功能，那么我们要更容易阅读之前的代码，这就要求我们不要产生 “Legacy Code”，因此就需要考虑什么是Clean Code, 因此我们就必须要学习S.O.L.I.D原则，我们就需要学到重构等相关的知识。 总结学无止境说到底，就是给客户提交高质量的软件，而且是高效率，也就是做出好东西，越快越好。 软件行业，聪明的人很多，他们不断在生产新的东西(语言，框架，工具)来帮助程序员提高软件的质量和效率，那么我们要想高质量，高效率做出软件，不管在哪里，我们都需要这些知识和技术。 外包更能学技术我们在一些产品公司，我们其实很难去使用一些新的技术，原因如下： 产品已经设计完成 技术选型已经确定 遗留代码太多 项目的管理人员不拥抱新技术。 但是在外包公司，更能学技术。原因如下： 接触项目多，因此可以在不同的项目里学到多种技 同时针对不同的项目，会思考多种的架构方式。 如果和国外团队合作，可以看到很多优秀的代码。 欧美常常比较先引入一些新技术。 欧美常常比较先引入一些开发模式。 逼迫你提高英语，你能看到更广阔的世界。 最后，列一下我们现在的.Net项目用到的一些技术和开发方法。 ####过程 SCRUM Kanban 开发方法 TDD BDD 架构 MVC MVVM SOA Domain Driven Design Event Driven 技术 C# EntityFramwork, NHibernate, Dapper, NoSQL ASP.NET MVC, ASP.NET Web API WCF, Restful jQuery, AngularJS Nunit, NSpec, Selenium Git, Github TeamCity, PowerShell, NAnt, Grunt Database Migration Message Queue, NServicebus Castle Event Source, CQRS, DDD 所以，谁说外包无技术？ 看你怎么做而已。 想加入我们吗？ 发邮件到 wangds@shinetechchina.com.","link":"/2015/03/16/management-2015-3-16-outsource-tech/"},{"title":"管理沉思录系列(四):我们企业文化杂谈","text":"企业文化这个话题太大，有很多学者，企业家谈论这个话题，每个人都有不同的想法，我在这方面没有什么经验，但是想基于自己目前的认知来谈谈对公司文化的感受和想法。 什么是企业文化先看一下百度百科的定义: 企业文化，或称组织文化（Corporate Culture或Organizational Culture），是一个组织由其价值观、信念、仪式、符号、处事方式等组成的其特有的文化形象。 职工文化，也称企业职员文化，是与企业文化相对应的文化形态，职工文化以职工为本，是一种素质文化，企业文化以企业为本，是一种管理文化。 企业文化是在一定的条件下，企业生产经营和管理活动中所创造的具有该企业特色的精神财富和物质形态。它包括文化观念、价值观念、企业精神、道德规范、行为准则、历史传统、企业制度、文化环境、企业产品等。其中价值观是企业文化的核心。 企业文化是企业的灵魂，是推动企业发展的不竭动力。它包含着非常丰富的内容，其核心是企业的精神和价值观。这里的价值观不是泛指企业管理中的各种文化现象，而是企业或企业中的员工在从事经营活动中所秉持的价值观念。 反正上面的定义我是记不住，那么什么是企业文化呢？ 随着这几年的不断的认识，我对企业文化有了一些自己的看法。 每个企业都有自己的企业文化其实一个企业不管怎么样，他都有自己的企业文化，很多时候大家觉得自己所在的公司没有企业文化，其实我想说“没有文化不也是公司的企业文化吗？”，所以说不管你有没有提出“口号”，这个公司都会自发的形成一种文化，只不过这种文化大部分时候都不是你想要的。比如，人员充满抱怨，做事得过且过，这不也是一种“文化”吗？ 团队活动是一种文化吗？原来，我一直认为举行团队活动就是一种文化，比如爬山，打球，聚餐等，但是后来我觉得这个还不能算是企业文化，这个只能算是一种活动，他能够提升团队的凝聚力，因为爬山、打球、聚餐这样的事情哪个公司都可以举办。 我所认为的企业文化我个人觉得，企业文化是一种能够让你实现目标，让你公司能够提供更好的产品或者服务的东西。 企业文化的作用企业文化重要吗？我认为企业文化很重要，企业文化主要有一下的作用： 弘扬公司的价值观，促进公司的发展，实现公司的目标 聚集有助于实现公司目标的员工 使员工乐意为公司的发展贡献自己的汗水 如果一个企业没有企业文化，那么每个人都会有自己的文化，这个文化很难统一，这样很难一起做出优秀的产品或者提供优秀的服务。 我们的企业文化我觉得企业文化，很难在公司刚成立的时候就建立，而是一个不断发展和完善的，应该是从员工日常工作中提炼出来的。通过这个可以影响现有或者以后新加入的人。 那我们分公司来说，一开始我一直想建立的是一种敏捷的文化，但是敏捷包含的东西太多，经过几年的实践，我发现很多新加入进来的人不知道什么是敏捷，甚至有些老员工对敏捷的理解也比较浅, 那么把敏捷作为公司的企业文化，操作起来有一定的困难。 Quality &amp; Productivity我们发现，要想有竞争力，我们必须要在两个方面突出 “高质和高效 (Quality &amp; Productivity)”, 在我们专注这两个方向来建设我们的企业文化的时候，我们很多的一些好的做事方式就出来了，比如，为了高质和高效，我们采用敏捷的开发过程，我们对质量的追求就需要我们正确理解需求，减少bug, 使用测试驱动开发等。我们对效率的追求，就让我们必须学习新的技术，持续集成，使用Git、多使用快捷键等，另外高质和高效不只是针对个人，而是针对团队，那么久要求我们有较好的团队文化，比如不要团队内部人身攻击，讨论问题不要假大空:”Show me the code”. Responsibility &amp; Passionate高质和高效让我们掌握了做事的方法和标准，知道了我们的目标，但是，后来我们发现光有这是不够的，如果没有责任心，光有方法或者标杆是不容易达到我们定义的标杆的，而一旦责任心下降，质量和效率都下降，即使我们使用再优秀的开发过程和开发工具。那么我们文化里就需要强调责任心，我们每个人都要有责任心，对团队负责任，对自己负责任，对客户负责任，对公司负责任。拿我们做项目来说，不是别人安排你做啥你做啥，而是你要把软件/项目做好，需要啥就做啥，比如，有的人就是看到了装作没看见就是很不负责任，所以，我们需要鉴别一个人是不是有责任心。 Responsibility 责任心在这里面，我想说个误区，有的人觉得，钱给的越多，责任心越大，我觉得这是一个伪定义，第一，钱多少才算是多呢？第二，如果一个人的责任心根据钱的多少来计算的话，那么管理者永远都要陷入这个里面。 事实证明，钱涨一点，短期有一定的激励，最多多做一点事，但是责任心还是没有变化的。通过我的观察，那些拿1万块的人很认真负责的人，在他们拿一千块钱的时候也很认真负责。我并不是说，我们需要克扣员工的工资，我们仍然需要给员工一份相对满意的薪水，我只是说一个人的责任心不会随着钱的变化而变化，换句话说，有责任心的人一定会把接手的任何东西都尽力，如果觉得钱少，他会提出钱少，或者换一份工作而不是消极怠工或者是降低产出。 我们公司曾经辞退一个“装睡不醒”的没有责任心的人，我曾经多次花力气想叫醒他，希望他能够有点责任心，但是事实证明 你永远无法叫醒一个装睡的人。 Passionate 激情这个是我们今年才加进来的，公司项目的稳定，不少人长期做一个项目，时间长了就有点“皮”了，现有项目觉得“轻车熟路”，因此没有学习和进步的激情，其实这个世界变化很快，尤其是科技技术行业，变化和创新日新月异，新技术层出不穷，而且这些新的东西真的是进步，极大提高生产力或者服务水平，拿软件行业来说，移动的飞速发展，让原来的传统软件向移动端转移，Cloud技术的发展和成熟，极大的提高了我们的运维，大大加快的发布和升级的周期，大大节省了成本。 如果我们不保持学习的激情，我们很难提供高质和高效的服务，而我们发现那些有激情的人能够保持对新东西的关注，而且对新东西学习，新方法或者新事物投入一定的时间，这个为公司未来的业务发展做出贡献。 另外，激情可以让公司充满活力，热烈的讨论，对生活的激情比如喜欢跑步，对技术的热情，经常学习或者分享能够让公司生气勃勃，这样的公司，让任何进入公司的人不会感觉死气沉沉，感觉这个公司充满活力，充满阳光。 总结企业文化是一种能够让你实现目标，让你公司能够提供更好的产品或者服务的东西 企业文化很重要 我们的企业文化是“高质，高效，责任，激情” (Quality, Productivity, Responsibility, Passionate)","link":"/2016/07/18/management-2016-07-18-management-thinking-company-culture/"},{"title":"敏捷实践系列(二)：敏捷意识","text":"上篇文章我提到了敏捷的心法，但是我想除了心法之外，更重要的是敏捷的意识。 为什么意识更重要？意识：辩证唯物主义的解释是，意识是物质运动变化的场所，意识是人脑对大脑内外表象的觉察，即它可以辨识自己脑区中的表象是来自于外部感官的还是来自于想像或回忆的。 我们这里说的意识，一是你能主管的去想一件事情，另一个就是你对一件事情的发自内心的认可程度。 敏捷，光有心法是没有用的，有没有要敏捷的意识，敏捷的意愿。有没有主观的愿望去做，我们经常说的话：没有成不成，就是看你想不想做。 欲推敏捷，首先要培养敏捷的意识我举两个例子： 一个是最近推行**”无车日”**, 无车日本来是想让大家绿色出行，减少二氧化碳的排放，但是结果是什么，结果是堵的一塌糊涂。 为什么？据说原因如下：有车的人想，本来平时不开车，但是今天无车日，路上车少，那我就开车肯定不赌。这样造成的结果是，坐公交的人觉得无车日大家都挤公交，开车的人觉得今天无车日开车应该不赌，所以开车。造成的结果是，公交也堵，开车也堵。这就是政府和民众对环保的意识不够，如果政府意识够了，那么政府是不是多提供公共交通的数量，以及提高公共交通的便捷以及服务？如果民众意识够了，那么我是不是可以走着去上班？我是不是可以骑自行车？我是不是可以跑步？若能如此，无车日才有了真正的意义。 另一个例子，就是我看到的道路旁边的自行车道栅栏，政府甚至花了不少钱来弄这个，但是效果呢? 我看到的情况是很多地方没人用，甚至造成地段的拥堵。为什么？ 有些地方自行车道里面有面包车在里面堵着，还有的地方有人逆向骑过来，试想，如果你骑自行车有这样的经历，你还会骑自行车道吗？骑到中间你飞出来？ 如果这个自行车道没人用，那么另一个问题又来，本来3车道，现在一个车道停车，一个车道过车，原来没有自行车道时，如果前面的车临时停车，其他的人还能利用空的地方错开车，现在就能硬等，这样岂不是更堵？结果就是，本来就赌的路，硬硬的把路切一块空着浪费了！ 从上面的两个例子，我们都能感觉到，都是为了要把事情做好，但是，就是意识层面没做好工作，才导致截然相反的结果。（以上只是我自己片面的感觉，真正的事实数据请看官方数据）。 如何培养敏捷的意识？首先，我觉得培养敏捷的意识之前，首先要知道是什么事敏捷的意识，我觉得敏捷的意识就是： 高质、高效的做事情 持续的学习 团队精神，Good team player. 责任心 关心客户的价值 解决问题 努力改变现状，不抱怨现状。 其次，那么如何培养敏捷的意识呢？我个人觉得两种方式： 招聘具有敏捷意识的人。 其实我列的敏捷的意识和大家想象的SCRUM那些无关的。 培养已有的人具有上面提到的敏捷的意识，方法比如说是宣传、强调、加薪、惩罚等等各种方法，关键是推行的人自己有没有这个意识来推行敏捷。 最后，最重要的是要让大家知道为什么要敏捷，敏捷解决的问题是什么？敏捷对工程师自己的好处是什么？因为只有人敏捷了，项目才能敏捷，所有的项目都敏捷了，公司才能说是一个敏捷的公司。若如此，强行推行一个SCRUM框架，持续交付等等，就必然走向文章开头的那两个例子，结果只能是适得其反。 愿君更饮一杯酒，敏捷路上无故人。 且行、且思、切记！ (注：佛光，图片拍摄于2015-6-6 太白山)","link":"/2015/09/28/agile-2015-9-28-agile-mindset/"},{"title":"管理沉思录系列(三):你不知道的ODC服务","text":"我们整个公司ODC的业务占了很大的比例，我们分公司做过的大部分的项目都是ODC. 那么是不是我们所有人对ODC项目都有一个正确/恰当的认识呢？我觉得不尽然，所以我想写写我对ODC的认识。一个是让我们公司的工程师知道ODC是什么，另外让客户知道真正的ODC服务是什么(除了销售的介绍，不妨听听正真服务人的想法)，他的优势是什么，如果处理不好，ODC的问题又是什么？ ODC的片面理解？在公司经常听到以下一些对解释： ODC就是按月付费我觉得按月付费只是ODC服务的一种付费形式，他根本不是一种服务。 ODC就是按时间付费这个也是片面的，1个小时也是时间，一个月也是，一年还是时间。几天的服务算是ODC吗？我认为不是。 ODC是Offshore development center这个解释也太过“干瘪”，离岸开发中心？ 离岸研发中心？如果这样理解，他就是离岸的一个办公地点而已嘛！ ODC到底是什么？对我们公司来说，我觉得ODC是一种合作方式，他的产出是一种服务，这个服务可以是如下一些交付物： 软件——-交付高质量的软件 咨询服务—-企业信息化(软件项目的立项，软件项目的规划, 开发商的评估等等) 而ODC服务要做好的几个主要的部分，我觉得是： O (Open): 双方都必须开放，必须透明，只有这样，才能做好互信，才能更好的信息共享。 D (Development): 这个部分是开发，或者咨询服务的实施过程 C (Coperation): 合作，我们知道客户合作胜过合同谈判。 ODC的模式好处有哪些?我认为ODC有几个很主要的优势： 软件开发，需求很难固定，尤其是现在这个变化极快的时代，一旦需求固定，将失去竞争力，拿现在手机开发来说，如果一开始定义了一个手机，而且严格按照计划来，一年以后等你上市时，发现大部分手机都有了指纹功能，而你的没有，那么你的手机就毫无竞争力，让之前的付出瞬间付之东流。 ODC的合同一般更倾向于长期客户，这样可以让团队成员能够更稳定，让熟悉的人能够长期服务于这个客户，大大降低了产品的风险。不然，A做的东西让B接是很需要时间的，如果A已经离职或者服务于别的项目，那么很可能导致项目难以持续。 ODC的付费形式是按月付费，可以大大降低客户的成本风险，以及可以节约现金流。 ODC的服务的交付大部分都是增量式，比如2个周一个迭代，客户可以尽早发现项目中的问题，尽早给予反馈进行修复。甚至尽早终止项目来减少损失。 ODC服务需要把双方都理解为自己的同事，开放(O), 合作(C). 没有信息影藏，双方都是想把产品或服务做好。 更容易激发双方的创造，不用过于盯着一开始定义的功能，不用过于在乎KPI (Kill people idea), Business value才是最重要的。 ODC使开发人员有更长时间来不断加强对客户的业务领域的理解，从而提交更好的产品和服务。 ODC使的软件提供方更容易做出计划，从而可以让开发人员更专注于一个客户的项目，想想固定价格的项目，很多友商固定价格的项目常常一个人同时做好几个，根本没时间来深入理解客户到底需要什么。 ODC的项目也更容易规划开发人员的个人发展，更容易做出一个长期的计划，从而增加员工对公司的认同，一个能留住人才的公司，肯定是可以提供更好的服务的。 ODC的好处远远不止这几点，我们使用ODC成功提交了大量的项目，当然单单使用这种合作模式也是不够的，软件行业想在ODC服务模式下提供高质量的服务依然没有那么简单，具体怎么做，欢迎阅读我的 ODC的问题ODC的模式固然有很多好处，但是这世界上从来没有任何一个模式是完美的，经过这几年的服务，ODC也有几个常见的问题, ODC一个最大的好处是可以让人员稳定，可以留住人，但是最大的问题也是留人问题： 项目周期太长，开发人员觉得枯燥有的项目做的时间比较长，比如5年以上，那么开发人员使用的技术就没有那么新，虽然这个对项目本身问题不大，但是技术人员第一都是喜欢追求新技术的。其次开发人员和别的项目或者开发人员讨论，觉得自己的技术已经没那么时髦了，容易产生浮躁的心里。 其实，解决这个问题的方法有几种： 在现有的项目里使用新技术，比如很多公司在使用的Powerbuilder可能需要更换为WEB系统或者新的技术，不然将来谁来维护？ 部分功能或者子系统使用新技术，比如部分使用NoSQL, Elastic Search，Cloud等新技术除了提高系统的性能，降低维护的任务外，开发人员也可以学到很多新东西 更换部分人员，更换部分新成员到项目，老成员可以做别的项目 但是，这些都需要客户方的大力支持，ODC提供方是很难单方面进行改进。 报价增长太慢，不符合开发人员薪水增长预期。这个也是一个常见问题，程序员的薪水每年都希望提升，而大部分公司程序员薪水的提升是和程序员给公司能带来的价值/收入来决定的，也就是基本上和报价关联度比较大。当然，我们可以不关联，那么如果不关联会带来更多的问题。这里面出现的矛盾是，正常情况我们和客户都会说每年有一个百分比的报价提升，但是这会受到几个因素的影响，一是这个百分比是否和整个市场薪水变化同步，而是部分开发人员能力提升较大，自己期望高于这个百分比的薪水涨幅 这个问题解决方法其实也是有三种： 降低利润 客户接受对应报价的提升。 人员离开项目 在人员的生产效率没有降低的情况下（理论上每年应该都有提高，因为对项目业务更熟悉，使用的技术更熟练），我个人一直觉得第二种是对客户最好的一种方式，因为 报价的提升是恰恰是成本最低的，同时想想这个开发人员对项目的过去几年已有的贡献，他应该享受某些程度上的不可替代带来的回报提升。 开发人员同一项目时间长了，皮了！工作效率下降。当我们很多东西都熟练的时候，我们原来8个小时的工作量很多时候6个小时做完了，虽然某种程度对客户的产出没有变化，那么时间长了，我们人就比较消极，在一种消极的情况下，稍微有一点有挑战的新任务，都会没有好的产出。 这种解决办法，我觉得只有一个，那就是换人！ “富成一个废人”ODC项目时间长了以后，大家压力不是太大，所以容易进入舒适区，舒适区呆久了，一旦换个项目，很可能适应不了新的节奏，新的知识或者丧失了学习的能力，从此“富成一个废人”。 这种解决办法，就是ODC我们也需要不断提高我们的质量和效率！使用正确合适的开发过程来避免这些发生，参考我的敏捷系列 总结废话少说，最后几句重要的。 ODC 卖的不是时间，是服务呀，时间人人都有哇 ODC 是一种合作方式 ODC 的产出是服务 （软件或者咨询) ODC 是为了提高质量和效率，不是为了多挣钱, 多挣钱只是ODC的附属产物 ODC 是为了更好的员工发展规划做基础，员工Happy，才能做好服务，客户才能Happy","link":"/2016/06/20/management-2016-06-20-managment-thinking-odc-services/"},{"title":"管理沉思录系列(二):加薪的&quot;艺术&quot;","text":"背景作为一个分公司负责人，绩效考核，薪水定级这些事情直接关系到分公司的生死存亡，所以向来都是我工作的主要内容之一。尤其是软件公司，人才是唯一的资产，而绩效考核往往决定是否可以吸引人才和留住人才。 分公司成立快5年了，也做了很多项目，其实考核的方案也每年都有变化，而也在薪水提升和管理上吃过不少“吃亏不讨好“的事，比如干过这样的蠢事：有个员工表先不好，为了激励他，给他进行了加薪。但是，加薪后还是一直表现不好，当我们辞退的时候，他竟然问我，如果我表现不好，你为什么给我加薪？ 类似的事情，有几次处理的不好，主要的原因就像我第一篇 管理沉思录系列(一):开篇, 小公司，人少，项目一个萝卜一个坑，把坏萝卜拔了，坑就很难很快填上，不敢顶失去项目的压力，但是恰恰是害怕失去项目，却为公司发展带了一些管理的债务。 另外，也有个别些员工受到一些“风”的吹动，心里难免会躁动不安，提出了离职。员工离职的原因林林总总，千差万别，但是背后可能原因基本都是一个，觉得薪水低了。这个时候，为了保住项目，很多人选择的方法都是给这些提高薪水留住人，但我的想法不同，我一定会留人，但是绝对不是提高薪水留人，下面我来说一下原因： 为什么不能随时调整薪水？公司必须有考核制度一个公司如果薪水的定义，完全凭老板自己来定，或者随时来调整，那么员工如何保证自己把精力放到自己的工作之中，放到自己的能力提高之中，放到产品的质量，效率和服务来？ 如果一个公司没有考核制度，那么没有“政治能力”的人就会很吃亏。一个软件公司能变成“后宫”。 薪水的调整必须有定义好的时间点考核一定是对一个周期的考核，而这个周期不能对有的人是一个月，有的人是一年，如果这样，就说明你有一个“任性”的领导。 拿我们分公司来说，这两个时间点就是： 每年的考核制度更新时，也就是1月1号 客户项目报价的调整，也就是新的合同签订时。 薪水是双方的“合同”，是一种承诺，体现了契约精神。一般，每年薪水的调整时，会和员工进行沟通，员工如果同意了，其实就是对公司的一种承诺，对客户的一种承诺，在这个周期内应该遵守承诺。随意调整薪水，如果工作内容没有变化就伤害了契约精神。（注：我第一分工作没到合同周期结束我辞职了，我给公司支付了赔偿，第二分公司，我是等到合同期结束才辞职) 不能造成 “会哭的孩子有奶吃” 的局面很多管理人员可能遇到这样的场景：资深员工找你加薪，或者暗示你他们的所得低于付出，甚至旁敲侧击的告诉你有很多公司能给他更高的薪水，你怎么办？这个时候，这个人可能是公司关键人物，可能是某个项目的核心成员，你可能也认同他的一些想法，然后给他加薪，这个看起来很合理，但是这个时候你违反了考核制度，也没有到调整薪水的时间。同时带来了更大的危害，因为你的行为并不是推动公司发展，加薪是因为他提出了加薪的要求 而不是他工作更出色了。这会带来几个严重的问题: 没有不透风的墙，大家会纷纷效仿，大家相互比较的不是谁的表现更出色，而是谁去找了老板加薪。 大家都想办法把自己编程“关键人物”，平时信息不分享，自己做的东西只有自己知道，然后对老板提出威胁。 公司里默默无闻，踏实干活的人将享受不到这个“福利”。 大家都学会了“哭”，因为“会哭的孩子有奶吃”。 那么老板就等着疲于“哄”孩子吧。 如何调整薪水？薪水调整的时间点和方法每个公司，每个管理者都有不同的方法，不同时期都有不同的考核制度，但是我觉得有一点是不变的，那就是不管什么考核，都要“公平，公正，公开”，同时，不要随意打破规则，新规则没出来，所有人都必须遵守老规则。 就拿我们分公司来说，薪水调整的时间点和方法。 要想提高薪水，首先提高能力，能力提高了，就提高对客户的报价。 如果考核周期中觉得自己不公平，可以提出改进考核的建议。 要求加薪需要在正确的时间点，一个考核周期没结束或者报价没变化时尽量不要要求随时加薪，重承诺。每年对考核进行修正，可以提出考核制度需要改进的地方，可以提出考核制度不公平的地方。另外一个时间点就是和客户谈新的报价或者合同之前。 可以做更多的事来提高薪水，可以给公司带来更多的价值或者收入。 不要让员工讨价还价比如制定一个清晰的考核计划，严格的执行，同时让员工贡献自己的想法，以免出现不公的事情。给员工清晰的薪水提升路线、时间、方法。 做好这些后，如果一个员工告诉你他找到了一份好工作而要离开时，这个时候你的立场一定要坚定，不要模棱两可，也不要发出错误的信号，让其他的员工感觉你通过加薪而留住了他们，对那些不想为公司工作的人不要留恋。 写在最后所以，加薪是一把双刃剑，用好了，事半功倍，用不好，事倍功半！ 我也在不断学习和思考，愿君与我同行，愿我们公司的小伙伴一起出谋划策，打下一片江土。","link":"/2016/06/15/management-2016-6-15-management-salary/"},{"title":"团队最佳实践和 GuideLine 系列 (一)：SCRUM","text":"我们团队做了好多年的项目，也成功提交了不少项目，所以我想总结一下一些好的实践，在这里给大家一个参考。 介绍好的团队一定有一套自己的流程，不管是使用敏捷或者传统的开发过程，我相信都有一套自己的方法。我们团队实践多年的过程中，觉得敏捷是比较适合我们的，而在不断的摸索中对SCRUM更多的认可和适应了。今天我就先来简单的介绍一下SCRUM, 细节的内容大家请参考 &lt;&lt;硝烟中的SCRUM和XP&gt;&gt; Scrum下面的SCRUM东西，有很多是我们自己总结的。 SCRUM 主要流程 SCRUM 原则 关注产品的Delivery 透明 短迭代 整体质量 团队合作 持续沟通 承诺 自组织 尽早让问题暴露 团队组成 一般是5到9个人 开发团队全功能，开发，测试，UI等 全职 自组织 全体成员对质量负责 评估功能复杂度","link":"/2016/04/05/practices-2016-04-05-team-guideline-scrum/"},{"title":"团队最佳实践和 GuideLine 系列 (二)：代码规范的意义","text":"有不少写代码总是只按喜欢按自己的习惯写，但是如果这个产品永远是你自己一个人来写和维护，那么问题不大，那么如果是有很多人协作，那么麻烦就大了，我相信有很多人说了很多代码规范的重要性，我今天在这里只提两点意义。 可读性代码规范最大的目的就是保持可读性。 Martin Fowler 说: Any fool can write code that a computer can understand. 随便找个笨蛋都能写出电脑可以明白的代码 Good programmers write code that humans can understand. 好的程序员写的代码是让人能看明白的 其实，明白了可读性重要后，是有一些方法来提高可读性的。 自己每写完一段代码，至少读三遍，看看是否能够明白，知道为什么要这么写和自己是怎么写的。 代码写完了，可以让别人看你的代码，就看那一个方法，不要太多上下文，如果别人能够明白，就是很不错的。如果不明白，可能是命名不对，或者if,else太多大家被绕进去了。 好的代码光看类名就知道类是做什么的，光看方法名就知道这一个方法解决哪一个具体问题（单一职责） 写单元测试，如果代码测试覆盖率好，可读性也更好，前提是单元测试要写好。 可读性好的代码，任何人也都可以帮忙写单元测试。 可维护行代码规范的另一个主要目的就是可维护性。 可维护性就是：how easily a system can be modified 这个可维护性一定还是基于代码的可读性上，在可维护性方面有几个实践记得参考。 写代码的时候一定要觉得我做的产品将来我会维护，当然肯定不全是，但是做的时候要这么思考 保持一个廉耻心，心里想着如果代码不是我维护，将来千万不要改代码的时候让别人问候我的家人 使用大家熟悉的技术或者通用的技术。 使用大家常用的一些结构比如MVC, MVVM等等。 使用一些好的实践比如单元测试 （修改代码的时候就不怕破坏隐藏的功能） 留下必要的文档。 项目相关的东西集中在一起。","link":"/2016/04/06/practices-2016-04-06-team-guideline-purpose/"},{"title":"团队最佳实践和 GuideLine 系列 (三)：我们的一些代码规范","text":"下面是.NET项目的一些自己的规范 代码顺序 Using clauses Name space Class Private field Protected field Private attribute Protected attribute field Public attribute field Constructor Public method Protected method Private method 代码注释 尽量不写注释 代码本身应该可以自解释 如果代码足够复杂，确实需要的时候再写注释 不要写只给自己看的注释，那叫笔记，你写到别的地方 如果代码没写完，就一定要加个 TODO: 注释 Hard-Code 永远不要hard-code 配置一定要放到配置文件，比如API地址，数据库连接，一些魔数等等 代码可读性上面 至少读三遍自己写的代码 团队里的人应该都能看懂你的代码，看不懂不能觉得别人笨，可能是自己代码可读性不高 不要出现水平滚动条 （1024以上的分辨率） IF语句签插一个空行 Return语句钱插一个空行（除非return在if后面可以写到同一行） 方法之间要插入一个空行 异常 不要把异常堆栈信息抛到客户端 在程序最上层一定要不捕获未知异常 未知异常，日志里要记录堆栈信息 定义非常具体的异常，不要通过异常信息判断, 记录异常信息时使用 Log(ex.ToString()), 不要使用Log(ex.Message) Password_Is_Less_Than_Seven_Exception Age_Must_Be_Greater_Than_18_Exception NULL 不要忽略对NULL的处理 不要假设值永远不能空，如果是这样，请抛自己定义的异常 一些集合可以在构造函数里初始化，避免空 一些工具比如Resharper可以检查空","link":"/2016/04/07/practices-2016-04-07-team-guideline-code-guide/"},{"title":"团队最佳实践和 GuideLine 系列 (四)：如何做一个Feature","text":"我一直认为一拿到任务就开始写代码是有问题的，而这是很多人的习惯，结果就是不断的修改，我还是那句话，作为程序员我们是要把代码写对，而不是把它改对。 下面我就说一下拿到任务后整个流程应该是什么: 充分理解需求，不要立即写代码 设计 （主要是思考如何实现） 找出需要和别的代码交互或者集成的部分 开始一个新分支 设计接口 （尤其是需要和别人交互的代码） 实现接口 编译通过 单元测试覆盖全代码 所有单元测试通过 冒烟测试通过，就是至少自己点一点，测一测 功能测试通过 合并Develop代码到这个分支 若有冲突解决冲突. 重复7到11. 合并回Develop","link":"/2016/04/08/practices-2016-04-08-team-guideline-how-to-start-feature/"},{"title":"团队最佳实践和 GuideLine 系列 (五)：Definition of Done","text":"Definition of Done: 就是对做完一个功能的标准是什么，只有我们提前定义好了标准，我们才知道结果是一种什么样的期望。 我们团队的DONE标准我们大家原来的时候总有一个习惯，你问进度如何，总是说快完了，马上完了，如果期望这个东西是10个小时做完，当天下班时，你问开发人员，他说的这个”马上”一定是至少还得一天，基本上他说90%了，那基本上就是还需要40%的时间来完成剩下10%的功能。如果我们设置一个中间状态，那么事情永远到不了我们想要的质量，因为大家着急把功能做完，但是没有测，或者没有单元测试，或者还有一个小功能没有实现。 所有任务只有 “DONE” 和 “NOT DONE” 状态，没有90%完成这样的。 代码写完了，签入了，编译通过，符合当前版本的需求。 代码Review过了。 持续集成没有错误。 单元测试覆盖通过了。 部署到对应的环境并且测试通过了。 任何编译，部署和配置的改变都已经开发并且文档或者交流过了。 如果需要文档等都已写或者更新。 完整的DoD 细节就不解释了，如果需要解释的，请在文章后留言。","link":"/2016/04/09/practices-2016-04-09-team-guideline-definition-of-done/"},{"title":"团队最佳实践和 GuideLine 系列 (六)：Git规范","text":"之前我讲过Git flow, 请参考我的文章敏捷实践系列(四)：代码管理流程 想知道个整体概念的，就看一下下面的图 我们团队的Git规范 使用Git时，总是使用SSH连接 任何时候不要在代码里包含密码，尤其是数据库密码，服务器密码，即使你删掉了，因为Git history可以看到所有历史！！！ 严格遵守Git flow 每一次提交都要写清楚修改的是什么 每天离开办公室必须提交所有的代码到Git服务器 频繁提交 （small workable piece of code） 如果你feature分支没有完成,不要合并回Develop分支, 请参考之前文章 Definition of Done 仔细检查config的设置，不要用自己本地的覆盖了服务器上的。 每一个新的feature必须在一个新的分支上。 解决冲突后，一定要测试！！！","link":"/2016/04/10/practices-2016-04-10-team-guideline-git/"},{"title":"团队最佳实践和 GuideLine 系列 (七)：给客户提交前的CheckList","text":"给客户提交前除了完成之前提的Definition of Done, 良好的代码规范等，我根据大家比较容易忽略的地方，列出来作为这一方面的规范。 给客户列出按计划或者需求定义但是没有完成的功能 （这样，客户就不会把这类问题当Bug） 给客户准备测试数据 确保你的测试数据和你给的客户的版本匹配 （容易出错的就是数据库脚本和客户用的不一致） 列出客户需要注意的地方，比如数据库连接字符串，API地址等。 确保你的最后一次改动，程序能够工作 （容易出错的是你发现了一个错误，然后就改了，但是你觉得是小改动，没有测试，但是导致客户连主页都进不了） 确保客户测试或者运行系统需要的所有信息。","link":"/2016/04/11/practices-2016-04-11-team-guideline-deliver-check-list/"},{"title":"团队最佳实践和 GuideLine 系列 (八)：沟通","text":"沟通是软件开发过程中极其重要的一部分，今天主要列一下做项目的时候沟通的规范 和客户沟通之前先和团队沟通。 第一时间提出你遇到的问题和障碍。 了解团队每个成员擅长的东西。 不要浪费时间寻找方案，如果团队成员有人有相关经验。 如果你自己对某些需求或者方案不确信的时候，一定要找团队一起沟通一下。 沟通的时候必须态度端正。 沟通的时候必须讨论事情本身，不得有人身攻击。 沟通的时候所有人都有表达想法的权利。 必要的时候 “Show me the code”!","link":"/2016/04/12/practices-2016-04-12-guideline-communication/"},{"title":"团队最佳实践和 GuideLine 系列 (九)：CSS和JS","text":"CSS和JavaScript的规范网上有很多，今天列出一些规范 JS代码一定要使用模块话，比如RequireJS, ES6等等 不能写内联样式 不要直接在页面写CSS和JavaScript代码 （放到独立文件里） 不要在JavaScript写HTML代码，除非是是组件里，尽量使用HTML Template BR 标签只用在段落里，不是用来换行的!!! CSS的命名需要和内容匹配，不要写成left-nav, 要是你想放到右边呢？使用side-nva. 就是这么几句，能做到就很不容易！","link":"/2016/04/13/practices-2016-04-13-team-guideline-css-js/"},{"title":"团队最佳实践和 GuideLine 系列 (十)：单元测试","text":"之前的文章写过 单元测试最佳实践 有兴趣的可以看一下，今天列出我的单元测试规范： 单元测试规范： 所有public方法必须被单元测试覆盖 只测试public方法 不要依赖其它的类，除非是静态Helper或者测试框架的类。 所有需要依赖类都必须被mock。 必须很快速的运行，单元测试里不能有耗时的代码 使用一些工具，比如NCrunch 可以在后台实时运行单元测试，随时知道自己写的代码有没有破坏测试。 文件，外部Service和数据库的存取都必须mock掉 单元测试要可以无限次的重复运行 单元测试不是要实验想法，不要去测.NET本身的问题。","link":"/2016/04/14/practices-2016-04-14-team-guideline-unit-testing/"},{"title":"路千万条，但你不能同时走两条路","text":"春节期间，我在上大三的外甥想让我改一下简历，想试试找工作，同时他说也有考研的想法，我说改简历是很容易的事，关键是简历的内容，是谁的简历，至于简历格式，只要整齐就行，我还没看到有几个是因为简历做的漂亮而拿到高薪的。 我一听这个想法，大概就能猜到他是想试试是否能找个好的工作，如果不行的话，就去考研。估计很多学生是这个想法，而且很多父母也赞成这个想法，但是从我个人的观察来看，这个想法是很危险的。 原因在我看来是很简单的，我们很多时候做事都说两手准备，但是最后两手都没准备好，我多年的经验和教训告诉我，我们一段时间只能专心做一件事，就比如“条条大路通罗马”，但是你同一时间只能在一条路上，否则你就永远站在十字路口彷徨。好听点是两手准备，不好听就是三心而已。 如果我们要考研，那么我们就需要准备考研的课程，比如语文、英语、数学等。如果你考研考不好，要么说明你学习能力有问题，要么是没有认真学习，一个既不认真，有没学习能力的人，你凭什么说可以找个好工作？ 如果你选择找工作，那么一点也不轻松，你需要锻炼很多能力，沟通能力、合作能力，为人处事，就拿软件行业的工作来说，很多优秀的学生大三的时候已经可以做很多有意思的东西，算法，编程等等要开始有自己的Demo或者作品了，需要刷大量的面试题。所以如果要想毕业就找份好工作，哪有时间去专心考研？ 我给他的建议，就是把简历的东西先放一边，先想清楚到底是想考研和找工作，这两条路没有一条轻松的，也不存在这条路是那条路的退路，就选中一条路使劲的走，如果选择了考研，就不要羡慕别人找了个好工作，如果找工作，就不要羡慕别人考了个好大学的研究生。 路有千万条，我们这一生最终有且只能走出属于自己的一条，这就是我们给自己画的人生轨迹。 最后，如果考研，我建议他换个专业，他本科学的是通信，到不是说通信专业不好，而是我觉得本科是通识教育，大部分大学生本科里的专业课都是60分的水平，换专业最大的好处，就是多了一个学科，就多了一个看世界的角度，这世界很多的创作和发明都是有跨学科背景的，乔布斯不也是因为上了书法课而让产品上了一个层次吗？而且乔布斯一个理科生却让他的演讲让很多人顶礼膜拜，这个以后有机会再说跨学科的重要性。写到这里，有些人要抬杠了，说你不是说要专心，同一时间只能走一条路吗？是的，但我并没说不同时间不能走两条路，而且考研换个专业其实也是殊途同归，因为我们最重要的是提升自己的能力和输出价值。","link":"/2019/02/11/personaldev-2019-02-11-focus-on-one-road/"},{"title":"聊聊专业和业余","text":"昨天和朋友聊天，说到一个事情，他说这个事情简单，一些业余的人就可以，我给他说很不一样，然后说后面写篇文章说一下，于是有了此篇。 理解专业和业余的区别，异常重要，会让我们进步非常快，不会让我们浪费如此珍贵的人生。 毕业工作很多年，如果让我说一个感受很深的体会的就是 专业 和 业余 的区别，我想很多人都能理解这两个词的字面意思，但是要想有深刻的感受，却是不易。 就比如我们看很多体育比赛，觉得人家没啥，就拿大家经常骂的国足来说，很多人老觉得自己踢球也还可以，还不如自己上去踢，那是因为这些人没亲眼见过人家的系统训练，现场观球很多时候业余人员也不太容易看一个人踢得如何，大部分主持人说的头头有道，估计最差的足球教练都不相信他们的胡扯，20年前，还是陕西国力的时候，我就看到一个陕西国力替补球员见球迷的时候，现场颠球跟玩一样，当然不是说颠球好就球踢得好。还有人说，女足水平太厉害了，国足踢不过女足，那都是超业余得看法，国足要是踢女足得话，完全是大学生欺负小学生，职业化水平差距太大了。 我拿我自己经历的几件事来说一下： 第一个例子：我们每年公司都举行一次乒乓球比赛，而且我们公司放了个乒乓球桌，大家还经常练一练，我自己还拿过公司乒乓球比赛的第三名（业余人也不多)。我们有一个瑞典的客户在我们这边待了半年，他不太会打球，所以我们公司的中外大战，依然是大部分中国人获胜，去年10月份，那个客户说他哥哥要来西安玩，说他哥哥小的时候训练过几个月，我们根本当回事，但是结果是把我们虐的一塌糊涂，我们全公司的连发球都接不住。（下面就是他在发球) 所以，从这件事上充分说明被专业训练过几个月的人轻轻松松秒杀野路子打几十年的人。如果跟着业余的人做事，一定是误人子弟，一辈子不会有长进的。 第二个例子，我有一个外国客户，现在在Google, 合作了很多年，现在我们成了非常好的朋友，人非常帅气， 相信我的很多同事都知道，8年前他们给客户的报价是我们5倍左右，刚开始我一直认为是外国人对中国程序员的歧视，所以认为我们就应该低，直到有一次他和我一起编码解决一个项目问题，他做事的质量和效率让我震惊，有一个小的东西要做，当时让我们一个还算高级的程序员做，我们这个高级程序员评估了2个礼拜，我们这个程序员第二天才刚搭建好环境，估计他觉得慢了，不好意思说，就说他们的客户希望这几天就要要，他说我们来不及了，然后晚上我俩吃完饭，喝完酒，他说Jack, 我们去酒店一起试试做做这个小项目吧，然后我们就拿了两瓶啤酒，一起写这个项目，几个小时之后，我们高级程序员需要2个礼拜的东西，几个小时边喝酒边完成了，然后我被深深的震撼了，我要说人家效率是我们的10倍一点不夸张，人家的报价才是我们的5倍，人家还觉得我们占便宜了呢？ 是我们很差吗？不是的，我自己很多时候也是一些程序员3，4倍的效率（根据项目完成的时间计算)，但是报价连2倍都不到。 为什么有那么大的差距呢？我想说是因为专业的程度，除了写代码的速度，做事的方式，找问题，解决问题的方法等等就是有那么大的差距，很多人代码出问题的时候，需要把程序跑起来，设置断点，一个个试，人家早就用单元测试自动发现问题了, 这些人还一直沉醉在自己的这个状态中。 第三个例子，我见到了另一个国外的程序员，有幸他举家在西安待了半年，让我们两家成为了好朋友，刚和我们团队一起工作的时候，有很多我们会的东西他不会，我们还觉得有点优势，我还给他讲一些东西，很多时候讨论的时候，我们还能占一些主导，但是半年后，几乎没有我们会的他不会了，有过了两年，人家就可以自己写框架了，最近他自己成立个个人咨询公司，正在服务一个客户，报价已经是我们目前这边报价的3倍了，如果说人家为何成长的为何如此之快，我还是要说人家用的是专业的训练方法。而我们还在到处找免费的东西，天天在网上看业余的人士胡扯。 从上面你就可以看到，专业的训练用更少的时间达到了效果，然后在收入上有了很大的区别。 今天就到此为止，明天我继续聊聊专业和业余的区别，为什么认识到专业是如此重要，以及为什么我们业余。","link":"/2019/02/12/personaldev-2019-02-12-professional-and-no-professional/"},{"title":"为什么要敬畏专业？","text":"再次强调，认识到很多东西想变得专业绝非一日之功，会帮助我们在工作、学习以及子女教育上规避掉很多弯路。 我们都知道中国制造很厉害，但是很多核心技术，很多软的东西都提不起来，电脑操作系统不管是Windows, Linux和MacOS都是别人的，手机操作系统Android和iOS同样是别人的。我相信我们做不出这些东西，不是我们不够聪明，是因为除了我们总想找条捷径，不愿投入以外，还有很多人缺乏对专业的东西的敬畏，比如，我们一会儿说我们有雷布斯，一会儿说自己是罗布斯。就拿BATJ（百度、阿里巴巴、腾讯、京东)，以及一些国内IT的一些大公司来说，微软、Google、苹果等这些公司离了他们几乎没多大影响，但是BATJ没有微软、Google、苹果等产品还真不行。 为什么差别如此之大，就是对专业的态度上，我们弄不弄就说自己是第一，弄不弄就是乔布斯的接班人，拿某锤手机来说，我承认有很多自己的改进，用户体验上有很多优秀的地方，但是刚入行就老说自己东半球第一，每次我都以为是东方不败，显然对手机行业的了解是业余的，迟早会付出代价的。任何行业不了解的时候，一定要向专业的人学习，对这个行业以及行业的前辈要有基本的敬畏。那些说：“没吃过猪肉，还没见过猪走吗？” 显然就是胡说，你没吃过猪肉，你怎么知道是什么味道呢？ 不相信专业的人，通常过度自负，觉得什么东西都可以完全自己搞，最后要么跟守株待兔一样，要么像瞎猫一样，举几个涉及到工作、学习、子女教育、生病等例子： 工作，就拿我所在的软件行业，一些客户，你报个价格，他觉得这么简单这么贵？我自己回去找几个人来搞，这就是不敬重权威，觉得这东西就像去超市买个东西一样，刚毕业那几年，很多企业搞ERP，就是自己随便找几个人就觉得可以搞定，最后ERP变成了 （咦？哦？屁？) 学习一样，很多人觉得自学能力强，我承认靠刻苦的自学，肯定也可以不错，因为有很多人根本就不学习，但是要更好，要做到行业里的前20%, 想成为大师，如果我们相信专业，我们就需要向专业人士学习，比如和专业人士一起工作， 购买专业人士的教程，买书也是向专业人士学习，可惜很多人不愿意花几十块钱，宁愿花几十天在网上瞎找资料，更可笑的还在用百度查技术资料。 子女教育，很多人认为也是很简单的事，大师的书也不看，老师的话也不听、比自己牛的人观点也不停、自己也不成长， 我说的难听一点，那些觉得教育小孩儿自己无师自通的，也就是自己小孩儿幼儿园的水平，只是因为多活了几年，能比小孩儿多听懂几句话而已，如果你孩子将来还可以，那并不是你教育多成功，而是他后天付出了巨大的努力并且不能像父母一样的见识，另外，尤其很多孩子的父母的父母，一弄就说你不也长大了吗？我想说，现在都啥年代了，活着，像猪一样的活着，早都不是一个问题了。子女教育是个大话题，以后也是我想重点聊的，子女教育向来不是一个人的事，就算我和你自己说的很有道理，保持学习，也不一定我们的子女一定可以成功，但是可以保证的是，比我们不学习教育出来的孩子更成功，我为啥认为认识到专业性很重要，也是因为我也一样之前没认识到，吃了很大的亏，子女教育我就是小学生。 生病治疗，我们很多人不相信专业，吃了很大的亏，很多人盲目相信一些所谓的“中医”，生病不吃药或者弄些所谓的安慰剂来吃，不相信专业的科学，我们要相信，大学医学院，实验室，那么多医药企业的研发团队，不太可能某个人没有经过正规训练的，就随随便便能治疗各种疑难杂症，我觉得相信这些的人，就等于相信科学家，个大学医学院精心挑选的人，医药研发团队的是傻逼，相信大街上有一个巨大的低垂的果实没有一个人看见，碰巧让他看见了。 所以，不管是谁生病，相信我，去医院找专业的医生是唯一正确的选择，自己网上瞎看，瞎琢磨，这药不能吃，那药不能吃，最终都会耽误事。 看来这个问题如此重要，今天又聊不完了，下篇我们继续聊聊为什么专业的人是那么的专业，我们需要注意哪些可以变得专业。 坏了的钟表，一天时间也能对两次，所以做事情要学会衡量是不是这次是瞎猫碰到了死耗子。 最后，如果你觉得不错，麻烦点击好看，并转发到朋友圈，让人知道，你的三观很正。","link":"/2019/02/14/personaldev-2019-02-14-why-we-should-respect-professional/"},{"title":"如何做到专业","text":"认识到专业的重要性，然后保持对任何能做到专业的事和人的敬畏，是我们能把事情做到专业的一个重要条件，除此之外，我们要尤其注意一下几点。 刻意练习很多行业都需要长时间的刻意练习，大家都直到的10000小时定理，就是任何一个行业要想有所建树，都需要投入至少10000小时，当然，这10000个小时，还必须刻意的联系，比如我们学钢琴，我们开始肯定练简单的指法，然后练习简单的音阶，最后才从一级慢慢练到十级，循序渐进的长期练习。 系统完整的专业知识我学车的时候，给我安排了一个业余教练，自认为牛逼，不按照人家驾校的体系给我教，还说的头头是道，他的理论是你最终就是要在路上开的，所以一开始你就要上路练习，由于我不会开车不了解，就觉得他说的很有道理，他带着我演示了一段路，然后由于天气热，他就在下面树下坐着，让我自己开，然后就往前开，最后碰到一个人行道，有人我就慌了，赶紧左打方向掉头，可是我肯本就没想到踩刹车，还好我也不知道踩油门，车子是怠速，然后我向左边打满了，发现打不动了，车子还没调过来，我就向把方向盘再往回打，这样我刻意往左再打一圈，可是当我往右打的时候，车子又往右偏的，随后车就撞到了路边的道牙子，还好人没事。会开车的人现在肯定觉得很可笑，但是这就看到了这个教练缺乏完整的教学体系知识。这个很多农村的人买个车找个大沙滩来练，最后一上高速，付出了生命的代价，这就是没有系统完整的知识，开车可不是学会直着往前开就可以了，侧方停车，倒车入库，会车，各种交通常识，安全意识，突发情况都需要知道怎么处理 持续稳定的把事情做正确专业的人，就是你交给他一件事，成了，又交给他一件事，他又成了。不专业的人只是偶尔把事情做对，这没什么了不起，因为坏了的钟表一天都能对两次。我们单位乒乓球比赛，如果只比一个球，我估计大部分人都有机会拿冠军。我用人的时候，一般不会看这个人做这件事最高分有多高，我更看重这个人最低分有多高，同样一个事情，一个人一次100分，一次20分，另一个人一次80分，一次70分的人，显然我会考虑后者。 专业就是对事不对人事都是人做的，很多时候，我们一件事情没有好的结果的原因是我们过于考虑人，而忽略这个事情本来应有的正确方式。我曾经多次考虑让一些人在公司承担更大的责任，最终效果不好，有些时候，不是他不知道这个事情怎么做，而是他觉得这个事情不好意思说，比如团队某个人进度太慢了，他总感觉不好说，某个人质量有问题，非很大劲，想到了一个非常委婉的说法，最后别人还没有Get到，我认为完全没必要，就是不要过多的考虑这些东西，事情该怎么样就怎么样，如果由于我们帮助另外一个更职业，更专业而得罪了所谓的朋友，我觉得这样的朋友是不值得交的，迟早会把你带到坑里。同样的，如果我们没让别人明白问题所在，那对那个人也没有任何帮助，一样是损失。比如，如果你承诺明天下班之前把这个东西完成，那么就是明天下午。 持续改进专业的人，从来不会呆在原地，他们不光是把事情完成，而是总是在想有没有更好的方法。有人又要说了，那这个不是没有尽头吗？我举个我做项目的例子，和我合作过的程序员，经常会听到我一句话： ”这个地方是还可以改进的，比如XXX, XXX, 但是当前的时间和成本预算，我们刻意考虑放到下一个版本里“。 每次，我一定会去想一遍有没有更好的方案，如果找到，目前的需求和时间上看要不要用最好的方案。这就是持续改进，软件开发里面的持续重构就是做这件事的。比如财务给一堆数据的时候，能不能先给个汇总数字，然后针对这个汇总数字你的想法。而不是简简单单的丢一堆数据，还得领导自己去找去算。我们和别人沟通的时候，有没有不断的去想让对方话更少的时间来理解我们表达的东西，让别人的为这件事所化的时间走向极限，无限靠近0？ 控制好情绪专业的人做事情，不会因为心情不好，就对所做的事情大打折扣。因为吵了一架，因为路上遇到了糟心事，因为加人生病等而没法专心做事，如果这样，没人敢让这样的人做事情，因为让别人冒着巨大的不可控的风险陪你玩。","link":"/2019/02/14/personaldev-2019-02-15-how-to-be-professional/"},{"title":"当你是个锤子","text":"当你只有一把锤子，那么你看所有的一切都是钉子。 史蒂芬.柯唯 在《高效能人士的七个习惯》里举过一个例子，他拿出下面一张卡片。 如果你是一位男士，你可能看到下面的图片是一个漂亮的大美女，卷发，带着黑色的项链，露出长长的脖子一直向下，穿着一件时髦漂亮的羽毛上衣。 但是我告诉你他是一个伤心的老太太，一点都不好看，你是不是觉得不可思议？ 那么请仔细看下面的图，如果你刚开始认为是个老太太，那么请找出美女的视角，如果你刚开始认为是美女，就请找出伤心的老太太的视角。 如果你没有找出来，我告诉你一个技巧，首先如果你看到的是美女的耳朵，就换成是老太太的眼睛，如果你看到是美女的下巴，就换成是老太太的大鼻子，美女的项链换成老太太的嘴巴，美女的白白的脖子请换成老太太的下巴。（如果你还没看出来, 请使劲多看几遍 ! 当然，我这里并不是要和你完捉迷藏，而是要说我们经常用自己的第一印象或者自己熟悉的方式来理解一个事情，用我们已熟悉的方法往所有的新问题上用。而没有深入的想有没有更好的方法。 如果我们有一把锤子，然后去找钉子，那么就是发挥特长，但是我们很多人的问题就是只有一把锤子，那么觉得这个世界全都是钉子。 当一个家长，把孩子打一顿，就完成了作业，这个就是他的锤子，很可能以后孩子所有的问题都变成了钉子。 当一个老师，用一个方法教成功一个学生的时候，这就是他的锤子，就可能一直用这个方法对所有的学生，那么就忽略了因材施教。 当一个医生，给病人治病，比如癌症，就把患癌的地方切掉，而且最大限度的切掉的时候，我们医生就只有一把锤子，那么所有的癌症对他就是钉子（好在现在已经有很多新的方式了，大家可以看看浙江大学生命科学院教授王立铭《众病之王的解决方案》）。 当我们很多人，甚至整个社会缺乏创新的时候，我们就要想想是否我们整个家庭教育，学校教育和社会教育把人变成了一个锤子。 人们总是习惯用自己最熟悉的方式去解决问题而不理会这种方式是否合适。 我举个我工作例子来说: 我记得最早的时候，我做项目的时候用了三层架构，然后公司的人就所有的项目一直三层架构，显然不是所有的都这么适合的，后来我又提倡领域驱动架构，很多人就啥项目都要领域驱动。 我在公司推行过SCRUM, 有很多人啥项目，啥客户都要严格的SCRUM, 我在公司里推过GitFlow, 那么很多人啥项目都要GitFlow, 而其实我认为最好的分支管理是一个主干分支，只不过我们很多条件没达到而难以实施。 所以，我们不要限于你所见的第一印象和知识，需要更深的想几步，你看到的是不是人家在当时的场景，当时的环境，当时的各种约束条件选择出来的一个当时最优的方案，那么我们显然不能把他当作终级解决任何场景，任何项目的锤子。 当你以为我要的是一个钻子，其实我要的是一个洞，而根本不关心是不是用钻子钻的洞，当你看到用钻子可以钻一个洞的时候，我其实那个洞是用来钉个钉子挂东西，其实我们可能连洞都不需要，粘个挂钩就可以了。 我们一些程序员看架构师在一个项目里用了一个架构时，觉得学到了大招，然后啥项目都往上套，我们要想想人家为什么用这个架构。 也有不少人，老是觉得其它人傻逼，这么简单的东西没有想到，但是人家为什么不这么做才更值得我们思考，所以当你看到别人处理一个钉子，没有用锤子的时候，我们要知道人家可不是只有一个锤子。 最后，希望我们大家不要有锤子思维，凡事多想想为什么，有没有更好的方法，除了过去的经验，还有没有更好的方式，不要老停在过去的经验，这个世界变化太快，很多东西过去的经验已经不灵了。只有这样，我们才不会”杀鸡用牛刀“， 认为全世界都是钉子。","link":"/2019/02/16/personaldev-2019-02-16-when-you-are-a-hammer/"},{"title":"管理沉思录系列(一):开篇","text":"感谢公司的这个平台，让我这个毛头小子，不知天高地厚的人做了几年事业部负责人，然后又从2011年开始作为西安第一分公司的负责人至今。虽然分公司人员并不多，但是依然经历了很多事，才有了许多的思考和实践！ 为何一直没有写管理相关的文章我其实是一个很喜欢思考的人，对团队管理，公司建设等相关的东西很感兴趣，但是一直没敢记录一些相关的想法，主要有一下几个原因： 害怕得罪人管理人员有几类： “全是假话，没有真话”—我很讨厌这种人 “假话全不说，真话不全说”–有一定修养，但不愿得罪人，算是好的管理人员 “假话全不说，真话全都说”— 我就是这种人 我就是上面的第三种人，我这个人比较简单，喜欢有一说一，所以很多时候说话的时候不分场合，喜欢说真话，所以容易得罪人。而任何管理的方法和认识，很多时候很难照顾到所有人，很难和很多人达成一致，而又的时候，我说的一些管理的方法和思考，正好和有些人的冲突，那么别人就会觉得我是公开反对。 管理经验不足，不敢分享想法由于只是分公司的负责人，而且人并不多，相比那些“大领导”，我的管理经验算个毛？对自己一些管理的思考缺乏自信。 害怕流失员工我的一些管理的理念，可能别的人看了，有的人表示赞同，有的人嗤之以鼻，最多是关掉网页罢了，但是假如我单位自己员工看了，他和自己的领导理念不一致怎么办？我说的那些人不认同怎么办？那么是不是这些人会流失？流失了项目怎么办？ 害怕员工误解比如我之前写过加班有罪, 当我们偶尔需要加班的时候，很多人就会误解，会觉得我言行不一致，觉得我自己打脸了，很多人喜欢看别人打脸，但是我一直认为领导要敢于打脸，不要该打脸的时候硬撑着，随后我又不得不写一篇当我谈 “加班有罪” 我在谈什么？, 所以很多时候，一篇文章很难把一件事情说的通透，就拿加班这件事，我们认同加班有罪，但是我们如何能够做到不加班，恰恰需要大家的共同努力。（注：我们基本不加班，但是不代表着零加班，所有的人6点整就走人, 所有人都看着表走的公司，你真的敢去吗？) 害怕得罪领导如果领导看了，觉得我的很多想法不对，和领导的想法不一致怎么办？ 文章其实是一种交流和信息的流通，我觉得很多管理人员不愿分享自己的管理想法，应该也有我上面的几个担忧吧。 为何我现在要分享一些自己的管理想法和心得一个害怕得罪人的领导不是好领导我觉得，作为公司的管理人员，我们需要首先需要考虑公司的员工，考虑员工的发展，那么公司发展好了，公司文化建设好了，才能让员工发展有一定的基石。从管理的角度思考，当公司多余10个人时，很难所有人对所有的事情都有一致的认识，必然有个别人的一些认识，个人素质等与整体不一致，那么作为管理人员，必须兼顾大部分的想法，让大部分人认可公司的价值和文化，那么一些管理的方法，制度等等必然会得罪一些人，如果我们害怕去得罪人而选择很多中庸的做法，那么反过来，害得还是大部分员工。 分享管理的想法和经验可以提高自己的管理能力通过分享自己的想法，会有以下一些好处: 会对自己的一些想法进行总结。 通过总结，会对自己的想法进行梳理，同时还可以验证自己的想法。 可以看到自己的成长，对事情认识的提高，很多年以后，也许觉得自己当时的想法是什么样，为什么那么幼稚？ 如果有有兴趣的人，对你的观点进行讨论，必然会激发出一些新的思考和认识。 so, why not share your thoughts? 和员工交流我一直提倡员工与自己多沟通，有什么想法可以多交流，现在的交流方式已经非常发达，邮件，电话，微信，会议室一对一，活动等。我也努力创造各种交流的机会，但是中国人尤其是IT人员，很不善于沟通，也非常羞涩于和你交流想法，这让沟通的效果很不理想。由于对很多东西的误解和不理解或者了解，很多中国的员工会在离职的时候才表达自己的想法，最终让自己和公司都遭受不必要的损失。所以，通过写一些文章，员工可以看到自己领导对事情的认知，以及做决定背后的原因。 小公司也有很多经验，“小而美”也很难之前一直觉得分公司是个小公司，但是这几年，尤其是今年经历的一些事，我发现小公司其实很难管理，有些事情在大公司很好处理，比如，大公司大项目，50个人，走几个人不是任何问题，但是小公司，一个萝卜一个坑，走一个人你可能都头疼，类似的事情很多。 另外，小公司的数量很多，而且也会越来越多，依据“长尾理论”，这个是很正常的，即使是大公司，里面也有部分，部门里也有团队，其实我这里遇到的问题，解决问题的方法，他们都能用的上。 “小而美” 是趋势，能做到“小而美”，很难，做好了，何尝不是能力的体现呢？ 让其它人理解你做的一些决定在一个公司，我们肯定要和很多人，甚至是很多部门打交道，那么我们有的时候把自己做的一件事再三解释，不如通过文章传播一下自己的想法，这么做的原因，这样可以节省不少时间，同时也可以争取到相关人员或者领导的理解。","link":"/2016/06/10/management-2016-06-10-management-thinking-introduction/"},{"title":"如何提高元认知","text":"思考是学习的一部分，如果你不思考你正在学习的是什么，那么你就没在学习。 元认知，在中国很早就有很多大师做的很好，所有的思想家都有很好的元认知的能力，比如孔子的“三省吾身”。 提高元认知的工具有很多，今天主要说一点简单的方法，让我们可以提高我们的元认知。 我们做事情的时候，需要问自己的一些问题并回答。 事前 我们之前有没有做过类似的事情？ 我们要达到什么目标？ 我们做的事情优先级是什么？ 事中 我做的方向对吗？ 是在正常轨道上吗？ 按现在的进度可以达到目标吗？ 遇到困难的时候，有谁可以帮我吗？ 事后 哪些我们做的比较好？ 哪些我们还可以提高？ 另外，我们要经常反思。 哪些是我们知道的？ 哪些是我们不知道的？ 哪些我们已经知道我们知道？ 哪些我们还不知道我们知道？ 元认知除了可以多提上面的一些问题之外，我们还需要锻炼元认知的效率，比如如何排除身体外部和内部的噪音，从而可以进行深度思考，可以进行thinking of thinking, 外部噪音比较容易，我们可以找一个比较安静的房间，带上防噪耳机，但是内心深处的噪音比较难排除，现在已经有很多的证实有效的方法，比如打坐、冥想和瑜伽。","link":"/2019/02/18/personaldev-2019-02-18-improve-yuanrenzhi/"},{"title":"元认知，对认知的认知","text":"我们通过做事，学习来获取知识，我们对周围事情、环境以及人的认知给我们带来了喜怒哀乐。 我们事情没有做好，学习东西学不进去，人际关系没处理好，是我们认知不够，但是我们有没有想过为什么我们认知不够呢？ 我们很愤怒，我们的认知可能是来自于别人的某件事情，但是我们有没有想过我们自己的大脑为什么会产生愤怒，我们是否可以让我们的大脑不产生这种情绪呢？ 今天跟大家分享一个知识，叫元认知。 元认知，又称反省认知、监控认知、超认知、反审认知等，是指人对自己的认知过程的认知。学习者可以通过元认知来了解、检验、评估和调整自己的认知活动。一般认为，元认知可以由元认知知识、元认知体验和元认知监控三部分组成。 元认知包括元认知知识和元认知控制。 元认知的实质是对认知活动的自我意识和自我调节。 学习如何学习 最容易理解的元认知的例子就是“学习如何学习”，我们中国的教育体系从小缺乏这种元认知教育，我们大部分学生被灌输知识，强调学习，强调分数，缺少这种元认知，外面很多的培[瞎]训[扯]都没有帮助我们自己加强元认知的学习（也就是对元认知的认知）。所以我直到毕业十几年后才开始注意到这些问题，比如看到 《如何阅读一本书》才知道我们原来根本没有意识到我们一直在阅读，却没想过阅读一本如何阅读的书。 自己既是观察者，又是被观察者 我们一直用大脑来思考，但是我们却很少思考我们的大脑，比如思考如何让我们更有效的思考，我们要学会把大脑当作一个被思考的对象，那么我们就会考虑很多，比如让我们大脑更健康，适当休息等等，更多对大脑进行科学的认知，比如大脑随着我们一生其实都有物理的变化。可喜的是现在有一些《最强大脑》的节目，让我们认知到大脑的潜力，但可悲的是大部分看完最强大脑后觉得自己是傻逼。希望这个节目能够多普及一些科学和训练的方法，让大家直到自己不是傻逼，通过学习和刻意练习是可以达到的。 元认知在很多领域可以应用 在一些领域也有应用元的概念，比如在我做的软件领域，元编程也是一种，可以理解为“程序编写程序”，反射就是常用的一种元编程技术，在制造领域“机器控制机器”已经很常见了。 在生活中，也又很多可以应用的地方，生活很艰难，我们也可以“自己安慰自己”。 最后，希望我们都思考一下元认知，想想如何提高我们自己的元认知能力，思考一下如何思考，学习一下如何学习，后面我也会继续学习和分享元认知的知识，和大家一起提高我们的认知，欢迎大家关注和分享我的公众号，让我们一起共同成长。 扫码关注公众号","link":"/2019/02/17/personaldev-2019-02-17-yuanrenzhi/"},{"title":"穷人最好的投资是什么？","text":"我这里说的穷人相对富人而言，不是指你穷的没饭吃，而是指你还没有财务自由，还需要拼命挣钱的那些人，就和我一样。 穷人最好的投资是什么？ 穷人最好的投资就是投资自己，穷人最好的投资就是投资自己，穷人最好的投资就是投资自己！ 重要得事情说三遍。 这个观点是我认为的，不一定准确，不然我可能早就变成有钱人了是吧？但是你也别急着否定，谁知道将来会不会呢？ 只要生命不止，我们的投资就没结束。 为什么最好的投资是自己，首先穷人没钱，做不了大投资。到目前为止，我还没找到不投资自己，穷人有几个可以空手套白狼的，至少这样的几率很低。 投资股票？ 穷人输不起。 投资基金？ 小钱赚了赚不了多少，遇到股市大跌，基金赔个50%也不是不可能，而且股票和基金，有钱人玩的都是长线，你有钱抗吗？ 另外，我给你算个帐，2个毕业生，毕业的时候都是5000的薪水，一个投资自己的人，3年后工资涨到一万是没有任何问题的。但是一个人拿着5000块来投资，除了生活支出，每个月只能拿出3000块来投资，一年36000块，就算年初把36000全部给你，你全部投资进去，一年最多10%的收益（10%的收益基本上是华尔街精英们投资里做的比较好的了）。你一年的收益不到1万，但是想想我们那位工资涨到1万的人，3年后，每年的收入增长至少是6万， 而且我们炒股的那个人，由于没有好好工作，自己能力就慢慢丧失，有没有工作都不一定了。这是一个非常简单的数学题。 从上面可以看出另一个东西来。 就是一个是线性增长，一个是指数增长，在这个房子不断涨价的时代，线性增长是不够的。 那有人说，我买房子呢？ 哦，你要有钱全款买房子投资，那你就不是穷人了，好吧，你是富二代。有钱的人很多其实不买房子的，Facebook的小马不就是一直租房子吗？唐骏说他在上海把买房的钱拿去投资，他闭着眼睛都是10%的收益，然后在五星级酒店里租了个2000平米的房子，所以他说他住一个2000平米的房子，相当于1晚上还赚一万。哦，你还没有有钱到向唐骏一样吧。 那我们穷人如何投资自己呢？ 答案很简单，提升能力，提升自己的不可替代性，做一个对别人有用的人。 下面是一些方法，穷人可以花的起的。 1. 人穷就要多读书 自古就有，书中自有黄金屋，书中自由颜如玉。现在没有几个人穷到买不起书，书可以让我们持续学习到新东西，可以带我们去到买不起飞机票的地方。 2. 做钱的主人 做钱的主人，不要做钱的奴隶，什么意思，就是钱要花掉，投资在自己的成长，买本书都不愿意，就是做钱的奴隶, 钱全部放到银行，就是做钱的奴隶，你的钱一分不花，每年都在减少至少6%（通胀）。 3. 持续学习 穷人没钱，但是有时间，那么就要把时间用到刀刃上，持续的学习，只要能学到东西，钱少点都可以，因为现在多一点钱，不会让你能力，让你未来的收益指数增长，花钱请好的老师，花钱买好的课程。 4， 给自己买份保险 穷人最怕的是突如起来的生病，变故，那么买保险是避免自己掉入深渊的方法，我从来不讨厌保险，我自己也给自己买了保险，我只是不喜欢很多做保险的人，因为他们让人讨厌的卖保险的方式。 5. 投资健康 每年做个体检，适当运动，吃健康些，健康是投资自己里最好的投资，但是避免只投资自己健康，能力不投资，那么就变成行尸走肉了。 6. 尺有所长，寸有缩短 发挥自己的特长，学会说 “不”， 自己不擅长的，自己办不到的就不要答应。比如，如果你不想得罪人，但是又不想浪费时间，每年花点钱给别人。 7. 花钱找一个教练 从你周围找一个能力比你强的人，让他多给你指导，多向人家虚心请教，请人家吃饭花不了你几个钱，比你强的人不在乎你的饭钱，成功的人都吃的很少，有的晚上都不吃饭。看重的就是你的诚意。那你周围实在没这样的人，那就多请教你的领导，多尊重你的领导，能当你领导的人，肯定比你强，你不用怀疑。领导怎么愿意帮你，那你就要做对公司有用的人，实在不行就多干活，不然还能咋地。 8. 离负面的人远点 离负面的人远点，离比你强的人讨厌的人远点，有的人朋友遍天下，完全没必要，因为你离负面的人越近，你就会变的越差，而且导致你离有用的人更远。负面的人大部分都是贪图小便宜，给点钱让他赶紧滚。 最后，总结一下： 读书，学习新技能，投资健康， 结交积极向上的人。 穷，不可怕。一辈子穷，才可怕。 投资自己，穷一阵子，不投资自己，穷一辈子。","link":"/2019/02/22/personaldev-2019-02-22-qiong-ren-tou-zi/"},{"title":"大学生如何写好简历","text":"最近有个亲戚的小孩儿想找工作，然后想让我指导一下简历，刚开始，我是觉得没有必要，我觉得简历形式不重要，能力很重要，不过后来我想想，还是需要一下指导的，因为如果“颜值”没过关，就没有机会让人家看到内涵，而且现在这个社会不再是酒香不怕巷子深了，大学生满地都是，凭什么一个单位愿意用你？那么简历无疑是大学生进入社会的第一道门坎。而且，我要是不提点建议，也显得自己不愿帮忙，那人家找我干吗呢？ 我自己还这没有太多写简历的经验，但是自工作以来面试的人却不少，我自己也换过几个工作，不过都比较幸运，每次换工作基本很快都找到了，第一个工作是国企，原因人家觉得我这个人踏实，一看就踏实（主要是穷，穿的像破烂)。 第二个工作，面试我的技术人员是一个女的，好像就没技术问题就入职的，后来才知道就不懂技术，搞得我明明可以靠技术，最后却靠了运气。 现在这个公司，一待10多年了，想想都是缘分，当时好像是没买到回西安的火车票，就在北京试试，一试就来了现在单位。一干就是10几年，所以，缘分很重要! 言归正传吧！ 先说一下我看到的简历几个明显问题。 照片用得是艺术照，容易让人感觉不正式，男的用艺术照干吗呢？女的用艺术照是要勾引人吗？照片，找工作请一定用正装图像照（证件照）。 中英文部分混杂，你是给中国人看，还是给外国人看？你就一份纯英文，一份纯中文就好。 政治面貌写的是团员，强调一下自己没入党，很光荣吗？我当年还是少先队员呢。 邮箱不要用QQ, 不是说QQ邮箱不好，QQ邮箱很好用，但是用来找工作用，哦，就是不好。不信你就用，一个原因是工作中很少人用QQ邮箱, 其次是QQ邮箱被很多邮箱服务器当作垃圾邮件，因为现在很多二货都有QQ, 所有二货们都有QQ邮箱，但是你看见有几个国内的二货能有Gmail的邮箱，所以你要是用Gmail邮箱找技术岗位的话，那很加分的，因为证明你能获取到别人看不到的信息。实在不行，就用outlook好吧？ 列表前面的图案不统一，统一很重要，不是找时尚的工作，不需要五颜六色，已经不是小孩了，别再萌萌哒，学猫叫，要么列表不用图案，要用整个简历都用一个，我还没见过哪个正式场合的人穿西装上身黑，下身蓝的。 爱好特长，全是用的标识符图案，容易让人感觉智商受侮辱了，因为我真的有几个不认识是个啥意思，就直接用文字就好嘛。 你看，单单单单的一个简历，要挑都能挑出这些问题。 那么大学生简历应该要注意哪些呢？ 企业招大学生，最看重的不是你有多少经验，是你的态度，你的潜力或者可塑性，你的学习能力，你的专业里面的知识，你的兴趣爱好。 所以，整个简历要能够快速，准确的展示上面的那些东西。快速，就是让看简历的人花最少的时间Get到你的能力，准确就是简历内容要真实。 不要尝试和面试官斗智力，你在他们面前就是一个小白，真诚就是最好的套路。 下面是我推荐的简历方式。从上到下，基本一页纸就够了。 基本信息 姓名 性别 年龄（可有可无) 籍贯 联系电话 联系邮箱 正装微微笑头像照 （长的丑的就不要贴了，不要过于自信） 教育背景 同专业的，就写最高的一个学历就可以 不同专业的，都写上，比如本科一个专业，研究生另一个专业 自我评价 就是把自己的优点列出来，如果你的优点真的都写不下了，那就写点不重要的缺点。就是描述积极向上的态度，好的性格。 实习经历 按你期望找的岗位的相关性汇总，不要按年限顺序罗列，要写自己实习的每个工作的角色，工作内容，以及解决了那些问题，学习到了什么东西等。 有些人说，上面东西太多了，可能一页纸写不下，我想说那可能你会的东西太多了，鬼才相信呢？ 祝各位大学生都能找到心仪的工作！","link":"/2019/02/21/personaldev-2019-02-21-da-xue-sheng-xie-jian-li/"},{"title":"为何无知的人认为自己聪明？？","text":"今天给大家说一下达克效应以及自己的理解，然后看看我们处在上图重的哪个阶段，如果看不懂也没关系，往下看文章，最后附上一张中文的。 一个实验里，杜宁与克鲁格先是找了一群康奈尔的在校学生，然后对他们的“幽默”、“语法”、“逻辑”等几项能力进行了测试。之后，再让参试者进行自我评估。结果是，成绩最差的那些学生对自我水平的认知偏差最大。其成绩处于12%百分比等级（即意味着说，他们的成绩处于末尾12%的水平——有88%的人的成绩比他们更高）的应试者认为自己的百分比等级至少应该是67%。与此同时，那些能力更强者却可能反过来低估自己的能力。 这种“越差越牛屄，越强越谦虚”的现象，之后就干脆被称为“杜宁-克鲁格效应” 。 另外一个经常被引用的瓦伯格湖效应的例子是：大约80%的司机认为自己的驾驶水平处于平均水平之上，这显然在数学上很简单的看出是不可能的。 这就说明，当一个人认知能力比较低的时候，越觉得自己厉害，这就是说无知的人最自信。越没本事的是越嚣张，越有能力的越低调。 无知的人不知道自己无知，所以自信心爆棚。 有知识的人越发知道自己的无知，学海无涯，所以都很谦虚。 所以，我们让一个人群的人自己给自己评价，自我定位基本上是不准确的，而由于专家类的人本身就少，所以整体基本是高估自己的。 那我们知道这个有什么用呢？ 莫做无谓争论 不要和无知的人浪费时间争论，如果知道他现在是在线上的哪个点，就很坦然，知道他现在可能蠢到极点了。 《庄子》的秋水篇，井蛙不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。 意思就是，不要和井里的青蛙谈大海，它眼中的天地只有井口那么大，和夏天生夏天死的虫子，不要谈论关于冰雪的事情，因为它的眼界有限，见不到冬天；同样的，和见识浅陋的人，不必和他们谈论道，因为他们的学识有限。 进步，不要骄傲无知 有不少东西的学习，我们初始阶段进步的比较快，然后容易让我们觉得自己天下无敌，就像很多从师傅那里学了一招，就觉得天下无敌，甚至眼里没有师长。其实就像上面的哪个曲线一样，能力增加了一点，自信心却到了山顶。所以，如果任何时候有进步了，都需要审视一下自己在哪里？ 和高手一起，早点发现自己的无知 从上面那个曲线，可以看到，当我们学到或者见到高手越来越多的时候，我们就没有那么自信了，这个过程一直持续到自信心跌倒谷底，所以很多时候，我们如果带团队的时候，我们要让他们看到井底之外的天，不然大家还在那里意淫，当我们跌倒谷底的时候，那是一件好事情，证明我们以后都是在上升的。如果我们带孩子也一样，培养出自信后，要多让他见见世面，从此知道要学的东西还很多，学画画，那么多看看大师的作品，学钢琴，多听听音乐会等。 下面是一张类似中文图，值得大家仔细看几分钟。 你现在在哪个阶段？ 哎，我是感觉刚刚过了绝望之谷。路漫漫其修远兮，吾将上下而求索。","link":"/2019/02/24/personaldev-2019-02-24-why-idiot-think-himself-smart/"},{"title":"为什么买东西要买贵的？","text":"我买过很多便宜的东西，也买过一些相对较贵的东西，我得出了一个很重要的经验，就是买东西在条件可以允许的情况下，就买贵的，我说一下原因。 贵的东西质量好 我之前买锅，总以为一个锅嘛，都是铁而已，100块钱的就可以了，但是直到后来我买了一个不错的不粘锅，我说的不是100块的不粘锅，是500块以上的不粘锅，然后才发现之前很多菜炒不好，是锅的原因。算算我吃过多少次炒糊的菜，就知道我买个贵的锅是有多值。 跑步鞋，刚开始我100多块的，后来买3，4百块的，但是膝盖和脚经常受伤， 后来一狠心买了个将近2000多的跑步鞋，然后就很少受伤，好的跑步鞋踩在地上的缓冲相当好。 加湿器，我原来买那种看着“冒烟”的几十块钱，后来发现不行，就觉得反正便宜多买几个，后来发现要么地上都是水，要么有地上有很多白色粉末，直到我买了空气净化器，放到加湿器旁边，发现空气净化器呼呼的叫，后来查了一下，原来那种加湿器如果不用纯净水的话，基本上是人造雾霾，所以，我就买了个将近2000块的加湿器，冷蒸发，大家可以去看下这个技术，然后加湿器就非常低调的在那里默默的工作，不给你带来一丝的纷扰。 空气净化器，原来买的某米的空气净化器，雾霾大的时候开窗根本不管用，那么小，300CADR，空气进化速度太慢，后来我就买了一个800CADR的，基本上25平方米的房间5分钟就可以净化一遍。 我列的几个例子都是和健康有关的，大家不太注意的，我相信大家比我有钱的买过很多贵的东西，贵的质量好都是有感触的。 贵的东西体验好 我喜欢用苹果的产品，至少到目前为止，没有哪个厂商的整体用户体验比苹果产品好，你告诉我一个功能好没有意义，我用Macbook Air比较多，它很轻便，电池可以用10个小时，无需鼠标，基本不用关机，我需要的时候都是秒开。更别说Mac上的软件比PC上的好太多了。我也有一个2万的PC工作用，但是用了快两年，我一直觉得比不上我1万的Macbook Air. 苹果产品的集成体验太好了，我手机和电脑无缝集成，就是切换一些东西基本感觉不到切换的存在。我最近喜欢用的一个功能，就是在苹果手机上复制，在Macbook上直接粘贴。 贵的东西体验好，还有一个更重要的作用，就是我们可以学习到大量用户体验的东西，用了很多苹果上的软件，我就直到很多我的软件和产品应该怎么借鉴，好的东西，会提高我们对体验的标准。 贵的东西可以提高你的身份 这个不用质疑，比尔盖茨，马云穿的再烂都没事，但是我们一个普通人如果破破烂烂，你就会丢掉很多机会，很多个见你第一面就不会再有深入了解你的机会了。 拿女的来说，某些时候买贵的东西更安全，你开个兰博基尼，就算没有，你买个LV的包，走在街上，一般的流氓都不敢欺负你，很多流氓其实都是废物，也只敢欺负没钱的人。 贵的东西可以让你节省时间 有的时候，我需要打车，我就尽量打好一点的车，因为好一点的车，稍微贵一点，很好叫到，对我来说，时间我认为更重要，我多花10块钱，回家我可以早到半个小时，去见人我可以早到半个小时准备。更重要的，贵一点的也更安全，更舒适。 有一年春节，我去洗车，人很多，我就去了一个50块钱的地方，其它的地方35块，我去了，就我一个人，直接就洗了，中间来了一个人问了一下，人家说50，他和人家磨叽半天，洗车的坚持50，然后他就不洗了，开车走的时候他说了一句：“还真有傻逼在这洗呢？” 得亏我的智商高点，不然他估计欠抽了，因为原来他才是一个傻逼，便宜的地方不等一个小时，你根本不可能，我相当于用15块钱买了1个小时的时间，就算我挣钱能力差点，一个小时哪怕挣个50块钱，我是不是还赚了35？这点智商都没有，还好意思说别人傻逼，他在寒风凌厉的外面等一小时的时候，我早就回暖气房子里想干啥干啥。 所有能让你省时间的服务，都要毫不犹豫的购买。花钱省时间，毫不犹豫的延长了你的有意义的生命长度。 买贵的东西，好处有很多，上面只是一些很浅显的例子，我相信大家都买过很多贵的东西，然后觉得超值。 但是，记住我说的是买贵的东西，不一定是买最贵的东西，如果经济条件允许，就买最贵，如果不允许，就买和最贵的质量和功能都有90%相同或相似的。 比如，买车，手动挡就不用买了吧？又不是要搞比赛。省那个一万块，你肯定会后悔，因为你要累好多年。但是买一百多万的，那也没必要，我觉得如果是普通轿车不是越野的话，20多万的车，基本上具备了车的90%功能了，这就是买贵的，不买最贵的。 后面，我会再写一篇，哪些东西应该买便宜的，是不是觉得矛盾？ 小说《了不起的盖茨比》里说，检验一流智力的标准，就是看你能不能在头脑中同时存在两种相反的想法，而且还能维持正常行事的能力。","link":"/2019/02/23/personaldev-2019-02-23-why-we-should-buy-expensive-product/"},{"title":"人人都该懂点逻辑学","text":"老上访户 “99%以上精神有问题”的———-北京大学法学院副教授孙东东 “事实上，大数据得出的结论和我想象的差不多，喜欢去低端足疗店的人是最健康的。如果你常去足疗店可以让你少去医院，那么是不是你的健康保险也更低一点？”——–百度CEO李彦宏 上面的两个人都是高学历的人，但是都犯了明显的逻辑问题，可见我们中国的逻辑思维教育确实需要重视起来。 联合国教科文组织把逻辑列为7门基础学科中的第二门，仅次于数学，《大英百科全书》把它列为五门基础学科之一，足见其重要性。 遗憾的是，逻辑学在中国没有得到重视，导致很多中国人缺乏基本的逻辑常识，人们常常依靠最原始的习惯来思考，逻辑谬误无处不在。 生活中我们经常碰到一些人出现明显的逻辑问题。 比如，你行你上呀，这明显就是偷换概念的逻辑错误，我们现在讨论的是你，不是我呀，况且你会的东西，就一定我要回吗？ 美食家就必须会做饭吗？说一个程序不好用，我就必须要会写程序？开飞机的一定要会造飞机吗？ 男人没有一个是好东西，等于天底下的男人都不是好人=天底下的男人都是坏人=男人中没有好人=好人就不是男人=好人只能是女人。 所以这个意思的结论就是你不可能找到一个好男人。有这样逻辑思维的女人，估计是过不好这一生。 尤其是女的，太没有逻辑思维了，比如一起出去吃饭，你问她吃啥，她说随便，然后你点一个，她说不好吃，又点一个，她还不好吃。 相反，学学 BBC的纪录片《逻辑的乐趣》（The Joy of Logic）里的一个故事，看看三个逻辑学家如何逻辑思维的。 三个逻辑学家走进一个酒馆，侍者问：你们仨都需要啤酒吗？ 第一个逻辑学家一脸懵，咕哝到：“我不知道。” 第二个逻辑学家也说：“我不知道。” 第三个逻辑学家却笑着回答：“我们三个人都要喝酒。” 为什么第三个人会做出这样的回答？ 侍者是问 “你们仨都需要啤酒吗（Would all three of you like a beer）？”，关键词在于 all three（三个人都）。 若是第一个和第二个人不想喝酒，轮到他的时候，只需要说 “我不想喝酒” 就可以了。然而，前两个人都没有给出否定性的回答，只回答了“我不知道（I don’t know）”。 这就意味着前面两个人都想喝酒，在依次回答侍者问题时，被问到的他们不知道后面的人是否想喝。于是，他们只能回答 “我不知道” 。 而这个回答有两层寓意： 1、轮到我了，我想喝酒，所以我不能说 “我不想喝”； 2、我不知道后面的人是否想喝酒，所以我不能说“我们仨都想喝”； 轮到第三个人的时候，他明白了前面两人的意思，而他也正好想要喝酒，便做出了肯定的回复。 逻辑不是知识，逻辑不生产知识，它所做的是提供我们一套严谨的规则，用来组织和运用知识。 每个人有两种思维模式： 直觉思维： 遇到一个问题，基于给出答案，往往凭直觉做判断，反思和复盘时往往说不出决策背后的逻辑。 逻辑思维：利用科学的思维模式进行结构化思考，在全面分析问题的基础上，做出更有利于自己的决定。 我们大多数人习惯基于直觉思维做事，缺乏逻辑思维的刻意练习，这叫做思维懒惰。 思维懒惰常体现在很多方面： 相信权威 一弄，就是孔子说的，孔子说的一定时对的吗？我们的“两个凡是”给的教训还不够吗？我和别人讨论的时候，也经常听到这样的观点，他们会说，这个时斯坦福毕业的人说的，意思就是你不是斯坦福毕业的，斯坦福毕业的人比你强，所以你说的不对，斯坦福毕业的人说的都是对的，太荒谬了。 盲目相信权威，实际上很多时候时候扼杀了我们的思考和创新。 概念模糊 经常争论的时候，连概念都没搞清楚，就开始反对，实际上两个人说的根本就不是一件事，还有，就是自己就没搞清那是个什么意思。为什么？因为中国人自古就有个习惯，概念不讲清楚。 中国的哲学家极少下定义，儒家讲仁？什么是仁？众说纷纭。老庄讲道，什么是道？没有定义，“道可道，非常道”。所以每个人的理解都不一样。 范伟的的一个小品《卖车》中有一个脑筋急转弯题，问：“你家的狗为什么不生跳蚤？” 范伟回答说是因为讲卫生，而正确答案却是：“因为狗只能生狗，生不出别的玩意儿来！” 范伟说：“你说是出生的生啊！” 这个问题也是概念的问题，范伟的理解是“寄生”的生，高秀敏说的是“出生”的生，虽是同一个字，但是表达的却是两个不同的概念。 二元思维 我们看电影的时候，都以好人和坏人区分，好人就真的啥都好吗？坏人就坏透顶了吗？ 这就是简单的二元思维。 非黑即白思维，这种思维只看到了事物的相反的两面或两端，忽视了其他方面或两个极端之间的中间情况，而其他方面可能很多，中间情况也往往是最普遍的。 错误推理 比如，我今天说推荐个好的赚钱机会，建议买指数型股票基金，因为马上建国70周年，国家会刺激经济发展来为国庆生，但是赔了我概不负责，那就有朋友说了，你这个话自相矛盾。其实这个推理就有问题，我只是说这是一个赚钱的机会，并没有一定说会赚钱。 这种思维的错误就在于从别人的论述中推不出反驳者所理解的观点。 这些错误的思维，有不少，建议大家去看看一些逻辑思维的书。 后面我附上一个网上有意思的鸡蛋思维，这鸡蛋真难吃. A：这鸡蛋真难吃。 B：隔壁家那鸭蛋更难吃，你咋不说呢？ A：这鸡蛋真难吃。 B：有本事你下个好吃的蛋来。 A：这鸡蛋真难吃。 B：下蛋的是一只勤劳勇敢善良正直的鸡。 A：这鸡蛋真难吃。 B：比前年的蛋已经进步很多了。 A：这鸡蛋真难吃。 B：你就是吃这鸡蛋长大的，你有什么权力说这蛋不好吃？ A：这鸡蛋真难吃。 B：你这么说是什么居心什么目的？ A：这鸡蛋真难吃。 B：嫌难吃就别吃，滚去吃隔壁的鸭蛋吧。 A：这鸡蛋真难吃。 B：隔壁的鸡给了你多少钱? A：这鸡蛋真难吃。 B：再难吃也是自己家的鸡下的蛋，凭这个就不能说难吃。 吾爱吾师，吾更爱真理———–亚里士多德","link":"/2019/02/25/personaldev-2019-02-25-everyone-should-know-some-logic/"},{"title":"如何识别诈骗","text":"现在骗子太多，让人防不胜防，我自己就遭遇过几次诈骗，只有一次被骗成功，让我损失了50块，还有一次骗子差点成功，如果那次成功就会损失更多。 第一次是刚上大学那会儿，去西安火车站，当时的火车站完全不是现在这个样子，我横穿了一个马路，然后就被一个“警察”拦着，穿着“警察”的衣服（当时貌似好多地方有卖得），说我横穿马路，要罚款，我说多少钱，“警察”给我说100块，我说没有那么多，后来说80，80我也没有 （是真的没有），后来就以50块成交，他说我是学生就算了，最后还给我教育了一番。现在想想我自己是多么的可笑，只能说自己无知，骗子太猖狂。 第二次是我买机票去上海，我的机票信息被泄露了，而且我的朋友的信息也泄露了，然后出发前三个小时，有个电话打过来，说是某航空公司的，航班不能正常起飞，让我换另外一趟班机，那个声音跟航公公司的客服是一模一样，一模一样的专业，我由于定了上海的酒店，然后又订了到其它地方的火车以及酒店，如果飞不了，我的所有的订的东西都得退，而且客户是外国的，来一趟不容易，我很是着急，就问他最早的航班，然后他给我说了个航班，中间又沟通了一堆，意思就是让我先付钱，原来航班的费用给我退了，但是说那个退需要时间，至此，我都没发现是骗人的。 最后骗子暴露是因为我问了一下他这个飞机是哪个航站楼的，骗子给我说是1号航站楼，而我记得西安好像没有1号航站楼。此时我才开始怀疑，我就打了一下航空公司的电话，查了一下航班信息，没见任何迹象表明这个飞机起飞不了，骗子另一个失误的地方是，我问他新航班的时间，他只说比我这个晚10分钟，我们想想一般不管出发地还是目的地，因为各种原因不能起飞，那也不可能10分钟后就可以起飞了，天气不会好那么快吧。 第三个例子，更可怕，我去半一张手机卡，某通信公司主营业厅的人帮我办完后，说需要下载支付宝，手机绑定支付宝，然后这样才可以开通流量，我就表示怀疑，她说必须的，然后我就看他用我新开的卡，上到她的手机上，下载了一个支付宝，然后用我这个卡注册了一个支付宝账户。整个过程我就静静的看着，我看她还能搞什么鬼。 弄完后，我就找他理论这件事，我很清楚，如果需要试下流量直接浏览个网页不就可以了？下载支付宝，绑定手机卡，她搞什么鬼我不清楚，但是我知道他们这样肯定骗了不少的用户，好在我已经不是当年的小白，怎么也是在IT行业里混，这个解释完全说不通，我就找来了她们经理告诉他们，他们这样做是不对的，刚开始他们还继续糊弄，后来我说你们再糊弄我就要报案了，你们这是诈骗。后来那个经理怂了，给我一顿道歉，说以后办业务找她之类的，让加个微信，我说我从不加没有道德底线的人的微信，还后来，我也没时间纠缠，就警告他们以后不要这样骗人，尤其是骗那些啥都不懂老头老太太。 上面三个例子是亲身经历，我相信大家也都经历了不少，而且未来随着我们信息泄露的越多，我们就越防不胜防，很多人不信，我只是说没碰到高手，我就举个非常简单的例子，比如一个人拿到了你的所有信息，拿到了你家人的所有信息，然后给你不停的打电话，你会觉得烦，然后他不停的打，一直打到你关机。（我知道你说你有很多办法不关机，比如黑名单，但是我告诉你，骗子又的是方法让你关机), 现在你手机关机了，然后骗子打电话给你爸，说你出事了，让你爸汇两万块，你爸给你打电话发现打不通，如果骗子再PS两张你受伤的照片发给你爸，你爸估计就把钱汇出去了。（以上千万别模仿，我相信看到这个文章得都是好人） 我举这些例子，就是让大家看到骗子是多么的高明，我们一定要知道骗子得一些伎俩，最大化得防止受骗。 虽然骗子的手段千变万化，但是我们记住一些基本的原则，比如天下没有免费的午餐。 所有的诈骗都分为6个部分（伯纳·派顿. 逻辑学）： （1）劝诱。劝诱的工作通常交给下套人来做，他们的任务是让受害人进入圈套中。下套人会用各种方式取得你的信任，少数人会出示证件，但绝大多数是诉诸个人魅力与推销术。 （2）诱因。诱因是受害人遭到诈骗的主因。在典型的骗术中，诱因通常是快速致富，也可能是其他的好处，如性诱惑。有时诱因来自于助人，例如慈善募捐。当然在诈骗的例子里，慈善是假，钱进了骗子的口袋是真。 （3）“托儿”。绝大多数的骗局会雇用一个“托儿”，也就是第三人，这个人有时为配合行骗还会装笨，或者装作与双方没有任何利害关系，好诱使受害人上钩。在拍卖会上，假买家会哄抬价格。“托儿”也会让受害人知道，要赢得果壳游戏与三张牌赌局有多容易。想想当年晚会的魔术？ （4）调包。骗局里总会出现调包，也就是用假货来取代真品，例如受害人受害人以为自己买到了真的翡翠，其实是玻璃的。或者是受害人以为得到一枚2000年前的古董，其实却是昨天新做的，甚至上面用简体字写的 “大明王朝”制，但是就是有人受骗。 （5）压力。在调包前后，诈骗者会施压催促受害人进行交易，或让受害人无法谨慎交易。通常的做法是加以时间限制，不是说以后没机会，就是说有别的买主出了更高的价钱。这种“现在就做，动作要快，不要考虑”的压力，是诈骗集团常用的伎俩。 （6）迟延。这是最后一项重点，它的目的在于阻止受害人报警。迟延是诈骗计划的核心部分，主要分为两种类型：法律迟延与时间迟延。 a. 法律迟延：通常受害人不愿报案的原因，在于受害人本身也犯下了走私、伪造或赌博等罪行。如果行为没有明显违法，那么锁定的就是个人名誉，性诈骗就是这样。难道你想告诉警察或自己的妈妈，自己花钱找妓女，结果进了房间后被洗劫？ b. 时间迟延：有时候，时间会无限拖延下去，因为受害人不知道自己低价。 买进的钻石是赝品，他从未将假钻拿去估价。而他不拿去估价的原因，在于他买的是赃物，拿去估价会被揭穿。有时候，时间迟延是有限制的，如受害人无法在特定期间内将假的铀矿股票变现。时间迟延的目的，通常是要让诈骗集团能顺利脱身。 记住，大多数诈骗手法之所以能成功，在于受害人相信自己的野心、偏见或贪婪能因此被满足。所有的诈骗手法都是换汤不换药，全由以上这6个部分组成。因此，没有任何书籍能毫无遗漏地介绍各种诈骗。所以最好的做法，是训练自己辨识这6个部分，好辨认出诈骗。","link":"/2019/02/26/personaldev-2019-02-26-shi-bie-zha-pian/"},{"title":"如何走出舒适区","text":"上面这张图里，可以看到舒适区是一个小圈，里面你感觉简单、安全、合群、不害怕、平庸、无风险。 舒适区外面是一个大圈，一些你害怕做的事，是一些难做的事，是机会，也是风险，是一些你没做过得事情，是很多新事物， 是没有限制的梦想。 上一篇说过很多人愿意待到舒适区，但是时间长了，一旦外部或者内部环境变化，你就没有这个舒适区，为了避免我们某一天，从舒适区的18层楼高处直接坠落到底，那我们早点认清，提前一步步的离开舒适区就是我们必须要做的，现代社会，竞争无比激烈，你没有机会在舒适区里呆太久。 如果还有人怀疑离开舒适区的必要性的话，我们可以看下下面这张图。 （中文：那么，请再解释一下我为什么要离开我现在站的这个地方…) 那么如何做可以帮助我们离开舒适区呢？ 定义新目标，学习新事物，立几个Flag 普通人，很难先定义一个“先赚一个亿”的小目标，但是订个词汇量5000的目标是可以达到的吧？立Flag, 比如在朋友圈里Show出来，这样可以督促你完成。 有很多，比如如下： 比如学习你行业的新技术，新方法 学习一种乐器 学习写作 学习健身 学习做饭 学习画画 等等等等 以终为始，把目标分解，一次一小步(baby step), 你每次的一小步，最后都是迈出舒适区的一大步 增加有用信息输入 就是我前面说的，要知道自己不知道，比如多关注本行业的一些最新技术，这里强调有用信息的有用，什么是有用，不是在莫视频软件里看别人搞怪，而是多看看书、权威杂志，高手文章等，只有我们知道自己不知道，才能先看到舒适区外部的世界。 扩大社交圈 多了解自己行业里其他人都在干些什么？然后想想这些事自己现在是否可以干？不能的话怎么办？ 多看看其它行业的人都在做什么？人家行业的东西是否可以借鉴到我们的行业里来，乔布斯当年也还不是从保时捷的设计里吸取了大量灵感？ 迎接挑战，知难而上 要多去尝试一些你还不能100%确定完成的事情，遇到一些困难的时候，不要基于退缩，尤其在团队里要做勇挑重担的人。做打不死的小强，因为一切打不死你的，都会让你更坚强，但是不要去做那些明显够不着的虚幻的目标，比如要1年赚一个亿，如果能打死你的，你就是死了的小强。 多做事，少八卦，把生活节奏调快一点 天天唱《从前慢》就是要回到母体的舒适区里，这是再后退，看看你每天睡觉超过8小时的话，那基本就是过于舒适了。 任何单位，任何地方，如果你还在慢慢晃悠的做事，那就是舒适区呆太久了，早睡早起，但是也别谁太早了，我还听说很多人晚上8点多就睡觉了，早上8点多起来，我想说，你要不是个天才，你就是党和国家，或者你家人把你当猪养了。 醒醒吧，梦总是会醒的。 跟我走吧，现在就出发，梦已经醒来，心不在害怕。。。。。。","link":"/2019/02/27/personaldev-2019-02-27-how-to-leave-comfort-zone/"},{"title":"你在舒适区吗？","text":"之前我们谈DK效应的时候，有下面这张图，在我们到达愚昧山峰之前，我们很多人都是巨婴，不知道自己不知道。 那么我们知道自己不知道，我们就一定会开悟吗？不一定。 除了我之前谈到的，提高认知之外，我们许多人成长慢的一个原因，就是我们喜欢呆在舒适区(comfort zone), 在comfort zone里做着我们熟悉的事，说着我们熟悉的话，不用担心，不用着急，不用害怕。 但是，就像题图里说的”Life begins at the end of comfort zone”, 为什么？ 我们听过亚当夏娃的故事，他们一开始就在伊甸园，无忧无虑，但是由于智慧果的诱惑太大，他们走出了舒适区，然后就有了我们，说这个有点虚。 但是，从科学的角度也是如此，我们每个人来到世上之前，在妈妈肚子里不也是这样吗？然后从妈妈肚子出来的时候，就走出了人生第一个舒适区，所以出生的时候哇哇大哭。 但是，遗憾的是，我们做父母的，又再想尽一切办法把孩子往妈妈肚子里放。所以，我们很多人成长了巨婴。 很多农村放养的孩子也有出息，因为出生后父母没有给他们继续提供想妈妈肚子里一样的舒适区，从下就没有舒适区。 很多企业里就创造了这样的舒适区，美其名曰，人性化，但很可能是僵化，尤其是一些大企业，很像红楼梦里的 “花柳繁华地，温柔富贵乡” ，最后贾府变成了假府，你的单位是吗？ 其实，中国古人就非常清楚这个道理，“生于忧患，死于安乐”。 温水煮青蛙也是这个意思。 管理上也一样，如果管理人员，觉得一片祥和，然后可以去登个珠峰之类的，如果你还没做到万科那么大，大部分应该都是虚幻的，是因为没有人提意见和提建议了，那我们就可能是是又到了自己的舒适区了。 很多人，包括我自己单位里的，尤其是做长期客户，非常容易让人陷入舒适区，一旦长期客户合同结束，毫无疑问会出现下面这个场景： 我也面试过很多人，他们在一个企业里工作了很长时间，常年用着熟悉的技术，不用学习，毫无压力，等年龄大以后，公司内部要使用新技术，他们就难以适应，然后出来找工作，但是其实出来还不如原来公司工资高，因为原来的公司对你有感情，会考虑你过去的贡献，但是一个新的公司是不会看这些的，这就是长期待在舒适区最大的危害，检查一下你现在在舒适区里吗？ 你在舒适区吗？ 请检查一下： 你的工资是不是很多年没有什么大的变化？ 你的社交网络有变化吗? 你每天或者每年的任务列表是一样或者类似的吗？ 你的职业生涯的目标有阶段性的成果吗？ 你不高兴，但是不知道为什么？ 你反应迟钝了吗？ 你很久没学习新东西了？ 如果回答是的，你很大可能就在舒适区里。 怎么办？下次我们谈谈如何走出舒适区的一些方法。","link":"/2019/02/27/personaldev-2019-02-27-ni-zai-shu-shi-qu-ma/"},{"title":"如何学的更少，会的更多","text":"“吾生也有涯，而知也无涯”，我们要学的东西太多了，但是很多东西，不学还不行，尤其是自己的专业，自己用来安身立命的技能等，尤其是现在各行各业变化都很快，时代在进步，科技在进步，不学习就没有活路，比如从工业时代到信息时代，人人都在用互联网，人人都在用手机，那么你所在的行业一样会和这些新科技联系在一起，所以有了工业+, 互联网+，+互联网。那么，随着AI的发展，估计到时候人人都得会点编程。 那么问题来了，这么多东西要学，怎么办？ 其实我认为并不用担心，我们只需要做的是和人拉开差距，往人群的头部走，道理很简单，任何一个社会，任何一个国家，任何一个城市，都不会让这个城市的前20% 的人没有活路，你要做的就是往前排走。 那么如何能走到前排呢？大家的寿命都差不多，也就是大家一生的时间总量也差不多，我们要做的就是提高学习效率，要做的就是用最短的时间学到最多的东西，单位时间里学习产出多。 这个世界上有很多学霸，今天我就给大家介绍一位学霸，为什么需要介绍他，因为他一年完成了麻省理工学院(MIT) 需要四年才能完成的33门课程。 他叫斯科特.杨，从高中开始放学后就几乎不学习，尽管如此，他还是以全班第2名的成绩毕业。读大学时，他每天学习一般不超过2个小时，但他的平均成绩总保持在A以上。从加拿大马尼托巴大学商科毕业后，他又以超凡的速度学习了麻省理工计算机课程，并登上TEDx的演讲台，向全世界宣讲自己的学习经验。斯科特·扬在家用了12个月，通过互联网完成了四年麻省理工大学33门的计算机课程，节省了150万的大学学费。 那么，他用的学习方法是什么呢？就是整体学习法。 同时把学习分为几个步骤： 后面我就分几次聊聊整体性学习法的东西，让你可以快速的熟悉这套学习方法。","link":"/2019/03/02/personaldev-2019-03-02-study-less-know-more/"},{"title":"你真的在学习吗？","text":"学习的焦虑现在已经是信息爆炸时代，到处都是各种知识，各种新闻，各种信息，各种培训学校，线下的，线上的，这让我们很多人感觉非常焦虑，总感觉跟不上了，落后于别人。 这对喜欢学习的是一件好事，因为我们多了知识的来源，他让喜欢学习的人越来越好，不喜欢学习的人越来越差，也就是加大了与不喜欢学习的人差距。 但是，我们不断学习，却感觉到越来越累，为什么？因为有句很丧很流行的话：“我们不停奔跑，只为留在原地”。我对罗老师这句话其实不满意的，我真希望罗老师以后能修正这句话，我们奔跑，首先要想是否和别人比，如果和自己比，那肯定是在前进，如果和别人比，那也不一定留在原地，我跑完过半程马拉松，我就知道，只要不停奔跑，就有人不断掉队，所以只要不停奔跑，就会离终点越来越近，所以坚持学习肯定是对的。 焦虑的原因，是很多人觉得 “吾生也有涯，而知也无涯 “， 学不完呀，所以很焦虑，也有人把后面的两句话加上了 ”吾生也有涯，而知也无涯，以有涯随无涯，殆己！” 放弃了，这更不对，我相信庄子并没有此意，我相信庄子的意思大概就是我们不要被信息爆炸炸晕了，学会一样是一样，人的精力有限，不要贪大求全，量力而行而已，但不是不让你学，庄子不学，你现在还能知道他？只不过学习，不一定是坐在桌子跟前就算学习，逍遥游也是学呀。 是你在学习，还是朋友圈在学习？我的朋友圈里，很多人在”坚持“学习，每天打卡朋友圈，一天不拉，我好佩服。其中最多的是英语学习打卡，我就见了很多人都打卡几年了，什么APP里面都级别很高了，天天说着自己欣赏自己的话，”今天又进步了“，”坚持很重要“，”朋友们，你们都学习了吗？“， ”每天一小步“。 还有一些人，咖啡厅里拍张照，”今日阳光明媚，读读书”，然后朋友圈一发，这些人还特别喜欢晒像“红楼梦”，”呼啸山庄”之类的。 （如果我朋友圈里的朋友也看过这些，我没有说你，我的朋友都是真的学习的人）。 我不否认，确实有不少人认真学习，但是大部分我可以肯定的是都不是，天天朋友圈学习英语，面试一句说不了，读书，问一下书里面写的啥，一问三不知。 说明什么？大部人都是把知识发给朋友圈，谁在学，微信在学，朋友圈程序在学。如果你真在学，而收效不好，那就是学习效率低，不用担心，后面我们一起探讨会一下高效学习。 兴趣学习，学习的重点在哪里？现在特别流行说 “兴趣是最好的老师”，我其实是比较怀疑的，这个对小孩可能很受用，但是对成年人不一定，兴趣不是那么重要，很多时候，兴趣是培养出来的，就是在某个地方不断成功，你自然就喜欢了，比如，你编程，你大量练习，最后比周围人都强，你做出了很多成功产品，你就会越来越有兴趣。所以，成年人，不要太看重兴趣，先想想，你在哪个行业容易做出成绩，哪个行业你就有兴趣，兴趣是你擅长做这件事，然后越做越好，别人都认可你，你自然就有兴趣。不要一弄就是不感兴趣，如果你赖以谋生的事情，你都不，那是懒惰者或者失败者的借口。 再拿学英语举例子，很多人说我喜欢看电影，所以我看电影学英语，有的人说我喜欢听歌，所以我要听歌学英语，很多人说我要背单词，但是最后都没效果，为什么？ 因为看电影学英语，听歌学英语也好，他们把重点放在了看电影，放在了听歌。看电影学英语，重点是学英语，不是看电影好吗？ 也就是你要把一个电影看十遍，看到你只想学英语，而不像看这个电影了。看几遍后，把屏幕挡上听。 我要背单词，不是朋友圈里天天打卡，这样重点就是彰显不是 “背单词”。 最后我并不反对朋友圈打卡，相反我鼓励你打卡，但是请记住下面的话。","link":"/2019/02/28/personaldev-2019-02-28-are-you-really-study/"},{"title":"八零后怎么就成了悲情的一代？","text":"网上或者现实中有很多人为80后打抱不平，我自己也是80后，我没觉得80后有多少悲情。 说80后悲的情这些人，老是说现在很多成功的人都是70后，60后，觉得人家那个时代好，这个显然是只看一个时代的头部人物，好像我们在那个年代就能成功一样，然后觉得90后，00后吃穿不愁，但是90后一定比我们幸福吗？先不说社会本来就应该要进步，一代要比一代强本来就是好事，难道我们的努力不就是让我们下一代也过的更好吗？况且，90后面对的世界也不一定比我们80后好，至少我小的时候，没有那么多作业，而且作业我想做就做，不想做就不做。 我自己也是80后，我小的时候虽然穷，但是我从来也没感觉到痛苦，因为我不知道富人是啥样，我周围都穷呀。小的时候没事我可以躺在山坡上晒太阳，下河摸鱼，上山赶羊，晚上8点就睡觉了，现在的小孩儿敢想吗？根本不敢想，为什么呢？因为怕输在起跑线。这个起跑线在我看来是什么呢？就是你去球场看球，前面有一个人站起来，后面的人不得不站起来看，最后大家都是站着看完一场球。你能说这比我们那个年代大家都坐着看球更幸福吗？ 说到机会，我们怎么就少了？ 没成功都是我们自己没用，我至少觉得有很多机会，最终都是自己无能没抓住，比如高考依然是给我们最大的机会，高考我们没参加吗？为什么人家都能考到名校？70年代多少人连高考的机会都没有，而且那个时候高考比现在难多了吧？ 还有的人怪扩招，不扩招说不定你都上不了大学。 70后成功也没啥稀罕的，70后都快50了，哪个年代的成功人士都是这个年龄段的人，再过10几年，你看肯定是80后里面的人当大佬，这很正常。 80后房价太贵？那70后当年住的房子好吗？能有的吃就不错了，90后将来毕业房价估计更贵吧。再说，80后毕业的时候，房价还没那么高，要是大学好好上学，毕业头几年能挣点钱，早点买房，不也是很好的赚钱机会吗？估计10年前买几套房的人现在笑的睡不着吧？没买，还是自己眼光不够，能力不够，没啥遗憾的。我当年也没买，但是我也没啥后悔的，当年没本事，没挣到钱。 80后要养几个老人，有啥委屈的？要是你不是独生女，家里能把你养大就不错了，你享受了几十年，现在多努力一点，咋就委屈了，你家里要是3,4个孩子，估计你能不能上大学都不一定。况且，国家现在的医保已经可以了，原来农村生个病，基本都看不起，更别说，现在的医疗水平进步巨大，很多当年得个病都活不了的，现在都能很好的活着。 80后牛逼的人也多的去了，现在信息这么发达，很容易就能看到，头条张一鸣是不是80后？拼多多黄铮是不是80后？好未来张邦鑫是不是80后？大疆的汪滔是不是80后？滴滴程维是不是80后？。。。。 所以，我们不要看到其他70后、90后的头部人物，就抱怨我们的时代，我想说的是，我们比我们的祖先日子强多了吧？至少现在是和平年代，不要觉得自己在战争年代就是将军，其实有这想法的人，战争年代当兵估计都没人要。要看看我们自己身边，自己这个年代优秀的人，多向他们学习。 80年代的人，不是出生在最好的一代人，但也绝不是最差的一代。相反，我觉得80年代的人，恰恰是幸福的一代。 感谢，这个时代！作为80后，我们只有不断努力，才能对得起这个时代，不要浪费时间抱怨，专心奋斗，留给我们的时间不多了。","link":"/2019/03/07/personaldev-2019-03-07-80-is-not-bad-generation/"},{"title":"人生可能并不是一条线","text":"之前我提过要走出舒适区，尽自己最大的努力去寻找自己的边界。但是很多时候我们又很难定义这个边界. 周末看了奥斯卡最佳纪录片《徒手攀岩》，我就在想一个问题，这个电影最后成功，我相信主角Alex应该是一步步走出舒适区，一步步的增加挑战，幸运的是，他成功了，但是我相信有很多没有成功，而事实上，很多极限大师都是为了挑战极限，不断走出自己的舒适区，最后献身在这个运动里。 而如果我们做的不是极限运动，万一我们走出去超过了自己的边界，超出了自己的承受能力呢？比如我们不断学习，拼命工作，可是，最后万一我们身体扛不住死掉了呢？ 那么，我们在追求什么？ 我们都在追求成为精英的路上，那么我们眼中的精英到底是什么？我想大部人追求的精英就是有钱、有权、有名望。 但是，这太难了，做为一个农村长大的孩子，然后见过一点市面的人，我觉得要想成为大家眼中的精英太难了，虽然说读书和奋斗让我们可以更进一步，但是如果老是要追求物质而不停止，我们这一生还有幸福吗？ 随着年龄越来越大，我慢慢的相信“命”，我说的命不是说我们听天有命，不是说算命先生说的命，而是你出生在什么样的家庭，在什么样的环境长大，这就是你的命，我相信我们大部分人终其一生24小时不睡觉也没有王思聪有钱，甚至有学问，为什么？有钱人有资源，好的教育也会让向人家倾斜，起点会越来越重要。 这就是我说的边界，我们要知道我们自己的边界，不要好高骛远。如果社会阶层是100层，我们父母在30层的话，我想我们一辈子能爬到60层已经是做了很大的贡献了，不要想着往90层爬，这基本不可能，要认命，认了命了，我们才会专心看到眼前的几个台阶，先爬上去再说。 看万维钢的书，里面提到了这个社会其实有三条链，食物链、智识链和幸福链，这个对我启发很大，或者至少让我们和某些有钱人比，让我们有了一些安慰。 食物链主要代表物质，就是钱、权、社会关系。但是这条链，我们只能有小的改善，也就是最多能到个中产，再往上很大程度上我们难以决定，除了命以外，运气是很大成分，所以说我们决定不了太多食物链的排名。 智识链，就是我们的认知，我们的三观，我们的文化，智识他不是一种物质，他很难继承或者赠送，这就给没太多资源的人有了很多机会。我相信很多靠读书来改变命运都在这条链上提高了自己的排名。 幸福链，就是我记不追求富贵，也不求有啥文化，我就老婆孩子热炕头，原来我觉得这种人没追求，现在我觉得也挺好的，人家自我满足，幸福就可以，现代这个社会，你食物链和智识链排名靠前的人也不能把我咋的，这样，其实也挺好。这个关键就是要自己觉得幸福，如果自己又要追求物质，比如抱怨工资低了，抱怨自己读书少了，那其实在幸福链上的排名反而更低了。 可以看到，如果只追求食物链排名的话，会非常累，付出大量的代价才能提高排名，而智识链相对容易一些，就是智识链排名靠前的人，控制不了别人，但是别人也别指望控制我，也就是想当我傻逼那也没门，幸福链主要是精神层面，主要是心态，幸幸福福过点小日子，如果你觉得幸福的话，现在社会其实并不难。 通过上面，我们可以发现，其实这么一分的话，人生就有三条线，我们要关注的是三条链上的排名，而不能只关注一条链，如果只有一条食物链排名的话，很多时候我们能气死，因为这条链我们很多时候不能有太大改变的。 其实，现在食物链上排名靠前的人，如果智识不高，财富其实是守不住的的，而智识链上排名靠前的人，很多时候会有机会做一些大事，这种自我实现会让让你感觉幸福，而且有机会大大提高自己食物链的排名，即使升不上去，我们依然可以通过我们的智识来培养下一代。 有的时候，我说一些东西，有些人会反问，你混的有钱吗？你没钱你说的东西就不对，哎，我想说，食物链的排名不是你想提高就提高的，但是提高智识链的排名总是让你有更多机会提高食物链排名的，而且很多时候有智慧和知识，这种幸福感无法传给别人的。 当然，我并不反对物质，如果哪个学问叫你无欲无求，只追求精神享受，我感觉那可能不是一个好学问。 总结一下，人生三条链，食物链、智识链，幸福链。我们不要只死定一条食物链而忽略了另外两条链。","link":"/2019/03/04/personaldev-2019-03-04-life-is-not-a-single-line/"},{"title":"你的产品卖不好，可能是说明书的问题","text":"我现在特别怕买国内的一些家具，尤其是需要自己组装的东西，倒不是质量不好，中国这么多年的制造经验，我相信很多产品本身的质量已经很不错，至少从原材料上来看。我们也都知道，很多产品国内生产，国外贴一个牌就增加了很多价格。 但是，为什么我依然害怕买一些国内的产品呢？因为很多产品不提供安装服务的话，你自己会相当痛苦，我有很多次买一些小的家具，然后回来让我自己组装，买回来后发现有个很气人的东西，就是没有说明书，有的时候我打电话过去，他们说这个东西很简单呀，然后给我发个视频的链接，每次我看完，要么是没看懂，要么就是他演示的产品和我的有差异，要么就是让你看完，啊哈，感觉智商受到了侮辱。每每这个时候，我就想把买的东西扔了。 最崩溃的是你安装完了，发现有个地方安反了，然后你想死的心都有，因为不光是重来一遍，你还得先拆再重来。还有的时候，没有说明书会让你把产品弄坏了，人家商家还不赔，我记得我买了一个食物垃圾处理器在水池子下面，但是安装的时候，我把一个孔给打开了，后来问了后才发现，那个只有安装洗碗机的时候才打开，可是遗憾的是那个孔已经打开堵不住了，怎么可能给他们好评？ 还有很多产品功能是有了，但是基本上你很难知道有这个功能，比如我买了个加湿器，我用了几个月了，才发现原来那个过滤网是可以拆下来洗的。说明书里没写，真的是工程师白设计了这个功能。 上面是宜家的说明书，基本上宜家的家具买回来，都有说明书，虽然说有些说明书依然不是很直观，但是人家至少是有，而且是多语言的说明书。相比，国内很多厂家的东西寄过来，就没有说明书，我前段时间给屋里换个锁，然后我花了好久才研究透锁的组成才最终安装成功，他奶奶的，我有必要为了换个锁，花时间去学习锁吗？ 一份好的说明书，可以大大的让产品上个档次，让用户的舒服度和体验大大上升，更重要的是可以节省用户的时间。原因很简单，不要认为你的用户都是这个行业，都是非常聪明的，你的产品操作越简单，你的用户的门槛就越低，你的用户群就越大。 我甚至觉得各行各业都要个用户手册。 拿我在的软件行业来说，很多人以为把代码交到客户手上就行了，其实不是，用户不知道怎么安装，怎么使用，再好的软件也发挥不了价值。 就用最常见的餐饮外卖，你觉得要不要用户手册，我觉得是要的，如果每个用户打开后，发现有一张纸，纸上印刷着你外卖食物里各种食物的组成，各种食物大概的配比，用户是不是吃的更放心呢？再画上一些图告诉客户怎么吃手不会脏，吃完了垃圾要扔到哪里，可回收还是不可回收，是不是商家的逼格就高一些了呢？甚至你可以告诉食客你做这个外卖的远景呢？最后再协商如有什么问题，请联系哪里。我相信我肯定愿意多点这样的外卖，就算再不行，我可以用这张纸当我吃饭的时候餐布吧？而你的成本就是多了一张纸而已（这段给我做餐饮的朋友思考一下) 所以，我希望我们学习别人产品的时候，不要光学习硬件的部分，现在硬件部分基本说没有壁垒了，因为很多复杂的东西，你可以砸碎了学，放到显微镜下看，但是别忘了学习人家软件的东西，比如写一份好的说明书。","link":"/2019/03/09/personaldev-2019-03-09-why-your-product-not-sell-well/"},{"title":"发展你的兴趣，而不是跟随你的兴趣","text":"大家是不是经常从成功人士之口里听到下面的话： 兴趣是最好的老师 (Interest is the best teacher) 跟随你的内心 (Follow your heart) 追随你的激情 (Follow your passion) 我想说，作为一个普通人我们千万不要盲信，如果我们完全这么做，会让我们相当危险。 我们看到很多成功人士，说这话的时候，也确实发现他们对他所从事的是很有激情，看似真如他们所说。但是，我们有没有考虑过一个问题？是因为他们做的事情成功后，他们才更有激情？ 还是他们本身对这件事就很有兴趣，然后才做成功那件事呢？ 我可以肯定的是，大部分人都是后者，就是你在一个领域成功后，你才对这件事更有激情。 兴趣是最好的老师，是非常大的骗局为什么？因为这假设了两个前提： 第一，我们知道我们的兴趣。 第二，我们的兴趣是不变的。 显然，这两个前提都是不成立的。 很多时候，我们还没见到更多的东西时候，我们最么知道那就是我们的兴趣，那就是一生所求？当你常年住在一个小山村，你可能并不知道你真正的兴趣是什么？当你突然见了花花世界后，你可能对很多东西都有兴趣。 其次，我们的兴趣也会随着年龄变化的，我们想想，婴儿时，我们的兴趣是喝奶，小孩子时，我们的兴趣是玩具，是好吃的糖果，到了成年，我们的兴趣可能是音乐，美术或者旅行。 兴趣不能当饭吃这个世界上，能把自己的兴趣变成工作的很少，比如，你喜欢篮球，和你能找到一个篮球工作，这个差别很大，喜欢和你能，这里面隔了十万八千里，我相信大部分人都喜欢打游戏，对游戏很有兴趣，很有激情，但是游戏能当饭吃吗？不能，你看到有的人打出了世界冠军，但你想想，那个冠军凭什么是你？你有没有这个天赋？你有没有训练你的资源？你去问问那些打出冠军的人，他们失去了什么？很多人说我喜欢，所以我更努力，这个世上不是光靠努力就可以成功，更需要资源，需要专业的训练，刻意的练习，很多时候，一上专业的训练，你的兴趣可能并不是你想象的那样，一个枯燥动作做上万遍，你真的认为这很有意思？ 追随兴趣，很多时候就是懒惰除非你是天生的富二代，不然，我们就一定需要养活自己，甚至是养活家人，我们可能需要从搬砖开始，而不是做梦自己开着跑车四处兜风去，我们很多时候说是追随兴趣，其实就是懒惰，是因为我们不想脱离自己舒适区，觉的练习太苦，觉得学习太累。 兴趣是培养出来的很多时候，我们的兴趣不是一开始就有的，或者一成不变的，很多时候，我们的兴趣是这样产生的，就是我们做一个事情的时候，我们做成功了，或者比其他人做的更好点，我们就有了成就感，然后这种成就感如果不断的正循环，然后就产生了对这件事的激情。这就是为什么，我们很多时候，说鼓励教育比兴趣教育重要一百倍，一千倍，一万倍。我们开头说的，那些说兴趣是最好的老师的那些人，就是这么来的。 跟随你的兴趣就是把鸡蛋放到一个篮子里我们知道把鸡蛋放到一个篮子里，风险巨大，但是把一个人的人生放到一个篮子里，我认为无疑是犯罪，首先，我们根本不知道整个社会几十年之后发展成什么样，其次，万一这个兴趣行不通，怎么办？行不通的可能性太大了，比如，我们大部分人的兴趣都是音乐，美术，体育，但这些最终能走出来的人太少了，而国家的教育体系，让一个人出来没饭吃的几率太低了，如果你有大量资源，你有大量资本，你有退路，那还有可能，但是如果你没有，国家的教育体系是我们大部分普通人家最安全的出路。 很多我们不感兴趣的事情，会是我们将来感兴趣的事情的重要基石如果说你喜欢计算机，但是不喜欢数学，你喜欢运动，但是不喜欢基础课，这都是不行的，越来越多的行业，都是跨学科的，越是往顶部走，越是发现之前枯燥的东西有用，越来越发现，枯燥的东西就是你的瓶颈。比如，我上大学的时候，觉得操作系统可没用，觉得高等数学生活中完全用不到，但是，等我需要看AI的东西的时候，就非常后悔没有学好这些课程。比如，你觉得做好面包和学好英语有什么关系？当你追求的东西层次上升到想和全世界交流的时候，你还觉得英语不重要？你觉得学好语文和英语有什么关系？当你想把中国文化传到全世界的时候，你觉得英语重不重要？你喜欢乐高，你喜欢建筑，你学不好数学，估计也只能盖个几层小楼？当你想盖出世界一流大楼的时候，你觉得美术重不重要？数学重不重要？物理重不重要？ 给学生的建议如果你还是一个学生，我觉得你要把功课学好当做自己最大的兴趣，否则你就上不到好的大学，三人行，必有我师，好的大学，有好的资源，有优秀的同学，他们能把你的感兴趣的事情做到世界级的，你喜欢车，做无人驾驶呀，你喜欢飞机，飞往比邻星呀，你喜欢乐高，盖世界第一大楼呀。学好功课的前提下，兴趣放课外发展吧，除非是你很早就展示了某方面超强的天赋。 给工作的人建议大部分的人都不是富二代，先看看哪个事情能让积累你的资源，找到一个工作，有一份收入，然后有余力的情况下，再谈兴趣吧，据我观察，大部分人，都是在某一个领域沉下心来，努力学习，努力工作，然后取得成就，最后这个人发现这件事它越来越有趣。 刚开始，我喜欢安安静静的写代码，我不喜欢做管理，但是，短期写代码水平不会有巨大的提升，而我自己更擅长一些管理的东西，比一些人这方面做的好，所以我做了这方面的工作，比我写代码可以带来更多的收入，我可以用我多出来的收入，发展我的兴趣，比如我可以买更多的书，更好的电脑，付费参加高水平的会议等等，最后代码水平也跟着提高了，这不也很好吗？ 你如果喜欢旅游，那么你先把能力提升，工作做好，学好英语，然后去其它国家出差，既能旅行又能为公司带来贡献，不是很好吗？ 找最能发挥你的事情做，找你最能贡献价值的事情做。君子不器，很多人老觉得自己对一件事情感兴趣，就不想做别的事情，其实我们喜欢，和我们能做贡献的并不是一件事，我们在社会的价值，最终是通过我们对别人的贡献来衡量的。 我们已经工作的人，不要想自己喜欢做什么情，想想你做什么，对公司贡献最大，对社会贡献最大，比如，你是做后端的，但是公司急缺前端，那你是不是可以学前端呢？ 你是个后卫，但是队伍现在缺个好中场，我们是不是可以尝试去做中场呢？哪里你给别人贡献大，哪里能发挥你的特长，哪里你的收获就越大，我们的幸福很多时候是因为别人需要而存在，我们的幸福从来都不是来自对别人的需要。 因此，找到一件事情做好它，然后不断加大难度，不断做好它，慢慢的，这件事情你会喜欢的，千万不要猴子掰包谷，今天一个兴趣，发现没做好，就说没兴趣，明天又是这样，这样终将一事无成，人生也终将无趣。","link":"/2019/03/11/personaldev-2019-03-11-develop-what-you-like/"},{"title":"习惯付费，终身受益","text":"现在有了互联网，很容易让很多人产生错觉，觉得很多东西可以免费得到，似乎你也正在享受很多免费的东西，头条让你免费看新闻，抖音让你免费看娱乐，各种视频网站也可以免费看到很多电影，电视剧八卦等。 我们有没有认真想想，这些东西你真的是免费得到的吗？你是不是在忍受各种广告？你的各种点赞是不是在帮助服务商标注数据？你的安全信息已经各种泄露，你在互联网早就一丝不挂，你说没有？你朋友有没有？现在各种APP都可以读取通讯录，虽然你没有，但是只要你出现在你朋友的联系人里，如果他上传了，你的自然也暴露了。 这个世界的本质，就是资源的交换，时间也是资源。你免费使用一些东西的时候，你出售的就是时间，这个时候你的时间换算下来估计连一毛钱都不值。 我先举个我身边的一些例子，我身边有好多的程序员还在用百度搜技术资料，有的时候我看到了，我问他为什么，他说访问不了谷歌，我说买一个某某服务不就可以了吗？他说免费的，几乎用不了，我心里一万个草泥马，有的人还说让公司买，我心里想这个人做技术肯定是没前途了。 还有一些人，尤其是做技术的人居多，很少买书，老是喜欢在网上找一些文章东拼西凑，估计凑了几个月都学不出个啥东西，我看到的不错技术人员，先不说买了多少电子书，哪个书架上不是一些经典图书？反过来说，没有花钱买书的人，肯定学不好技术的。所以说，以后面试的时候，让他把他家书架拍一下，绝对是个好方法。别人花一年甚至几年时间写出来的书，你就几十块钱那，你还嫌贵？国内写技术书几乎都是在做贡献，很多作者就是本着人生要写一本书的执念而已。 我们最宝贵的就是时间，虽然时间每个人都有，区别就是看我们时间卖给了谁。 付费就是让我们花钱买别人的时间，然后让我们的时间卖出更多的钱。 我举几个我自己付费的例子吧。 第一个，很多年前，我也用盗版office, 但是为了升级，为了在Mac上安装最新的Office, 我花了大量的时间，后来果断的购买了Office365, 一年几百块，可以安装5台设备，而且有大容量的网盘OneDrive可用。 第二个，我之前也是免费看视频，现在我购买了优酷，爱奇艺，腾讯视频，我看相关视频的时候，除了可以看到1080高清，免去广告已经可以给我省了很多的时间，另外付费后，可以看到大量优质的内容，比如爱奇艺的BBC纪录片，不付费你是根本看不到的，还有部分电影，完全没必要去电影院看，有了会员，有些较新的电影就可以看了，节省了去电影院来回奔波的时间，而这一个月不到20块钱而已 （我不是给他们做广告，实际上他们也没给我钱） 第三个，我和很多人一样，喜欢收集电子书，但是基本上这样收集的电子书基本都没看，后来我就开始买电子书，而且买原版，大家都知道一本原版的书均价都是50美金以上（中国图书太便宜了), 也就是一本书至少300块，自从花钱买这些书后，就确确实实认真看了一些书。 第四个，看到好文章打赏，能写出好文章的人，都有一定的水平，而打赏是我们对一个作者的认可，一个观点的认可，也体现了我们的一个价值观，就是我们不是占便宜，是愿意为别人的辛勤工作付费的人，别小看这个意识，这其实就是感恩意识，资源交换意识，尊重他人劳动的意识，这个意识让我们人与人之间产生了巨大差别。 例子有很多，以后可以再聊。 很多人说，我穷，我没钱，第一你真的穷的一年几百块钱的付费都付不起？ 第二，你有钱的时候，想过或者做个这些吗？ 花钱省时间，穷一阵子，花时间省钱，穷一辈子。","link":"/2019/02/19/personaldev-2019-02-19-xiguanfufei/"},{"title":"2020年终总结","text":"往年写年终总结的时候总觉得时间过得很快，2020年却让人觉得过得很慢，新冠病毒让整个人类都度过了非常艰难的一年，我希望2020年不曾来过。2020年必定在人类历史上留下非常重要的一笔，一笔人类遭遇新冠病毒，共同抵御新冠病毒的壮烈篇章。 2020年，回忆都是很多痛苦，但是2021年要来了，还是简单总结一下吧。 工作方面作为一个中年的需要养家糊口的男人来说，工作方面一直是投入时间最多的，做为一个分公司负责人，加上公司是做国外项目为主，今年的疫情国外的情况大家都知道了，所以开年的时候，我是非常担忧的，尽一切机会争取和参与项目，稳定现有客户，加上在家办公，管理上也必须做出调整和适应，加上疫情期间公司也更换办公地址，上半年自己每天工作时间都是超长的，最后公司保住了以往的基本盘，营业额也略有增长，由于保密原因，工作内容这里就不便细说，工作上时间和精力投入都不小，总之，感谢党，感谢领导，感谢同事，更重要的是感谢自己的努力。 锻炼和健康健康方面，由于在家办公，加上工作时间超长，工作习惯不好，久坐导致颈椎和腰椎都出现了很大的问题，这个问题，一个是工作太忙，年初头几个月，基本上每天都是坐在电脑跟前10几个小时，第二个是觉得自己身体底子好，19年跑了一次全马和几次半马，就忽略了工作习惯，颈椎和腰椎的问题反反复复，这个是对我今年影响最大的一件事，几度及其痛苦。加上中间去按摩了一次，导致加重的很厉害，这里提醒大家轻易不要去按摩颈椎和腰椎，基本上大部分都是瞎按的，即使你觉得你找的人很专业，原因这里就不解释了。 今年还出现过头疼，心脏疼，但是做了各种检查都没发现问题，后来每天半小时正念冥想，坚持了一个月后，就基本上没有问题了。 自己本身是一个喜欢跑步的人，遗憾的是2020年跑步这件事基本上是废了，上半年疫情严重没法出去跑，再加上颈椎腰椎问题没敢跑步，后来让亲戚找了熟人做了核磁共振诊断，医生说可以跑步锻炼才开始慢慢恢复跑步，但是停下来那么久，加上身体问题，想恢复非常困难。最后一直慢慢坚持，11月8号勉勉强强跑了一个西安马拉松的半程。 个人成长今年学的最多的就是医学，业余时间用了不少时间看研究医学方面的知识，研究医学的一些前沿的研究。 学习了《阅读与写作过程》课程，收获非常大，感觉自己原来读书就是识字了，学完这个课程，对中外很多著名作家，著名诗人，书法家写的内容真的发自内心欣赏，坚定了自己以后要多读经典名著的兴趣。 要说今年最大的收获，就是每天1小时，坚持了一个月的学习了沟通课，以往也看了很多书，但是今年才理解了什么是沟通，后面有机会详细聊聊。 技术方面的学习，很多都是工作需要的，今年这块儿比去年少多了，也不想写了，不想挑战太多的技术的东西，因为大部分的应用类的技术只要愿意投入时间和精力都能很快学会，又不是去搞科研，高深的算法。技术方面的自我成就感越来越少了。 今年还有一个最大的收获，是对“无限游戏”有了较深的理解，当我们以“无限的游戏”来看很多事情，那么很多事情和我们现在的理解会大不同，这个后面会写篇文章分享。 娱乐方面今年基本上没有啥娱乐，不得不说是遗憾，期望的各种体育赛事几乎也没有。 非要推荐点啥，那么电视剧《女王的棋局》和综艺节目《演员的诞生》是值得看的，电影的话，虽然《八佰》有硬伤，但是不当正剧看的话，还是拍的不错的，科幻片《upload》也大开脑洞，至于大火的电视剧，《装台》和《大秦赋》也可以看看，装台看了2集，由于自己是陕西人，我只能说里面的人的性格，我感觉和我身边很多人很像，演的不错，但是就是节奏太慢，《大秦赋》由于说的是战国，先秦和秦，这个时代有太多的经典的书都看不完，看电视对我来说有点浪费时间。加上很多编剧胡乱改，而且非要加上自己的思想，自己可能又没啥思想，所以很多历史剧我都不太看，这一点，我和李诚儒老师的观点是一致的。 还有一件娱乐的事就是美国大选，对美国大选进行预测也是一件快乐的事，没想到通过娱乐了解了美国的选举制度，学习了一些美国的历史，对西方的自由和民主制度，我现在是越来越怀疑是有很大问题的，反过来对中国的政治制度更多理解和认同。 总结2020年很多东西都不想写，不想回忆，如果将来老了无事可做要给自己写回忆录的话，那个时候我想肯定是可以把2020年很多东西拿出来细细的写一写的。 2020收获： 人生无常，经历生死，以后余生不虚度。 多加锻炼，身体第一，身体问题都是习惯问题造成的，尽量保证每天7小时睡眠。 生活中的很多问题都是沟通能力问题造成的。 学会玩无限游戏。 正念冥想有用。","link":"/2020/12/31/personaldev-2020-12-31-annual-summary-2020/"},{"title":"领导力：不要做个“好人”","text":"最近和人聊女孩子应该找一个什么样的老公，我给的第一建议是这个人必须是个好人，好人的意思就是要本心善良，有empathy 共情能力，但是给的第二个建议就是要有领导力，做什么才能锻炼领导力，这里面有很多东西需要学习和做的东西，但是判断一个人没有领导力有一条比较管用，就是这个人在做事的时候如果一直是“好人”，那么他就是不具备领导力。这个好人和我第一个建议的里本心善良的好人是不同的，但是这两个好人是可以集于一人之身，为什么需要领导力，因为领导力不光让我们可以做好工作，也可以让我们更好的生活，因为领导是一个职位，但是领导力不是职位，而是做事和解决问题的能力。 由于我不是一个情感博主，加上我今年一个工作的重点是我自己和团队里的Leader的领导力的提高，这篇文章我们就重点谈谈第二点。 前几天，一个朋友跟我抱怨说，自己这几年一直很努力，做事能力也可以，和团队的人相处大家对他评价都挺好的，但是一直得不到职位的提拔，有些比他年轻的人业务能力不如他，都开始带团队了，自己感觉非常不公，我想不少人也有这个问题，但是大部分人都会抱怨公司，抱怨领导，但是因为是朋友，如果聪明点做个好人，我和他一起骂他领导就可以了，但是因为是朋友嘛，就尽量说点有用的，我给他的回答大概就是，不要找领导的问题，我们大部分的问题都是自己的原因，我们平时做事有没有体现出来领导力，比如团队里人有问题，他说了觉得自己得罪人，那么就是缺乏领导力，缺乏领导力怎么可能去带领队伍呢？从平时对人来看，就是一个老好人，要想提升，我给的建议就是不要做老好人。 为什么具有领导力的人不能做个“好人”，我这里举一个例子，因为做个好人的结果就是这样的，假如你是一个男生，你让人给你介绍一个女性的朋友，这个女生挑不出你的毛病，但是最后人家还是拒绝你，拒绝的时候还会鼓励你说：“这个人是个好男人，老实，认真，勤奋，他一定能找到更适合的人”，看出这个问题了吗？你是一个好人，别人挑不出你的毛病，但是事情的结果呢？没有进展。你最多可以陪她看夕阳，永远没机会一起去看朝阳。 那么回到领导力这块儿，假如你在一个公司里，领导对你的评价就是你是一个好人，你只是一个好人，那么你就要注意了，等于直接就说你没有领导力，但是，有的时候，我和人沟通，很多人竟然举一些例子，说你看看谁谁是大领导，你看看人家的是多么好，从不发脾气，和和气气。我只想说，如果理解还是这样，我就会觉得不光是没领导力的问题，智商都堪忧，首先大领导都是想得多，说的少，但是决定事情的时候都是非常有决断力，非常的狠，而且大领导是不会有时间去管你一个小兵的，那么小兵需要谁来管呢，当然是中层领导，中层领导如果做一个好人的话，大领导为什么让你当中层领导呢？大领导刚开始创业的时候有几个脾气好的？ 我接触的一些人，本来各方面技术能力，工作态度等等都非常不错，但是一直很难有所突破，最重要的一个原因，就是选择做一个“好人”，不愿意得罪人，这就导致自己停留在一个Level上被困死了，这里面经常表现为以下几个： 团队成员工作态度不认真，不想说。 团队成员工作质量有问题，不想说。 团队工作态度不认真或者质量有问题，不能直接说，说的很委婉，委婉的别人要么没听懂，要么装作没听懂 团队人员工作不能改进，不敢换人。 如果领导有问题，则更不想说，即使影响自己的发展都不说，选择自己忍着，选择自己吃亏。 这里面经常出现的原因有几个： 不想说，不想得罪人，因为我就拿这点钱，为什么要做得罪人的事。 不知道怎么说 但实际上，不管是做领导还是做团队一员，发现团队问题和提升的东西，就算不谈团队协作能力，对自己的利益来说，都是对自己有益的事情，你是领导，你成员有问题，你不提，他怎么提高。 你是团队成员，你领导有问题，他领导不好团队，你不说，你又不离职，最后受害的更是自己，这里的受害就是整个团队不会成功，一个团队都不成功，你怎么可能成功？ 这里面很多人觉得第二个问题知道怎么说是能力问题，但是我却认为第一个更是能力问题，当你这么想的时候，基本上你拿多少钱都不会这么干，因为一个人能力不是自己脑子想的自己能做就能做，一个人的能力不是知而是行，不是看你知道多少，而是要看你把知道的东西行动和应用的能力，如果你不去”行“，那么你就永远停留在“知”这个层面，而且知的这个不通过验证，你怎么知道你知道的就是实际情况呢。 这里面最重要的问题就是，很多能力都是不断累积的，尤其是领导力，更是需要通过实际的领导经验的，这领导就是要领导和组织去完成一件事情，或者负责协调去解决一个问题的。如果我们不开始实际着手解决一个小问题，怎么有能力去解决一个大问题呢？如果你不领导好一个小团队，谁会给你机会去领导一个大团队呢？ 所以，领导力的一个很重要的一点就是不能做一个老好人，一个团队，领导是老好人，最后的结果就是问题不会得到解决，事情得不到解决，整个团队就会遭殃，最终这个老好人自己不能升职加薪，团队大部分人还会从心里记恨，觉得自己跟了一个不行的领导。 回到整个社会上也一样，你很难期望所有人都非常遵守规矩，而实际上也不可能的，不然不会有法律，不会有警察。如果其它人都选择做好人，那么整个社会的环境不是这样的。 回到家庭也一样，如果你对所有的事情都是老好人，对所有人都一样，你家里的事情肯定也办不好，你家里的人大概率也会受不少窝囊气，现在我去问女孩子，大部分的女孩子都不会再去选择一个老实人嫁了，嫁了的都后悔了，时代变了。我自己大学刚毕业时，和一个老乡，人家给他介绍一个女朋友，女孩子家人觉得他是一个大学生，收入也还可以，但他自己真的是一个好人，两人出去玩座公交车都隔几个座位，送女孩子回家都是后面跟着隔几米，过几天，女孩子这个人太老实了，自己不愿意了，后来经人介绍，和另一个人闪婚了，10几天后，女孩子跑了，理由是这个男孩子人太好了，太老实了。 一个家庭，一篇祥和，没有一丁点摩擦，这个家庭大概率就要完了，工作上，一个团队一篇祥和，没有争论，没有一点冲突，这个时候就需要小心了，证明团队没有进步了。 说了这么多，为什么领导力不能是老好人，因为老好人可以勉强做好自己的事情，但是不能推动那些需要其他人协作的事情往前进展，不能推动事情的解决。只要事情不能解决，不管是愿意不愿意得罪人，最终体现出来的都是能力问题。 这个就像一个穷人说不是不想挣大钱，而是不愿意去挣，大概率这个人是在做梦。","link":"/2021/01/18/personaldev-2021-01-12-leadership-do-not-be-good-man-to-everything/"},{"title":"当我谈 &quot;加班有罪&quot; 我在谈什么？","text":"前言PS. 本文只描述IT行业。 博客园果真人气比较高，我之前准备写个 “领域驱动系列”，然后感觉大家不感兴趣，看来用的人不多，所以一直没动力续，但是昨天写了 加班有罪, 却收到了很多个赞，让我感到有点意外。 我今天看了很多评论，感觉很欣慰，大家其实对加班的看法和担忧其实都是正确的，但是很多人可能忽略了一些前提，如果盲目的下班就走，数着秒下班，那我写这篇文章就有罪了。 为什么加班是有罪的，加班有罪 这篇文章已经做了较多的阐述，那么光说加班有罪是不够的，公司或者老板可以提倡不加班的文化，但是如何才能做到不加班？直接一刀切，到六点就赶大家走这样肯定是不够的，可能很多公司如果现在立马这么做，可能就倒闭了，员工可能还得找工作。 加班有罪的对立面也不一定是正确的我们很多人想问题，可能是非黑即白，我们提倡不加班，但是我们要想如何不加班，如果我们技术水平低，别人1个小时做完的，你可能一天也做不完，如果你写的程序员出现了紧急的bug, 如果你上班时间在看电影，QQ等，你再不加班把任务做完，哪个公司敢用你？ 我前篇文章说过，并没有说你一分钟都不能多待，比如每个月有8个小时的加班，我认为都是正常的。 如果你上班时间也没有好好干，那么不加班更有罪，因为你是上班时间休息了。 如何不加班?我们实行敏捷很多年了，但是同样有很多人一说到敏捷，就只知道SCRUM, 没有抓住敏捷的本质。就算过程用SCRUM, 那么其实也就是一个管理层或者从上到下的东西，但是并没有对程序员每日的工作有多大的帮助。我们同样需要很多的工程实践，技术成长等来提高我们每天的工作效率和质量。 那么我认为从程序员的角度，如果你想理直气壮的准点走人，那么一下几点可供参考。 工作时间要保证 我个人觉得上班时间工作是天经地义的，可能有的人羡慕Google等有更宽松的时间，羡慕很多公司都不需要工作8小时，但是前提先想一想，我们是否有那些公司的工程师的能力和效率，如果没有，还是在上班时间好好工作，如果有，与其羡慕，不如赶紧加入你羡慕的公司，前提是人家要你。 上班的时间要用来工作 我们很多人上班时间一会儿刷下微博，一会儿看看微信，尤其是QQ闪个不停，还有号称是要学习的，加了一堆技术的群，美其名曰学习技术，我也加了些群看看，实际上发现基本都在里面灌水。原因很简单，有的时候问个问题，基本问问题的人描述不清，别人怎么回答？ 问问题，你就不能上StackOverflow吗？ 原因是自己只会用百度，好吧，我无话可说。 进公司隐瞒自己技术水平 现在IT行业有个怪圈，我觉得迟早得拨乱反正，本来作为一个程序员答答题，上机写写程序等是非常正常的，但是你要是这样来招人，很多人就很不乐意，说我没那么多时间，我只给公司请了2个小时假来面试，你看着他的简历应该是会的样子，这就极其考验面试官，很多时候越是写程序不行的，越是最比较厉害，尤其是看到概念比较多的。你还真不容易判断出他不行，但是一进来，你发现就完全不行，ASP.NET 你让写个HttpModule不会，MVC你让统一地方处理一下异常不会，你说做权限控制，他写不了一个Filter, 你说WCF 想扩展功能写个Behavior 他说我们用的时候就是顶一个接口标记Contract, 深入的没看过，总之各种不行。然后你布置个很简单的任务，就是说一个高级程序员必须会的，他得花时间再学习，然后才能有产出，你说怎么办？上班时间都在学习，你说活还干吗？ 针对上面的情况，一种方案是直接不用这个人，第二种就是要争取个人同意让他多干一会儿，不然你还得背上黄世仁的名，其他人看到你说的不加班是假的。 降低自己的薪水，给自己留学习的时间 我们有的时候，确实进来后，发现周围的人都比自己强，而自己的薪水也和他们差不多，如何衡量，就是如果你的薪水比市场其它公司要高不少，而且你进来后发现你比别人差不少，就证明你要多了，这样公司可能按同级别薪水的人要求你，你的产出肯定是比别人少，这样你想完成任务，就得加班，那么就到了我说的恶心循环，最好的方式就是主动降点薪水，然后留下班后的时间给自己学习，公司也不会对你要求太多。其实这样，你的收益更大。 提高工作效率，改变工作方式 我们很多人，做事方式和方法有问题，比如连需求都没搞清楚，就开始写代码，然后删了又删，改了又该，这样很简单的一个东西，必然要做很长时间。有的人代码写完后自己下次都要想很久才能知道啥意思，这就需要我们多改进自己的工作方式，多向效率高的程序员学习等。 同时有很多东西提高效率，比如你是否可以并行的做一些事情来提高效率，比如使用Resharper就可以大大提高效率，写单元测试可以避免你为了测一个方法每次都要把系统跑起来debug呢？持续集成可以帮助你把你修复bug更靠近你产生bug的时候等等。 下班后多学习 上篇文章我也提出了，不加班不代表下班后不学习，我招人的时候，经常问的一个问题，就是你如何提高自己技术水平，很多人回答了我一个无法反驳的答案就是:”通过做公司的项目学习”，但是这是远远不够的，一般如果只是这样，除非你天赋异禀。我是不相信你这样就能够成为大牛的。 比如我们需要了解工程实践，了解新的技术，了解一切帮助提高质量和效率的东西，了解一切提高沟通和管理的书籍等。","link":"/2015/04/17/management-2015-4-17-what-I-talk-when-I-talk-overwork/"},{"title":".Net WEB 程序员需要掌握的技能","text":"img { margin: 10px; max-width: 150px; } 最近公司里有新入职的员工，根据个人的理解和经验，我来列一下一个.Net WEB程序员需要掌握的知识 基础部分 C# 基础语法 OOP的概念，面向对象的理解 继承 封装 多态 ASP.NET MVC (Web Form 用的越来越少，如果你不熟悉，可以不看) JavaScript 基础语法 如何在HTML里使用JavaScript 常用Dom 操作 SQL Server 常用T-SQL 增删改查 SQL Managment studio 常用操作 jQuery 常用API HTML HTML 所有标签的语义，什么时候用什么标签 CSS 常用CSS的知识，如何在HTML使用 常用的布局 Bootstrap C# 代码规范 CSS 代码规范 JavScript代码规范 Git的基本使用 常用命令使用 获取代码 解决冲突 提交代码 新建分支，合并分支 Github 帐号设置 SSH 配置 三层设计 UI Service Repository 事务的代码实现 提高部分 单元测试 Nunit Moq 单元测试的基本知识 Arrange, Action, Assert 依赖注入 面向接口编程的理解 Castle Windsor 与ASP.NET MVC 的集成 Installer 不同的生命周期 Entity Framework Migration JavaScript 闭包 JavaScript 的面向对象 prototype JavaScript的动态特性 AngularJS .NET Async TPL WCF 基本使用 Debug VS 常用Debug 功能 Firebug / Chrome Developer Fiddler 常用的快捷键 windows Visual studio Resharper Chrome 进阶部分 常用设计模式 常用设计原则的理解 S.O.L.I.D DRY Repsiotory Pattern Unit Of Work HTTP 协议 前端常用的性能优化 .Net 常用性能优化的方法 RequireJS Async.js MVC 模式 MVVM 模式 SignalR PowerShell 深入部分 AOP 领域驱动设计DDD CQRS NServicebus Event Sourcing Event Driven MSMQ/RabbitMQ Load Balance Memcache NoSQL MongoDB Redis Load Balance Cache 问题 Session 问题 敏捷 SCRUM TDD BDD 使用一个敏捷管理工具 JIRA Scrum/Kanban, Trello, Target Process, Pivotal Tracker, 国产的WorkTile应该也不错 XP 持续集成 TeamCity Grunt 扩展部分 Node.js 服务器端 Socket.io Mobile APP Hybrid APP Phonegap Native APP iOS Objective C /Swift iPhone/iPad development Xamarin Cross-platform development 买一台Mac 熟悉Mac 常用操作 熟悉Shell 学一门动态语言，比如Ruby WPF 熟悉一下最新的Windows Desktop开发 推荐书籍","link":"/2015/05/12/technologies-2015-5-12-net-study-road/"},{"title":"太白山游记","text":"之前爬过陕西的很多山，华山、骊山、翠华山、王顺山、南五台、太平森林公园，祥裕。但是太白山则是爬完华山之后最想爬的山。因为它是秦岭山脉主峰，也是中国大陆青藏高原以东第一高峰，海拔3767米。更是长江和黄河两大水系分水岭，中国南北分界线，所谓人往高处走，我们都想爬的更高来看的更远。 由于我们公司一个团队做的很不错，去年获得了优秀团队的奖励，大家决定用团队奖励来活动一次。经过大家一致的表决，最后决定爬太白山。 出发（2015年6月5号）我们计划周五12点出发，但是由于团队要发布系统，后来基本到下午1点才正式从西安出发。一路高速到绛法高速太白山方向，我们一行6个人，2辆车，去的时候由于很精神我开的相对较快，下高速等了同事大概10多分钟，原本以为下高速还要开很远，但是下了高速沿法场线差不多10分钟就到了太白山游客服务中心，问了一下要自驾进山必须是2.0以上的SUV, 我们一辆车是2.0T的但不是SUV, 我们另一辆是SUV, 但不是2.0以上的，只能把车停到停车场，收费是20元一天。 盘山公路必须乘坐景区大巴，大概两个小时到下板寺，沿途有几个景点莲花峰瀑布，三国古栈道，盘山公路非常漂亮，终于明白了为啥必须是2.0以上的SUV才能进。 缆车直接坐车到下板寺，海拔已经2700米，一下车，大家就感觉冷，而且开始有点高原反应了，由于缆车最后一趟是下午5点，我们只有10几分钟，赶紧买了缆车票，乘坐缆车。 小鸟独立枝头，此处已经3000米了，我们多想像飞翔的小鸟，这才叫傲世。 缆车上已经可以看到上板寺, 已经是云雾缭绕，高山的冷松 回望远处的山，我们已经与云同高，坐在缆车里感觉真的是冲上云霄。 下了缆车，兄弟们先合个影 天圆地方在往上走40分钟左右，差不多到天圆地方，凌空玻璃， 我们有个兄弟害怕，不赶上去，拉都拉不上去，奇怪的是后来他还到了拔仙台。 佛光继续往上走，云雾越来越近 突然，我们杨同学大喊一声: “看，佛光”，我们都停下来欣赏佛光，之前只听过，而且一直半信半疑，今天真的亲眼看见了。 中国南北分界岭继续往上走，就进入中国南北分界岭，中间有一个外事检查站，老外是不能进去的，我不明白这是为什么，难道因为军事机密？ 又见神奇佛光，每个人看到的中间的影子都是自己，你动他也动，你走他也走，真实佛在心中，佛就是你自己。 太白自然保护区往前走几步，就到了太白自然保护区，又见佛光。 夜宿小文公晚上7点多，终于到了小文公，听说到大文公需要两个小时，所以我们决定在小文公住，60元一个床，我们6个人买了4张床。 床是硬板床，被子也比较薄，安顿好后。此时已经感觉到比较冷了。 来时的路 山里的云海 大家已经感觉到很冷了，开始做俯卧撑。 由于高原反应，大家基本上都头疼，基本上一晚上没怎么睡着，还有人打呼噜，迷迷糊糊最后可能只睡了两个小时吧。 日出早上5点半我们准备出发，我们决定在去大文公的路上看日出，早上看到的群山真的很漂亮，随着太阳的升起，每一分钟都不一样，从水墨画到山水画，任何大片都拍不出自然的本身，任何画家也画不出这么漂亮的山水，我驻足看了很久，心想，学画的要画山水，就应该在此住一段时间。 日出江花红胜火，日出的过程大概就2分钟，真的是很漂亮。 欣赏图吧，很遗憾没带单反，用我的iPhone 5S拍的。 去往大文公路上已经可以看到太白山顶，拔仙绝顶，但是想不到的是到那里比我们想像的时间长很多。 大文公我们走了将近2小时，才到大文公，中间的路基本上都是石头路，不太好走，我们有2个人太慢了，可能是高原反应，我们走到大文公就留下了杨同学等另外的2个人。 我背的装备比较多，睡袋，急救包，野外小工具箱，我在这里都拿出来交给杨同学了，杨同学在这里等另外两个同事。说在此等我们三个人回来。 大爷海很多人走到大文公就返回了，因为去大爷海要先爬一段山，从小文公到大文公很多人已经走的很累了。 真正的高山杜鹃。 驴友的尼玛堆 走了将近2个小时，终于到了大爷海，这段路是很难走的，先上山，然后下山，建议没有爬山经验的就不要去了，尤其是如果下雨下雪，路都基本走不成。 大爷海 六个人，到这里就三个人。 拔仙台从大爷海去拔仙台，有两条路，左边的路比较陡峭，但是大概20多分钟就到了，右边比较平坦，但是要将近1个小时，于是我们选择的耗时较短的路。 山上还有些积雪没化 上山的路，全都是石头上走 拔仙台不远了 回望来时的路 马上到山顶了 往下看大爷海 已经到拔仙台，可以看到来时走的路都在3500米高的山顶，婉如一条丝带。 拔仙绝顶，一览众山小， 我想化作苍鹰，展翅翱翔！ 我们三个人留下脚印 回来的时候，我们选择了走平坦的路，因为上山时基本都是手脚并用。 二爷海和三爷海 返程回来的时候，我们两个同事明显感觉很累了，但是我看到乌云一来，就加快了脚步，我们返回大文公时，我们等着的同事已经走了，所以我们就一路不停的一直走会缆车，当我们到达缆车时已经是下午2点多了，至此我们已经来回共走了9个小时。我们回来时比同事预计的快了2个小时，主要是下山，高原反应没那么严重了。 到上板寺寺时，很多人问我们他们今天能否到拔仙台，我估计问这话的人，明天都到不了了，因为完全没有准备，还有一些女的就穿着短裙，问还有多远，我说你们还是回吧，不然就冻死了，她们能到小文公就不错了。接下来，就是座缆车，座大巴2小时，然后我们就开车返回西安了，回来时由于太累，基本上一路高速都没赶超过90km/h. 附录要去太白山，而且要登顶的人，必须计划两天时间，而且要带冲锋衣，山上很冷，一定要带登山杖，要穿比较好的登山鞋。带些高热量的食物，如果高原反应严重的最好带点药。山上天气瞬息万变，最好带上防雨的装备，同时带上高能量食物和水，山上也有卖食物和水的，但是你要带钱。 建议在小文公住。","link":"/2015/06/15/life-travel-2011-6-15-climb-mountain/"},{"title":"领域驱动设计系列（一）:为何要领域驱动设计？","text":"前言领域驱动设计最近貌似开始火起来了，越来越多的人开始认识到领域设计的重要性，从我做过的项目来看，似乎欧洲已经有很多的公司开始实施领域驱动设计了，我看领域驱动设计也有些时间了，但是网上不管是文章还是代码，都显得太过“高大上”，一谈领域驱动设计，一大堆的概念一股脑的给你上上来，搞的有点晕头转向，而我想在一些中小项目实施领域驱动也遇到了不小的障碍，大家对很多东西都处于一种恐惧的状态，而且在正真开始实施时，也遇到一些疑问，所以也想和大家交流学习，因此开始在此写写对领域驱动的理解，后面会有一些轻量的演进代码。 为何要领域驱动设计？简化数据存储领域驱动设计有很多原因，谈到我为啥要在公司推行领域驱动设计，说起来还是很好玩的，因为原来基于数据驱动的开发方式，也就是传统的多层开发架构，大家定义了一堆DAL来操作数据, 在.Net大家一般有两种使用方式，一种是用ORM像Entity Framework, 另一种想使用Dapper这样轻量级的Mapping工具，这些都要把关系型数据转换为对象。结果导致以下几种结果。 没有正确的使用ORM, 导致数据加载过多，导致系统性能很差。 为了解决性能问题，就不加载一些导航属性，但是确保DB Entity返回上层，这样对象的一些属性为空，上层使用这个数据时根本不知道什么时间这个属性是有值的，这个是很丑陋的是不是？ 如是又开始使用一些轻量级的数据方法，比如使用Dapper然后自己写SQL语句，这本来是很不错的方式，但是大部分人的SQL能力实在不敢恭维，大部分写出来的SQL语句，甚至比EnityFramework生成的语句还差。 所以，我就想我们做项目，大部分处理的应该是因为，如何让程序员从数据存储，模型转换的大泥潭里解放出来，领域驱动设计就进入了我的实现，当然但从数据这个角度还不足以选择领域驱动设计，用一个NoSQL数据库是不是就解决了？ 但是NoSQL也有一些问题，比如MongoDB如何更优雅的保证事务以及数据的一致性等。 更多了解上下文我们很多软件的问题，大家都知道是需求的问题，也就是客户的需求我们很难理解准确，导致程序员更加关注”HOW” 而忽略了”WHAT”, 最终做了几个礼拜甚至更长时间，结果客户会说:”What?! I told you”, 但是客户告诉我的，我们理解是不一样的。比如客户说：“ Great job, I love you!” 这个Love肯定不是男女之间的Love, 我们拿到的是一个客户的需求，他的上下文是什么？ 比如说：“这个球打的好”， 如果是在打篮球，肯定说的事篮球，如果是在打乒乓球肯定说的是乒乓球。 而领域驱动设计里我们可以让业务人员更多的参与系统，更早的参与系统。 统一语言(Ubiquitous Language)业务人员和我们使用一样的语言，我们的程序比如让业务尽量集中在领域里，比如在传统的数据驱动里，如果说Jack爱Rose, 我们一般会这么写 1UserService.Love(Jack, Rose) 但是我们业务人员很奇怪谁Love谁？ 为什么要UserService?, 如果我们写成下面这样 1Jack.Love(Rose) 还有如果我们用 1Company.hire(employee) 来代替 1companyservice.hire(company,employee) 这样我们就更容易让业务人员参与进来，而且代码可以更易于表示真实的业务场景。","link":"/2015/02/10/technologies-DDD-2015-2-10-why-ddd/"},{"title":"领域驱动设计系列（二）:领域Model？","text":"前言领域驱动设计里有很多东西，我们可以应用在各种各样的开发模式里，所以接下来说的一些东西，我们可以部分使用。 说道领域驱动的领域，大家肯定就要开始说Bounded Context,聚合，聚合根，容易让大家搞糊涂。 我觉得先抛开这些概念，后面再来说如何设计聚合，先简单来说。 模型过去，我们在多层设计里定义了很多Model, 数据库的Model(DB Entity), 然后为了不依赖数据库，我们有设计了业务的Domain Model, 同时我们又设计了ViewModel, 这样一般也没什么问题，职责也很清晰。但是有几个问题 我们要做很多的模型转换，转入转出。当然我们可以用AutoMapper来但是AutoMapper的性能实在难以恭维，大家可以在网上搜索AutoMapper performance. 领域模型成了一个单纯的DTO了。 领域模型首先我们要看领域，就是我们尽量把业务聚合到一个领域里，比如我们要做一个功能，可以看到用户每一次的登录日志，那个这个登录日志其实就是属于用户这个领域里。 其次我们看模型，原来我们的模型都是只有属性，也就是贫血模型，贫血的意思就是没有行为，像木乃伊一样，但是实际上领域是我们要完成业务的最主要的地方，我们希望领域能够自制，也就是领域自己管理自己。 示例比如有一个Employee, 他的状态有Active, Pending, DeActive, 业务上是Pending只能改为Active. 1234567public class Employee : Entity{ public Name Name { get; set; } public EmployeeStatus EmployeeStatus { get; set; }}c 如果是贫血的Employee模型，我们往往代码如下 1234567891011121314151617181920212223public class EmployeeService : IEmployeeService{ private readonly IUnitOfWorkFactory _unitOfWorkFactory; private readonly IEmployeeRepository _employeeRepository; public EmployeeService(IUnitOfWorkFactory unitOfWorkFactory, IEmployeeRepository employeeRepository) { _unitOfWorkFactory = unitOfWorkFactory; _employeeRepository = employeeRepository; } public void ChangeStatus(EmployeeStatus status, Guid employeeId) { using (var unitOfWork = _unitOfWorkFactory.GetCurrentUnitOfWork()) { var employee = _employeeRepository.GetById(employeeId); employee.EmployeeStatus = status; unitOfWork.Commit(); } }} 但是上面的代码的问题就是领域没有自治，本来修改我的状态是我的事，你能不能修改，外面随意修改我的状态是很危险的，比如Pending状态只能改为Active状态。 所以如果不是贫血的模型，我们代码就会这样，让领域自己来管理 123456public class Employee : Entity{ public UserId UserId { get; private set; } public EmployeeStatus EmployeeStatus { get; private set; } 1234567891011121314151617181920212223242526272829303132333435 public void ChangeStatus(EmployeeStatus status) { if (this.EmployeeStatus == EmployeeStatus.Pending &amp;&amp; status != EmployeeStatus.Active) { throw new Exception(&quot;Only can Active when status is pending&quot;); } this.EmployeeStatus = status; }}public class EmployeeService : IEmployeeService{ private readonly IUnitOfWorkFactory _unitOfWorkFactory; private readonly IEmployeeRepository _employeeRepository; public EmployeeService(IUnitOfWorkFactory unitOfWorkFactory, IEmployeeRepository employeeRepository) { _unitOfWorkFactory = unitOfWorkFactory; _employeeRepository = employeeRepository; } public void ChangeStatus(EmployeeStatus status, Guid employeeId) { using (var unitOfWork = _unitOfWorkFactory.GetCurrentUnitOfWork()) { var employee = _employeeRepository.GetById(employeeId); employee.ChangeStatus(status); unitOfWork.Commit(); } }} 因此可以看出，我们把业务代码尽量写在领域里让领域自治。 后记其实领域驱动设计最难的就是设计领域(Domain), 也就是后面会说到的AggregateRoot 聚合，但是我想我们先让领域不再贫血，这样在传统的多层设计，数据驱动等架构都可以使用这种模式。","link":"/2015/02/11/technologies-DDD-2015-2-11-domainmodel/"},{"title":"领域驱动设计系列（三）:事件驱动上","text":"前言今天讲一下事件驱动，这个不是领域驱动设计里的事件源(Event Source), 这个以后再讲，今天主要讲一下如何用事件来解耦，主要的原因是我们有个项目有个功能我觉得用事件的方式比较好，正好写篇博客，就不用专门给他们讲了。 解耦说到解耦，我们很熟悉分层设计，比如上层依赖于抽象，不依赖于具体的实现。比如一个类使用另一个类，我们使用接口而不直接使用实现类。 12345public EquipmentService(IEmailService emailService, IEquipmentRepository equipmentRepository) { _emailService = emailService; _equipmentRepository = equipmentRepository; } 为何用事件？SRP （单一职责)比如我们一个会议室预定系统，我们的一个设备坏了。我们需要通知预定这个会议室的所有人。于是我们需要发邮件。 伪代码如下 12345678910111213141516171819public class EquipmentService{ private readonly IEmailService _emailService; private readonly IEquipmentRepository _equipmentRepository; public EquipmentService(IEmailService emailService, IEquipmentRepository equipmentRepository) { _emailService = emailService; _equipmentRepository = equipmentRepository; } public void SetEquipmentBroken(string Id) { var equipment = _equipmentRepository.GetById(Id); equipment.DeActive(); _emailService.SendEmail(); }} 但是，问题来了，如果后来我们要说，如果设备坏了，我们要更改可用库存的数量，这时候我们是不是要在这里修改代码而引入IInventoryService? 后来如果经理说设备坏了你们尽然不告诉我，你们要闹哪样？这个时候我们是不是要修改代码引入ISMSService.Info(Manager)? 即使我们不考虑OCP原则，不考虑单一职责，我们程序员也会哭，我就DeActive一个设备，你要我做这么多事，我哪里清楚所有的功能？我就骂过程序员，你做这个功能呢为什么没考虑全！！！漏掉了这么重要的功能。 而问题，程序员从来没考虑全过，因此我就想办法如何解决这个程序员不仔细的问题。 事件驱动因为我熟悉iOS的开发，我就想到了iOS的Notification Center. 那我我DeActive一个设备，我就只DeActive这个设备，很SRP是不是？ 但是别的地方如何拿到通知？ 于是事件就自然的付出水面了。如果设备被DeActive了，程序就只需要喊一声，老子把设备DeActive了，你们要闹哪样你们自己看着办，代码如下。 12345678public void SetEquipmentBroken(string Id) { var equipment = _equipmentRepository.GetById(Id); equipment.DeActive(); EventBus.Publish(new EquipmentDeActivedEvent {Id = equipment.Id}); } 这样，通知会议室预定者的模块去通知，给老板发短信的模块就通知老板就OK了。 总结这里我们先将事件驱动，下一篇展示如何实现同步的事件，以后转换为异步那也很容易，让多个接受者处理这个事件，接受者可以是动态的哦，以后老板娘也想知道的话，代码也不用改的亲，好，我先去写实现代码去！","link":"/2015/02/11/technologies-DDD-2015-2-11-eventdriven1/"},{"title":"领域驱动设计系列 (四)：事件驱动下","text":"前言上一篇说到为什么要使用事件驱动，但是只有概念是不够的，我们要代码呀！记得脸书的老总说过: “Talk is cheap, Show me the code!” 实现思路发出事件事件顾名思义就是一件事情发生了，比如我要上头条，这不是一个事件，这事一个Command, HeadCommand, 而我上头条了这就是一个事件HeadedEvent，事件就是一件事情已经发生了。 好，先来一个伪代码 1234567public void Head() { var NewsPaper = new NewsPaper(&quot;南都娱乐&quot;); NewsPaper.WriteToHeader(&quot;汪峰&quot;); RaiseEvent(new HeadedEvent {Name = &quot;汪峰&quot;}); } 所以我们只需在代码里RaiseEvent就可以了。 那么如何订阅事件其实很简单，因为我们要实现的是同步的事件，我们只需要找到所有处理这个事件的实现类，然后调用所有就可以了。 123456789public interface IEventHandler&lt;TEvent&gt; where TEvent : Event{ void Handle(TEvent e);}public class HeadedEvent:Event{ public string Name { get; set; }} 如果国际章的妈妈关注这个Event, 我们就实现一个GuoJiZhangMotherEventHandler 1234567public class GuoJiZhangMotherEventHandler : IEventHandler&lt;HeadedEvent&gt;{ public void Handle(HeadedEvent e) { Console.WriteLine(e.Name+&quot;, Are you kidding me?&quot;); }} 如果我等屁民也关心这个事件的话，我们只需要再实现一个 PiMingEventHandler 1234567public class PiMingEventHandler:IEventHandler&lt;HeadedEvent&gt;{ public void Handle(HeadedEvent e) { Console.WriteLine(e.Name+&quot;, Guo Ji Zhang is your last wife?&quot;); }} 看，我们可以任意增加关注事件的代码，不用修改原来的代码吧，说好的OCP没骗你吧？ 那么问题来了，发出事件的人和接受事件的人怎么联系上的？在现实世界中，我们都是订阅报纸来看头条知道的，但是代码里我们就需要一个协调者了。如是我们就需要一个EventBus, 直接上代码吧 123456789101112public void Head(){ var NewsPaper = new NewsPaper(&quot;南都娱乐&quot;); NewsPaper.WriteToHeader(&quot;汪峰&quot;); RaiseEvent(new HeadedEvent {Name = &quot;汪峰&quot;});}private void RaiseEvent(HeadedEvent headedEvent){ EventBus.Publish&lt;HeadedEvent&gt;(new HeadedEvent { Name = &quot;汪峰&quot; });} EventBus找出所有Handle这个事件的实现类，调用对应的Handle方法，我们可以通过Castle或者任何注入框架轻易的实现 1234567891011public class EventBus{ public static void Publish&lt;T&gt;(T concreteEvent) where T: Event { var handlers = _container.ResolveAll&lt;IEventHandler&lt;T&gt;&gt;(); foreach (var handle in handlers) { handle.Handle(concreteEvent); } }} 好了，哥只负责帮汪老师上头条，上完我发出了事件通知，谁关注谁自己处理去，我的代码也不用改。 我代码实现完了，如果各位还不知道如何实现一个同步的事件驱动架构，那拜托你们找个漂亮的妹子来问我。事件驱动架构我就只能帮你到这里了。","link":"/2015/02/11/technologies-DDD-2015-2-11-eventdriven2/"},{"title":"领域驱动设计系列（五）:事件驱动之异步事件","text":"前言上一篇讲了事件，以及为什么要使用事件，主要是为了解耦，但是有同学就问了，同步如果订阅事件的人太多，比如13亿人都关心上头条的事，那么RaiseEvent得等13亿人都处理完，那得多久呀，从此再也不敢发事件了。举个例子，你在网上下单，下完单要通知库房，甚至要通知供应商补货，如果都是同步的话，消费者还不等急死呀，实际上你在电商网站上下个单， 一般你很快就能到订单页面，那个页面告诉你：“兄弟，订单已经创建成功，订单号是xxxxx-xxxxx-xxxx-xxxx,你的订单已经提交到库房” 等。然后你就很快了的下另一单了。好吧，提问的同学，说好的妹子呢？ 实现思路发出事件123456789101112 public void Head() { var NewsPaper = new NewsPaper(&quot;南都娱乐&quot;); NewsPaper.WriteToHeader(&quot;汪峰&quot;); RaiseEvent(new HeadedEvent {Name = &quot;汪峰&quot;}); }private void RaiseEvent(HeadedEvent headedEvent) { EventBus.Publish&lt;HeadedEvent&gt;(new HeadedEvent { Name = &quot;汪峰&quot; }); } 所以我们只需在代码里RaiseEvent就可以了。 订阅事件其实很简单，因为我们要实现的是同步的事件，我们只需要找到所有处理这个事件的实现类，然后调用所有就可以了。 12345678910111213141516171819202122232425public interface IEventHandler&lt;TEvent&gt; where TEvent : Event{ void Handle(TEvent e);}public class HeadedEvent:Event{ public string Name { get; set; }}public class GuoJiZhangMotherEventHandler : IEventHandler&lt;HeadedEvent&gt;{ public void Handle(HeadedEvent e) { Console.WriteLine(e.Name+&quot;, Are you kidding me?&quot;); }}public class PiMingEventHandler:IEventHandler&lt;HeadedEvent&gt;{ public void Handle(HeadedEvent e) { Console.WriteLine(e.Name+&quot;, Guo Ji Zhang is your last wife?&quot;); }} 我们可以看到正真的事件协调者是EventBus, 之前的代码如下是同步的。 1234567891011public class EventBus{ public static void Publish&lt;T&gt;(T concreteEvent) where T: Event { var handlers = _container.ResolveAll&lt;IEventHandler&lt;T&gt;&gt;(); foreach (var handle in handlers) { handle.Handle(concreteEvent); } }} 为了提高性能，我们可以先来第一步改进 1234567public void Publish&lt;T&gt;(T @event) where T : Event{ var handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;(); handlers.AsParallel().ForAll((h)=&gt; h.Handle(@event)); } 我们可以看到，现在并行处理可以大大加快速度，但是有两个问题，第一个问题就是没有处理异常，所以让我们加上异常。 12345678910111213141516171819202122 public void Publish&lt;T&gt;(T @event) where T : Event { var handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;(); handlers.AsParallel().ForAll((h)=&gt; HandleEvent&lt;T&gt;(h,@event)); } private void HandleEvent&lt;T&gt;(IEventHandler&lt;T&gt; handle, T @event) where T : Event { try { handle.Handle(@event); } catch (Exception e) { // Log the exception, as the caller don't care this } }} 第二个问题，就是我们虽然用了并行加快了速度，但是还没有正真实现异步，整个程序还是等所有Handler处理完才返回。 1234567public void Publish&lt;T&gt;(T @event) where T : Event { var handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;(); handlers.Select(h =&gt; Task.Factory.StartNew(() =&gt; HandleEvent&lt;T&gt;(h, @event))); } 这段代码执行完，尽然发现Handler没有执行，好吧，原因是IQueryable的延迟执行，所以我们需要调用一下ToList 1234567public void Publish&lt;T&gt;(T @event) where T : Event { var handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;(); handlers.Select(h =&gt; Task.Factory.StartNew(() =&gt; HandleEvent&lt;T&gt;(h, @event))).ToArray(); } 好了，我们就这样轻易的实现了一个AsyncEventBus, 是不是感谢.Net的强大? 总结这里还只是一个系统内部的Async, 如果涉及到系统之间的交互，这个就不行了，而且如果异步处理有错误，我们就会有信息丢失，所以需要更健壮的异步事件处理系统，这个后面再讲，但是一般的系统我们只需要把出错的时间记录下来，然后再看要不要处理就可以。 另外，异步要处理的东西很多，比如处理完毕后，如何通知用户，还是让用户刷新？ 我个人建议，一般情况下都不要用异步，只有在真的需要的时候再用。","link":"/2015/02/12/technologies-DDD-2015-2-12-eventdriven-asyncevent/"},{"title":"领域驱动设计系列（六）:CQRS","text":"img { max-width: 600px; border: solid 1px gray; border-radius: 5px; padding: 5px; } CQRS是Command Query Responsibility Seperation（命令查询职责分离）的缩写。 世上很多事情都比较复杂，但是我们只要进行一些简单的分类后，那么事情就简单了很多，比如我们把人分为男人和女人，也可以把人分为大人和小孩，还比如，我们说国内和国外，城市和农村。经过一些类似这样的划分，我们的对不同的类就有不同的关注。 这样我们就会有妇女儿童医院专门让女人生孩子，而不会建一个医院让男女都生孩子。 ##CRUD CRUD (Create, Read, Update, Delete) 增查改删，我们很多系统都是对数据的增查改删。过去我们很多系统比较简单，基本上增加的数据就是你要查询的数据，所以很多时候其实一个简单的Excel就能搞定。 而且增删改查也足够的简单，所以我们很多系统分层后在数据层Repository里仍是对单表的增删改查，这样对不少的系统都符合。 但是，系统规模稍微大一点，我们都知道我们的数据库里的数据模型很难和我们业务层需要的模型一致。 于是我们引入了Domain Model, Repository里就会做Domain Model的来回转换 同时我们在UI层要的数据，往往又和具体的Domain不同，这个时候我们又要定义一个ViewModel. 而这些ViewModel又是组合不同的DomainModel得来。 传统的代码里的问题： 领域里有很多分页和排序，尤其是Repository里 查询的方法里暴露了很多不应该有的领域模型的属性，因为需要组装DTO 如果使用ORM，预加载了很多数据以提高性能，但是占用大量内存，而且需要维护这些数据。 加载组合庞大的数据，比如页面是需要一个名字，我们也会把整个User数据取出来。 重要的原来把数据混在一起，复杂的查询相当难以优化。 尤其是数据库出现大量的Join 系统性能极速下降。 最重要的是我们把读写都放在了一起，显得责任不够清晰，代码也更复杂了一些，比如读数据是不太关心事物的，读数据是不需要验证的，只有写的时候才需要做数据校验，这也比较符合SRP(单一职责)，但是用CRUD的思维是我们全都混在了一起。 CQRS我们仔细看CRUD, 其实可以更简单的分为读(R)和写(CUD), 我们想想大部分情况都是，一个方法要么是执行一个Command完成一个动作，要么就是查询返回数据。 比如我们回答问题的人不应该去修改问题。 当我们读写分离后，我们对应的代码也会分离。 数据存储写的一端需要保证事物，所以一般数据存储为第三范式,读的一端一般都是反范式可以避免Join操作，这样我们只需要把数据存储为第一范式 扩展大部分的系统里写数据要远远少于读数据，并且一般都是每次修改很少的一部分数据，所以在写这端扩展都不是特别紧迫，读数据基本都远大于写数据的次数， 所以扩展就更重要。 我们很难建立同一个Model 既能给写数据和读数据公用而且能够保证性能都比较好的。 查询端查询端由于只是读数据，那么所有的方法应该都是返回数据，而且返回的数据就是界面直接需要的DTO, 这样可以减少传统的方法中把DomainModel映射为ViewModel或者DTO. 同时可以减少传统的领域里的一些混乱。 写端由于把读分离出去，所以我们就只关注写，那么我们写这一段需要保证事物，数据输入的验证，另外一般写这一端都不需要及时的看到结果，所以大部分都需要一个void方法就可以，那么让我们系统异步就更加方便。这样使系统的扩展性大大增强。 代码更容易集中处理当我在一些系统中使用CQRS后，很多地方代码大大简化，比如我所有的写操作都是一个Command, 那么我定义一个UICommand, 让所有的Command集成这个，那么我可以在这个UICommand里做一些通用的处理，比如Validation 同时我只需要定义一个CommandBus, 然后把对应的CommandBus分发到对应的Handler里（我前面几篇有实例代码），那么代码的耦合度大大降低。 代码分工协作更容易由于读这一端直接读数据，而且对数据库没有任何操作，那么我们可以根据UI定义对应的DTO, 那么开发的时候我们可以用Mock数据，至于数据怎么存的，那么我们随后只要添加一层Thin Data Layer即可，实际上当我们使用CQRS后，很多时候我们把数据保存的时候都直接保存为Denormalize的，那么从数据里直接查询单表的数据就可以拿到页面需要的数据，大大提升读取数据的性能，同时代码也会极其的简化，开发读这一段代码的开发人员甚至都不需要对业务有太多了解。 实现简单的实现 使用的Event后 使用了Event Source 和Service bus后","link":"/2015/06/04/technologies-DDD-2015-6-5-cqrs/"},{"title":"领域驱动设计系列（七）:领域驱动开发实践之路:我们如何从领域驱动开发当中获益","text":"领域驱动设计，遇见你之前我们公司推行和实践敏捷已经很多年了，SCRUM已经成功应用于大部分项目，得益与业界敏捷开发大师以及国内很多优秀工程师的分享和宣传，我们使用了很多优秀的软件开发实践，比如测试驱动开发(TDD)，行为驱动开发(BDD), 持续集成(CI)等等为我们带来了很多收益。由于我们公司以做项目为主，虽然这些软件实践确实能很好的提高软件交付质量和效率，但是要想用好这些实践，涉及到的因素很多，常见的如下： Scrum里需要Product Owner, 客户方很少能有一个比较符合Scrum里提到的Product Owner来定义需求为As a role I want to do something so that I can get some benefit. 行为驱动开发BDD对客户方要求更高，客户需要写Specific, Scenaro, Given…When…Then. 我做过一个项目，客户开始写BDD,而且也能写出比较高质量的BDD, 但是客户后来就不写了，觉得写的麻烦。 我们主要使用.NET，虽然大家都熟悉面向对象，熟悉类，接口，继承，封装等等，但是面对一个项目的时候，如何对业务就行合适的抽象，正确使用面向对象依然是非常大的挑战。 由于使用敏捷，不再像之前传统开发过程中有详细的需求说明书（假定那个需求说明书及时更新，且描述准确易于理解), 强调的是可工作的软件，但是很多业务逻辑很难通过界面来体现，虽然有User story, 但是就像第一步PO很难写出符合SMART原则的用户故事，常出现的情况，就是PO说一个需求的大意，程序员就“秒懂”了，最后也确实开发出了经过验收测试的软件，但是因为有测试和Feedback的修复，这一类的需求就“丢失”了。 人员变动，软件行业成员变动是很正常的现象，但是很多小团队一个萝卜一个坑，如果没有好的方法，项目的相关context就丢失了，且不说有的人走的时候没有心思做交接，就算想好好做交接，也只能是最大程度减少项目相关内容不能很好传递。 几年前，当我开始做分公司的时候，刚开始我一直在致力于敏捷的推行，好的软件开发实践的实践，很多同事的软件技能大幅提升，比如熟悉了很多Clean Code的东西，单元测试的重要性和好处，持续集成，Gitflow等的好处。但是有几个问题一直是我在考虑的问题 如何减少客户反馈的bug, 虽然敏捷强调客户频繁互动和反馈来让错误无限靠近开发的时间，但是能把事情一次做对而不是多次改对依然能大幅提高项目提交速度，也就节省了客户的成本，提高了开发程序员的效率。 人员变更时候的知识传递，虽然清晰的软件架构，整洁的代码，高的单元测试覆盖率能大幅加快新的人员理解项目的速度，但是看用户故事，单元测试以及散落在很多类中的代码（单一职责的时候，我们会有大量类，注意：这里不是说不要单一职责）对中途加入项目的人依然是需要较长时间熟悉项目和代码。 提高开发人员软件技能，提高开发效率从而提高对客户的产出，然后开发人员的薪水自然能有对应的提升是做为一个分公司负责人的第一责任，员工第一嘛！另一个方面，我认为相对简单的项目，比如一些CRUD项目，一些前端项目比如Angular/React的项目越来越没有竞争力。（注：这里并没有任何贬低前端的意思，只是说直接使用已有的这些框架门槛并不是非常高), 我们必须去接一些”不好做”的项目，也就是业务复杂，需求复杂类的，这类项目才能提升程序员的能力而且报价相对较高。 追求软件卓越，原来，我一直强调质量和效率的重要性，但是大家很难理解和应用，突然有一天，我想到（也许从别的地方看到的），软件最重要的是要解决两个问题： 做正确的事情 (Do Right Thing) 把事情做正确 (Do Thing Right) 初遇领域驱动设计做正确的事情 (Do Right Thing) 把事情做正确 (Do Thing Right) 一直在我脑海里，然后简单的CRUD项目越来越没竞争力，程序员的报价难以提高，自然薪水就会有瓶颈，而我也想解决这样的问题，突然有一天我看到了另一句话：我选择做这件事，不是因为他简单，而是因为他难，这句话对我触动很大。我的脑海里就一直萦绕着“简单”，“复杂”，“麻烦”， 于是我要做的事情就是下面三个: 做正确的事情 (Do Right Thing) 把事情做正确 (Do Thing Right) 做难的事情 (Do Hard Thing) 我就在网上搜索Complex, Software 等，一本叫做Domain Driven Design的这本书出现在我面前，Domain Driven Design这个词语早就听说过，但是更吸引我的是副标题 “Tackling complexity in the heart of software”, 我就大概看了一下书，里面的战略设计正好提供了解决复杂业务的方法，统一语言，Bounded Context, 界限上下文，设计就是代码，代码就是设计等等。 我相信这正是解决 做难的事情，做正确的事情 但是对战略有些了解，怎么去实现呢？一直没有一个好的例子来帮助大家如何使用领域驱动设计，直到一本《实现领域驱动设计》这本书的出现，才真的让我们有了打通任督二脉的机会。 实践领域驱动设计有了《领域驱动设计》和《实现领域驱动设计》两大神器，也只是向美女要了个联系方式和家庭住址而已，中间还隔了一个漫长的日落和日出，没有正式的项目，我们永远是在岸上游泳，虽然我们也在项目里开始或多或少使用了领域的一些概念，但是我们应该知道基于数据驱动(Database Driven) 是很难成功应用领域驱动设计的。正好这个时候公司来了一个项目（客户是Fortune Global 500), 他们的架构师指定要求使用领域驱动设计，这让我非常兴奋，让我们有机会对复杂业务进行领域驱动开发的实践。 就像实现领域驱动力说的一样，领域驱动主要有两大块儿战略设计和战术设计。 战略设计 (Do Right Things)Ubiquitous language领域驱动开发让业务专家(Domain Expert)和开发人员一起来梳理业务，而双方有效沟通的方式是使用通用语言，在这个项目里，一开始我们就定义了很多词汇表, 就是我们自己的通用语言。 Bounded Context 和 Domain有了通用语言，词汇表 每一个词汇一定是有边界的，不同的边界内是不一样，比如你爱人在你家这个Bounded Context是你的Wife, 但是如果她是一个老师，那么在学校这个边界里就是一个Teacher. 我们经过多次讨论，采取的方法是拆成多个子系统（Bounded Context,是不是很像现在的微服务？)，每个子系统进行自治。 随后我们把一个个业务抽象为领域对象(Domain Model), 每一个Domain对领域进行自治。而模型里的属性和行为表达为业务专家都可以理解的代码，用比如Job.Publish(). 虽然这里面最终产生了聚合根、实体、值对象等，但是我们和业务专家沟通的时候尽量不要说这些词汇，比如我们可以说， 在招聘这块儿，职位是不是必须经过公司进行管理，那样我们就知道 Job是属于公司这个聚合根。 对领域进行“通用”（类名，方法名等都用自然语言表达）建模，业务人员可以直接读懂我们的代码，从而可以知道是否表达了业务需求。 战术设计 (Do Things Right)在战术设计方面，由于业务行为和规则都在领域里，而且系统被拆分成多个子系统，这对技术实现上带来了非常大的挑战，尤其是大部分人都是有牢固的基于数据驱动开发的思想。 技术上有不同实现方式，但是一开始我们选择了“最佳实践”(实现领域驱动设计)，也就是使用了Event Source和CQRS, 但是这条路是陡峭的。 Event SourcingEvent Sourcing 就是我们不记录数据的最终状态，我们记录对数据的每一次改变(Event)，而读取的时候我们把这些改变从头再来一遍来取得数据状态，比如你有100块钱，现在剩下10块了，我们记录的不是money.total=10, 而是记录你每一次取钱的记录，然后从100块开始一步步重放你取钱的过程，来得到10. 一开始，我们写的过程中，时常回想起数据驱动的好，（每次开始一个新东西的时候，是不是很熟悉的感觉？)，觉得用Event Sourcing各种麻烦，直到后来随着系统的复杂性不断增加，我们才感觉到带来了非常大的好处, 这个随后单独来说。 CQRS由于使用了EventSourcing, 对数据查询，尤其是跨业务(aggregate)的查询非常麻烦，很难像关系数据那样有查询优势，CQRS是解决这一问题非常好的方法，CQRS让查询和写入分开，把界面需要查询的数据进行原样写入，原样的意思就是界面显示什么样的，就提前保存成什么样的，类似于原来的缓存，没有任何join操作，这样查询是非常高效的。 实践领域驱动过程中面临的技术挑战最大的挑战当然是战略设计部分 就是正确的划分Bounded Context和领域建模，这个部分这里难以几句话说清楚，只能多实践，多向大师学习，比如试试Event Storming的方式。 然后，如果团队没有任何领域驱动开发的经验，千万不要低估技术部分的挑战，并不是很多人说的技术部分不重要，如果实现不好，领域驱动很难落地。我们遇到一些典型问题，当然后来都很好的解决。 开发人员认为EventSourcing不重要，比如，原来你要发布一个Job, 你可能只需要改一个属性Job.Status=”Published”, 但是现在你需要定义一个JobPublishedEvent的事件，很多时候一次改变需要定义很多事件，比如CompanyNameChangedEvent, CompanyEmployeeAddeedEvent. 最重要的是事件的粒度如何定义？ 由于根据Bounded Context拆分成一个个子系统，系统之间的交互比较麻烦。原来在一个Controller里直接调用不同的Repository来改变数据的方式就很不适用了。 由于使用CQRS,查询必须要单独保存QueryModel, 这相对传统的数据库驱动的开发方法，写和读都是同一个数据库更加麻烦。 事件的版本管理，比如事件改名，删除和增加都需要考虑重放事件重建领域对象的影响。 CQRS如何保证数据的及时性和一致性，比如我在一个公司详细页面修改了一个公司名字，然后点击保存按钮导航到公司列表页面，这个时候QueryModel可能还没有更新过来，这些如何解决一致性的问题。 领域驱动开发如何让我们和客户共同获益的 做正确的事情(Do Right Things): 领域专家高效的和团队沟通，确保建立了正确的反映业务规则的模型，而开发人员有了直接可以使用的代码，而且可以因为Domain有了数据和行为，非常方便的进行单元测试，因为Domain不依赖第三方的数据存储等，可以确保实现了业务。 大大提高了沟通的效率，我们知道一图胜千言，而对开发人员来说，少废话，Show me the code! 不但代码对程序员更容易读，而且Code（领域对象)就是最新的需求. 可以跑起来的需求。 大大提高新成员进入项目的速度，最主要的是看领域模型以及对领域模型的测试，几乎就知道了系统的所有的业务规则。 领域驱动的技术部分给系统增加功能或扩展带来了极大的遍历，举几个例子： a. 由于使用了事件溯源，我们很容易查询历史数据。我们只需要指定一个时间点，我们重放事件的时候重放到这个时间点就可以了。 b. 操作日志，原来如果我们想记录操作日志我们代码里遍布都是Log, 而现在我们只需要重发事件，想看什么日志就看什么日志，而这些就只需要我们回放数据库存储的事件流就可以了。 c. 系统之间的通信，我们只需要发布事件就可以了，其它系统订阅我们的事件就可以，我们和其它系统之间没有直接依赖。 d. 大大提高了系统增加新功能的方便性，很多时候增加新功能就是订阅事件就可以了。 f. CQRS, Query model极大的提高了系统的查询性能，而且当我需要新的界面的时候，我不需要对写入端代码进行任何修改，包括类文件都不用修改，是不是符合对修改关闭，对扩展开放(OCP)？ 我们只需要建一个类似新的EventHandler，然后重放对应的事件就可以了。 e. 因为使用了事件溯源，系统之间通过事件集成，比如通过消息队列发布和订阅事件，这可以大大增加系统的**抗压能力**，我们可以把事件放入队列，后续处理系统即使不能及时处理也不会让前端系统崩溃。 f. 系统性能大福提高，在写入端只有插入操作，没有修改操作，在读取端只有Read操作，那么何须锁表，何须开启事务？由此一来，输出存储和读取的瓶颈可以大大缓解。 开发人员可以更集中的处理业务，由于一切都是事件，实现玩基础库后，开发人员可以忽略数据存储，大部分时间都是在写业务代码，不关心数据怎么存储，数据存储部分就俩操作 AggregateRoot.Get(id), AggregateRoot.Save(), EventPublish.Pubish(CompanyNameChangedEvent), 而事件订阅端只需要增加一个EventHandler就可以了。 系统很好进行了解耦，业务逻辑集中在领域中，不会像之前的开发里面业务逻辑充斥在很多地方，修改一些功能的时候，不得不如履薄冰，生怕哪里给破坏了，或者哪里没考虑全。 不用过于担心开发人员，尤其初级开发人员不正确的代码遍布系统多个部分，对其它功能的影响可以大大减低，Review代码其实主要Review业务实现的单独的类，不用担心很多技术实现部分不正确，因为基础库写好了，这样可以适当均衡团队成员组成来降低项目开发成本。 最后，系统更加容易修改和增加新功能，不正好支持了敏捷开发的“拥抱变化”吗？ 总结领域驱动开发好处多多，概念比较多，门槛相对较高，对人员要求较高，团队里至少需要有领路人，不然代价会比较大。 尤其慎用Event Sourcing, 而领域驱动尤其适合业务相对复杂的项目。 对那些很小的项目，CRUD仍然是好的选择。 最后，如果你对领域驱动比较感兴趣，欢迎如我联系wangdeshui@outlook.com","link":"/2017/11/01/technologies-DDD-2017-11-1-ddd-practice-road/"},{"title":"ES6+ 现在就用系列（二)：let 命令","text":"ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。也就是有了块级作用域。 为什么需要块级作用域?避免 var 变量提升带来的副作用示例： 123456789101112131415var saleCount = 20;function f(){ console.log(saleCount); if(saleCount&lt;100) { // according some rule, change it to 100 var saleCount=60; console.log(saleCount); } }f() 输出: // undefined 因为 “var saleCount=60;” 作用域是整个函数，而JavaScript里var定义的变量存在变量提升，也就是console.log(saleCount), 这个saleCount是 “var saleCount=60;” 这一句定义的，当调用的时候，saleCount的值是undefined. 实际上等于下面代码。 12345678910111213141516var saleCount = 20;function f(){ var saleCount; console.log(saleCount); if(saleCount&lt;100) { // according some rule, change it to 100 saleCount=60; console.log(saleCount); }}f() // undefined 避免循环变量变为全局变量12345678910示例： for (var i = 0; i &lt; 10; i++){ // do something } console.log(i); 输出: 10很明显，我们不希望i,这个变量变为全局变量。 let 示例代码12345678910'use strict'{ var b=1; let a=2;}console.log(a);console.log(b);# 输出: ReferenceError: a is not defined 上一节我们给出了如下的示例: 1234567891011var a = [];for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[1]();a[2]();a[3]();输出: 10,10,10 我们看到，输出的结果不是我们想要的，因为i是用var定义的，那么他在全局范围内都是生效的，也就是我们循环结束以后，i的值就是10，那么不管调用数组的那个元素，console.log(i) 输出的都是10， 那么let因为有了块级作用域，就可以避免这个问题。 1234567891011var a = [];for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[1]();a[2]();a[3]();输出 1, 2,3 另外，函数本身的作用域也在定义他的块的作用域内。 1234567function hello(){console.log(&quot;Hello, Jack&quot;)};{ function hello(){console.log(&quot;Hello, Tom&quot;)};}hello(); 上面的代码在ES6里面输出了”Hello, Jack”, 而在ES5里输出了”Hello, Tom”. 注意事项不能先使用，后定义123456789console.log(x);console.log(y);var x = 1;let y = 2;# 输出undefinedReferenceError: y is not defined 上面的代码由于x是var定义的，一开始x的变量是存在的，只是值是undefined, 但是由于y 是let定义的，就不存在变量提升。 暂时性死区如果一个变量是使用let定义的，那么这个变量就属于声明时所在的代码块，也就是变量不再受外部影响，下面的a 由于在块里定义了，所以 会报错，因为在那个块里是先使用后定义，如果去掉“let a”, 那么a就是外部的变量，这个时候就不会出错。 12345678var a = &quot;hello&quot;;{ a = 'world'; let a;}// ReferenceError 不能重复申明也就是不能重复申明同一个变量，即使一个是let申明，一个是用var申明也不行。 下面的代码都会报错。 1234function () { let a = 10; var a = 1;} 1234function () { let b = 10; let b = 1;} 总结由于let 避免了很多问题，所以建议在ES6的代码里总是使用let 来替代var. ​","link":"/2016/01/20/technologies-JSNext-2016-1-20-javascript-next-features-let/"},{"title":"ES6+ 现在就用系列（一)：为什么使用ES6+","text":"ES6+现在主流的浏览器都是支持到ES5, 为了表述方便，我在此发明一个名词”ES6+” 就是ES5以后的版本，包括ES6, ES7. 为什么说现在就用，虽然主流的浏览器只支持到ES5, 但是现在有很多的转换器，可以把一些ES6和ES7的代码转换为ES5的代码。这就意味着我们现在就可以使用这些新特性，然后使用转码器让代码可以运行在主流的浏览器上。 为什么立即开始使用ES6, ES7的新特性？JavaScript语言的一些糟糕的实现先不说JavaScript语言本身设计是否有问题，现有JavaScript语言的实现里有很多非常糟糕或者诡异的实现，就是你以为代码的结果是这样，但是他偏偏是那样，这给我们程序带了很多的意向不到的Bug和烦恼，如果你要是JavaScript大牛，你需要了解他内部的实现的Bug, 而且要知道哪些诡异的写法输出了什么诡异的结果，我个人对了解这种东西实在提不起太大的兴趣，因为我只想用“语言”来实现我的项目让人很好的使用我开发的软件，但是由于历史这样或那样的原因，导致JavaScript语言成为浏览器的霸主，我们不得不忍受这些糟糕的问题。下面我来展示一些让你觉得诡异的问题 （如果你不不觉得诡异，恭喜你，你已经是JavaScript的“高手”) 示例1: 12345(function() { return NaN === NaN;})(); 输出: false 示例2: 12345(function() { return (0.1 + 0.2 === 0.3);})();输出: false 示例3: 123[5, 12, 9, 2, 18, 1, 25].sort();输出: [1, 12, 18, 2, 25, 5, 9] 示例4: 1234567891011var a = &quot;1&quot;var b = 2var c = a + b输出：c = &quot;12&quot; var a = &quot;1&quot;var b = 2var c = +a + b输出：c = 3 示例5: 12345(function() { return ['10','10','10','10'].map(parseInt);})();输出: [10, NaN, 2, 3] 示例6: 12345(function() { return 9999999999999999;})();输出: 10000000000000000 示例7: 1234567891011var a = [];for (var i = 0; i &lt; 10; i++) {a[i] = function () { console.log(i);};}a[1](); a[2]();a[3]();输出: 10,10,10 我是觉得如果按正常人的理解，代码不能得到想要的结果，那就算是语言本身的问题。如果一个程序执行的和人期望的不一样，或者还需要一些Hack的方法，那么是很糟糕的。 ES5 一些语言特性的缺失由于上面的很多问题，所以ES 需要不断的改进, 当然新的版本肯定不可能一下子解决之前所有的问题。 已有JavaScript的问题这一块就不细说了，因为能来看这篇文章的人，应该对下面我列的几个突出的问题都有感受。 没有块级作用域，这个导致上面示例7的问题 全局变量的污染 类的写法比较怪异 没有模块管理 异步调用写法容易产生 “回调地狱” 为什么可以立即使用？因为现在很多转换器已经可以把ES6所有的特性以及ES7的部分特性转换为ES5，Babel就是一个非常好的转换器，所以我这里建议凡是能被Babel转换的新特性都可以立即在项目里适用。 ES6和ES7的一些新特性，可以大大提高项目的健壮性，同时让代码更易读，同时也可以避免很多ES5之前的很多诡异的东西。Gulp里可以很好的使用babel, 如果你对Gulp不熟悉，可以参考我博客里的Gulp系列。 这里简单说一Gulp和babel如何结合使用 123456789$ npm install -g gulp-babelvar gulp=require('gulp'), babel=require('gulp-babel');gulp.task('build',function(){ return gulp.src('src/app.js') .pipe(babel()) .pipe(gulp.dest('build')) }) ​后面的系列，我将以此介绍ES6, ES7的一些可以现在就用的主要特性。","link":"/2016/01/20/technologies-JSNext-2016-1-20-javascript-next-features/"},{"title":"ES6+ 现在就用系列（四)：箭头函数 &#x3D;&gt;","text":"箭头函数 =&gt;ES6 允许使用 =&gt; 来定义函数， 他是函数的缩写，这个熟悉C#的人应该了解，这其实就是C#里的lamda表达式 他不只是语法糖 (Syntax sugar), 箭头函数自动绑定 定义此函数作用域的this（Arrow functions automatically bind “this” from the containing scope.） ** 箭头函数没有自己的this，所以内部的this就是外层代码块的this。** 定义格式1(&lt;arguments&gt;) =&gt; &lt;return statement&gt; 当只有一个参数时，括号可省略，下面两种写法是等价的. 12(x) =&gt; x * xx =&gt; x * x 示例代码12345678910111213141516171819202122232425262728293031'use strict';// 数组const items = [1, 2, 3, 4];// lamda 表达式let byTwo = items.map(i =&gt; i * 2);// 可以使用blocklet byFour = items.map(i =&gt; { return i * 2;});// 绑定thisfunction Person() { this.company = &quot;deshui.wang&quot;; this.Names = [&quot;Jack&quot;, &quot;Alex&quot;, &quot;Eric&quot;]; this.print = () =&gt; { return this.Names.map((n) =&gt; { return n + &quot; is from &quot; + &quot;company &quot;+ this.company; }); };}console.log(new Person().print());// 输出:[ 'Jack is from company deshui.wang', 'Alex is from company deshui.wang', 'Eric is from company deshui.wang'] 注意事项 箭头函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象, 原因是箭头函数没有自己的 this. 不可以当作构造函数，不可以使用 new 命令。 不可以使用 arguments 对象，该对象在函数体内不存在。可以用 Rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 arguments、super、new.target 在在箭头函数之中是不存在的，他们指向外层函数的对应变量。 123456789 function hello() { setTimeout( () =&gt; { console.log(&quot;args:&quot;, arguments); },100);} hello( 1, 2, 3, 4 ); // 输出 1, 2, 3, 4 箭头函数没有自己的 this，所以不能用call()、apply()、bind()这些方法去改变 this 的指向。","link":"/2016/01/21/technologies-JSNext-2016-1-21-javascript-next-features-arrow-functions/"},{"title":"ES6+ 现在就用系列（三)：const 命令","text":"本文以及以后讨论的代码，都必须是在严格模式下，因为非严格模式下，有一些写法也符合,所以我们建议代码始终使用严格模式 定义在之前的ES版本里是没有常量的概念的，常量，就是一旦申明，值就不能改变的。 12345'use strict';const PI = 3.1415;console.log(PI) // 3.1415PI = 3; // TypeError: Assignment to constant variable. 特性 一旦申明，必须初始化 作用域只在声明所在的块级，和let相同 123456789101112131415161718 'use strict'; const apiBase = &quot;https://deshui.wang/api/v1/&quot;;const clientId = &quot;123456&quot;; //block scopedif (true) { const apiBase = &quot;https://cnblogs.com/api/&quot;; console.log(apiBase + clientId); // https://cnblogs.com/api/123456} console.log(apiBase+clientId); // https://deshui.wang/api/v1/123456 apiBase = &quot;https://google.com/api&quot;; //Identifier 'apiBase' has already been declared const 申明的变量，在一个作用域内也不能与let和var申明的重名 如果 const 申明的是个复合类型的变量，那么变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变。 12345678 'use strict'; const a = [1, 2]; a.push(3); console.log(a); // 1,2,3 a.length = 0;console.log(a); // [] a = [4]; // TypeError: Assignment to constant variable. 全局变量全局对象是最上层层的对象，在浏览器里指的是window对象，在Node.js指的是global对象。 12345// 'use strict';var a=&quot;hello&quot;;console.log(global.a);// 输出: undefined var 命令和 function 命令声明的全局变量，依旧是全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 上面的代码在Node.js下是不行的，但是浏览器却可以，不管是不是严格模式。 12345// 'use strict';var a=&quot;hello&quot;;console.log(window.a);// 输出: hello 但是，如果使用let, 那么属性将不绑定到window （Chrome developer tools 需要使用以下方法才能打开严格模式) 12345678(function(){ 'use strict' let a=&quot;hello&quot;; console.log(window.a);})()// 输出undefined","link":"/2016/01/21/technologies-JSNext-2016-1-21-javascript-next-features-const/"},{"title":"ES6+ 现在就用系列（六)：解构赋值 (Destructuring )","text":"定义ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） 解构数组在 ES5里我们需要这样赋值 1234567// ES5var point = [1, 2];var x = point[0], y = point[1];console.log(x); // 1console.log(y); // 2 那么在ES6 里我们可以简化为这样 123456// ES6let point = [1, 2];let [x, y] = point;console.log(x); // 1console.log(y); // 2 我们用这个特性很容易交换变量 123456789101112'use strict';let point = [1, 2];let [x, y] = point;console.log(x); // 1console.log(y); // 2// .. and reverse![x, y] = [y, x];console.log(x); // 2console.log(y); // 1 注意： node.js 目前还不支持解构赋值，所以我们可以用babel转换器来转换代码看看输出结果。 另外 babel 6.x以前的版本，默认开启了一些转换，但是 Babel 6.x 没有开启任何转换，我们需要显示地告诉应该转换哪些， 比较方便的方法是使用 preset, 比如 ES2015 Preset, 我们可以按如下方式安装 123456789101112131415161718npm install gulp --save-devnpm install gulp-babel --save-devnpm install babel-preset-es2015 --save-dev// gulpfile.jsvar gulp=require('gulp'), babel=require('gulp-babel');gulp.task('build',function(){ return gulp.src('./test.js') .pipe(babel()) .pipe(gulp.dest('./build')) }) // .babelrc{ &quot;presets&quot;: [&quot;es2015&quot;]} 上面的代码用babel转换器转换后 123456789101112131415'use strict';var point = [1, 2];var x = point[0];var y = point[1];console.log(x); // 1console.log(y); // 2// .. and reverse!var _ref = [y, x];x = _ref[0];y = _ref[1];console.log(x); // 2console.log(y); // 1 解构赋值时，我们可以忽略某些值 1234let threeD = [1, 2, 3];let [a, , c] = threeD;console.log(a); // 1console.log(c); // 3 可以嵌套数组 12345let nested = [1, [2, 3], 4];let [a, [b], d] = nested;console.log(a); // 1console.log(b); // 2console.log(d); // 4 也可以解构赋值Rest变量 123let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4] 如果解构不成功，变量的值就等于undefined。 1234let [x, y, ...z] = ['a'];x // &quot;a&quot;y // undefinedz // [] 解构赋值，赋给 var, let , const 定义的变量都可以 解构对象对象的属性没有次序，变量必须与属性同名，才能取到正确的值 1234567let point = { x: 1, y: 2};let { x, y } = point;console.log(x); // 1console.log(y); // 2 如果变量名与对象属性名不一样，那么必须像下面这样使用。 1234567let point = { x: 1, y: 2};let { x: a, y: b } = point;console.log(a); // 1console.log(b); // 2 支持嵌套对象 12345678910111213let point = {x: 1,y: 2,z: { one: 3, two: 4}};let { x: a, y: b, z: { one: c, two: d } } = point;console.log(a); // 1console.log(b); // 2console.log(c); // 3console.log(d); // 4 混合模式可以嵌套对象和数组 12345678910let mixed = {one: 1,two: 2,values: [3, 4, 5]};let { one: a, two: b, values: [c, , e] } = mixed;console.log(a); // 1console.log(b); // 2console.log(c); // 3console.log(e); // 5 有了解构赋值，我们就可以模拟函数多返回值 123456789101112function mixed () {return { one: 1, two: 2, values: [3, 4, 5]};}let { one: a, two: b, values: [c, , e] } = mixed();console.log(a); // 1console.log(b); // 2console.log(c); // 3console.log(e); // 5 注意，如果我们解构赋值时，忽略var, let, const 那么就会出错因为block不能被解构赋值 1234let point = {x: 1};{ x: a } = point; // throws error 但是，我们赋值时加上 let 或者把整个赋值语句用()括起来就可以了 12345let point = {x: 1};({ x: a } = point);console.log(a); // 1 字符串的解构赋值123456789const [a, b, c, d, e] = 'hello';a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;let {length : len} = 'hello';len // 5 ​ 函数参数的解构赋值12345678function add([x, y]){return x + y;}add([1, 2]) // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b)// [ 3, 7 ] 函数参数也可以使用默认值 12345678function move({x = 0, y = 0} = {}) {return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3}); // [3, 0]move({}); // [0, 0]move(); // [0, 0] 其它特性解构赋值可以有默认值12345var [x = 2] = [];x // 2[x, y = 'b'] = ['a'] // x='a', y='b'[x, y = 'b'] = ['a', undefined] // x='a', y='b' ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。123456function f(){ return 2;}let [x = f()] = [1]; x // 1 上面的代码因为x能取到值，所以函数f不会执行。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError ​上面的最后一行代码 x 用到 y 是, y 还没有声明。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。这个在我们阅读React-Native 相关文章时，下面的写法非常常见。 1let { log, sin, cos } = Math;","link":"/2016/01/21/technologies-JSNext-2016-1-21-javascript-next-features-destructuring-assignment/"},{"title":"ES6+ 现在就用系列（五)：模板字面量 (Template Literals)","text":"模板字面量字符串替换这个和C#6 里面的字符串插值类似。原来ES5里字符串要连接，一般就是用+ 特性 用反引号（`）标识, 它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数。 示例代码:简单字符串替换 1234var name = &quot;Brendan&quot;;console.log(`Yo, ${name}!`);// =&gt; &quot;Yo, Brendan!&quot; 表达式 12345678var a = 10;var b = 10;console.log(`JavaScript first appeared ${a+b} years ago. Crazy!`);//=&gt; JavaScript first appeared 20 years ago. Crazy!console.log(`The number of JS MVC frameworks is ${2 * (a + b)} and not ${10 * (a + b)}.`);//=&gt; The number of JS frameworks is 40 and not 200. 函数 123function fn() { return &quot;I am a result. Rarr&quot;; }console.log(`foo ${fn()} bar`);//=&gt; foo I am a result. Rarr bar. $() 可以使用任何表达式和方法调用 12345678910var user = {name: 'Caitlin Potter'};console.log(`Thanks for getting this into V8, ${user.name.toUpperCase()}.`);// =&gt; &quot;Thanks for getting this into V8, CAITLIN POTTER&quot;;// And another examplevar thing = 'drugs';console.log(`Say no to ${thing}. Although if you're talking to ${thing} you may already be on ${thing}.`);// =&gt; Say no to drugs. Although if you're talking to drugs you may already be on drugs. 示例代码： ES5: 12345678910111213141516'use strict';var customer = { name: &quot;Foo&quot; };var card = { amount: 7, product: &quot;Bar&quot;, unitprice: 42 };var message = &quot;Hello &quot; + customer.name + &quot;,\\n&quot; +&quot;want to buy &quot; + card.amount + &quot; &quot; + card.product + &quot; for\\n&quot; +&quot;a total of &quot; + (card.amount * card.unitprice) + &quot; bucks?&quot;;console.log(message);输出:Hello Foo,want to buy 7 Bar fora total of 294 bucks? ES6: 1234567891011var customer = { name: &quot;Foo&quot; }var card = { amount: 7, product: &quot;Bar&quot;, unitprice: 42 }message = `Hello ${customer.name},want to buy ${card.amount} ${card.product} fora total of ${card.amount * card.unitprice} bucks?`输出:Hello Foo,want to buy 7 Bar fora total of 294 bucks? Tagged Templates (标签模板？不知道如何翻译)比如 1fn`Hello ${you}! You're looking ${adjective} today!` 实际上等于 fn([&quot;Hello &quot;, &quot;! You're looking &quot;, &quot; today!&quot;], you, adjective); fn可以是任何函数名，也就是把字符串分解传到到方法的第一个参数里，第一个参数必须是数组，数组的每一项，就是被$()分开的没一串字符， 每一个$()里面的值将传给函数的剩余参数。等于下面函数定义，strings是一个数组，values是Rest参数。 1fn(strings, ...values) 示例 1234567891011121314var a = 5;var b = 10;function tag(strings, ...values) { console.log(strings[0]); // &quot;Hello &quot; console.log(strings[1]); // &quot; world &quot; console.log(values[0]); // 15 console.log(values[1]); // 50 return &quot;Bazinga!&quot;;}tag`Hello ${ a + b } world ${ a * b }`;// &quot;Bazinga!&quot; 有了 tagged template 我们可以让代码看起来更简洁，比如我们可以把下面的调用 1get([ &quot;http://example.com/foo?bar=&quot;, &quot;&amp;quux=&quot;, &quot;&quot; ],bar + baz, quux); 用新的写法 1get`http://example.com/foo?bar=${bar + baz}&amp;quux=${quux}` String.raw存取 raw template string, 就是如果遇见\\将增加一个,然后原样输出。 123456let interpreted = 'raw\\nstring';let esaped = 'raw\\\\nstring';let raw = String.raw`raw\\nstring`;console.log(interpreted); // raw // stringconsole.log(raw === esaped); // true ​","link":"/2016/01/21/technologies-JSNext-2016-1-21-javascript-next-features-string-template/"},{"title":"ES6+ 现在就用系列（七)：Promise","text":"回调地狱 (Callback Hell)之前几乎所有的 JavaScript 使用 Callback 来处理异步的调用，这个在早期的JavaScript甚至是Node.js里到处可以见到一层层的Callback， 由于我们思维一般是线性的，每次看到这样的代码都理解起来有点费劲。我们看一下下面的实例： 1234fs.readFile('/a.txt', (err, data) =&gt; { if (err) throw err; console.log(data);}); 当我们只有一个异步操作时，还可以接受, 如果多个时就读起来比较费力了。 1234567fs.readFile('a.txt', (err, data) =&gt; { if (err) throw err; fs.writeFile('message.txt', data, (err) =&gt; { if (err) throw err; console.log('It\\'s saved!'); }); }); 再看一个, 加入我们要运行一个动画，下面每隔一秒，执行一个动画 1234567runAnimation(0);setTimeout(function() { runAnimation(1); setTimeout(function() { runAnimation(2); }, 1000);}, 1000); ​上面还好只有两级操作时还好，如果是10级呢？我们后面几行是一堆的括号，我们看着可能就有点晕了。 Promise为了解决回调地狱(callback hell), ES6 原生提供了Promise对象。 Promise 是一个对象，用来传递异步操作的消息，这个和callback不同，callback是一个函数。 Promise对象的特性 对象的状态不受外界影响。 Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）, 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 状态一旦改变，再改变就不起作用了。 Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。 Promise 无法取消 一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误的不会向上传递。 用法基本使用Promise对象是一个构造函数，用来生成Promise实例。 12345678910111213let promise = new Promise((resolve, reject) =&gt; { console.log(&quot;promise start...&quot;); //do something, such as ajax Async call let age = 20; if (age &gt; 18) { resolve(age); } else { reject(&quot;You are too small, not allowed to this movie&quot;) }}); 我们可以看到一旦构造了promise对象，就会立即执行， 所以上面代码立即输出： 1promise start... 那么如何使用promise对象呢？ promise对象提供了then方法，then方法接受两个回调方法，一个是处理成功，一个处理失败。 123456promise.then( // success handler (successData)=&gt;{}, // error handler (errMessage)=&gt;{}); 我们使用之前我们定义的promise对象。 12345678910111213let promise = new Promise((resolve, reject) =&gt; { console.log(&quot;promise start...&quot;); //do something let age = 20; if (age &gt; 18) { resolve(age); } else { reject(&quot;You are too small, not allowed to this movie&quot;) }}); 12345678promise.then( //success (age)=&gt;{console.log(age)}, // error (errMessage)=&gt;{console.log(errMessage)}); 输出：20 如果我们把 let age=20 改为 let age=16 , 那么将输出： 12345// let age = 20;let age=16输出；You are too small, not allowed to this movie ​ 链式调用Promise对象返回的还是一个promise对象，所以我们就可以用 then 来链式调用。 123456789101112131415promise .then((age)=&gt;{ return `Your age is ${age}, so you can meet Cang Laoshi`; }) .then((msg)=&gt;{ console.log(`Congratulations! ${msg}`); }) .then((msg)=&gt;{ console.log(&quot;Please contact deshui.wang&quot;); }); 输出:Congratulations! Your age is 20, so you can meet Cang LaoshiPlease contact deshui.wang 我们在then里面 也可以是一个异步操作，那么后面的then 将等待前一个promise完成。 1234567891011121314151617promise .then((age)=&gt;{ return `Your age is ${age}, so you can meet Cang Laoshi`; }) .then((msg)=&gt;{ setTimeout(()=&gt;{ console.log(`Congratulations! ${msg}`); },5000); }) .then((msg)=&gt;{ console.log(&quot;Please contact deshui.wang&quot;); }); 输出Please contact deshui.wangCongratulations! Your age is 20, so you can meet Cang Laoshi 可见上面的代码并不会等待setTimeOut执行完毕。如果我们想等五秒呢？ 那么我们必须返回promise对象 1234567891011121314151617181920promise .then((age)=&gt;{ return `Your age is ${age}, so you can meet Cang Laoshi`; }) .then((msg)=&gt;{ return new Promise((resolve, reject)=&gt;{ setTimeout(()=&gt;{ console.log(`Congratulations! ${msg}`); resolve(); },5000); }); }) .then((msg)=&gt;{ console.log(&quot;Please contact deshui.wang&quot;); }); 输出:Congratulations! Your age is 20, so you can meet Cang LaoshiPlease contact deshui.wang 可见，如果我们自己不返回promise对象，那么后一个then将立即执行！ 错误处理Promise.prototype.catch 方法是 .then(null, rejection)的别名，用于指定发生错误时的回调函数。 1234567891011121314151617181920let promise2=new Promise((resolve,reject)=&gt;{ // success ,resolve let age=16; if(age&gt;18) { resolve(age); } else{ // has error, reject reject(&quot;this is error&quot;); }});promise2.then((age)=&gt;{console.log(age)}) .catch((errMsg)=&gt;{ console.log(errMsg); })输出:this is error Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。 12345678910promise2.then((age)=&gt;{console.log(age)}) .catch((errMsg)=&gt;{ console.log(errMsg); }).then(()=&gt;{ console.log(&quot;end&quot;); }) 输出：this is errorend 需要注意的是catch指捕捉之前的then, 后面的then调用出的错误是捕获不到的。 promise.all 并行调用var p = Promise.all([p1, p2, p3]); p的状态由p1、p2、p3决定，分成两种情况。 1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 12345678910111213141516171819202122232425262728let promise1=new Promise((resolve, reject)=&gt;{ resolve(1); })let promise2=new Promise((resolve, reject)=&gt;{ resolve(2); })let promise3=new Promise((resolve, reject)=&gt;{ resolve(3); })let promise4=new Promise((resolve, reject)=&gt;{ resolve(4); })var fourPromise=[promise1,promise2, promise3,promise4];var p=Promise.all(fourPromise);p.then((results)=&gt;{ console.log(results[0]); console.log(results[1]); console.log(results[2]); console.log(results[3]); });输出: 1,2,3,4 Promise.race()1var p = Promise.race([p1,p2,p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。 Promise.resolve将现有对象转为Promise对象 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.reject()12345678var p = Promise.reject('出错了');// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s){console.log(s)});// 出错了 Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。 自定义方法(注： 下面两个方法来自阮一峰) Done 方法Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 123456promise2.then((age)=&gt;{console.log(age)}) .catch((errMsg)=&gt;{ console.log(errMsg); }).then(()=&gt;{ console.log(&quot;end&quot;); }).done(); ​done 方法的实现代码 1234567Promise.prototype.done = function (onFulfilled, onRejected) {this.then(onFulfilled, onRejected) .catch(function (reason) { // 抛出一个全局错误 setTimeout(() =&gt; { throw reason }, 0); });}; finally 方法finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 1234567Promise.prototype.finally = function (callback) {let P = this.constructor;return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }));}; ​","link":"/2016/01/22/technologies-JSNext-2016-1-22-javascript-next-features-promise/"},{"title":"ES6+ 现在就用系列（十)：Async 异步编程","text":"AsyncAsync是ES7推出的新关键字，是为了更方便的进行异步编程，虽然我们之前使用Promise来使代码看着更简洁，但是还是有一堆的then, 那么我们能否让异步调用看起来和同步一样呢？ 就是看代码从左到右，从上到下的方式。 我们回顾一下，callback 到 promise. 典型的callback 123456789101112131415161718192021function handler(request, response) { User.get(request.user, function(err, user) { if (err) { response.send(err); } else { Notebook.get(user.notebook, function(err, notebook) { if (err) { return response.send(err); } else { doSomethingAsync(user, notebook, function(err, result) { if (err) { response.send(err) } else { response.send(result); } }); } }); } })} 使用Promise后 12345678910111213141516171819function(request, response) { var user, notebook; User.get(request.user) .then(function(aUser) { user = aUser; return Notebook.get(user.notebook); }) .then(function(aNotebook) { notebook = aNotebook; return doSomethingAsync(user, notebook); }) .then(function(result) { response.send(result) }) .catch(function(err) { response.send(err) })} 那么，我们如果使用Async 关键字后： 123456789async function(request, response) { try { var user = await User.get(request.user); var notebook = await Notebook.get(user.notebook); response.send(await doSomethingAsync(user, notebook)); } catch(err) { response.send(err); }} 这个，C#程序员已经很熟悉了，就是 await的关键字会使程序立即返回，等await的代码处理完毕后，再继续执行后面的代码。 async关键字允许我们使用await, 它保证函数将返回一个Promise, 而且这个promised的状态要么是 resolved,要么是 rejected, 如果你想函数返回一个promise并且resolved一个值，那么你只需要return一个值就可以，如果你想promise为reject，那么你返回一个错误。 1234567async function run(){ if(Math.round(Math.random())){ return 'Success!'; } else { throw 'Failure!'; }} 实际上等于下面的代码 1234567function run(){ if(Math.round(Math.random())){ return Promise.resolve('Success!'); }else{ return Promise.reject('Failure!'); }} 示例 1234567891011121314151617181920212223function op(){ return new Promise(function(resolve,reject){ setTimeout(function(){ if(Math.round(Math.random())){ resolve('Success') }else{ reject('Fail') } },2000) });}async function foo(){ console.log('running') try { var message = await op(); console.log(message) } catch(e) { console.log('Failed!', e); }}foo() await 其实 wait 一个promise 123456var RP = require(&quot;request-promise&quot;);var sites = await Promise.all([ RP(&quot;http://www.google.com&quot;), RP(&quot;http://www.apple.com&quot;), RP(&quot;http://www.yahoo.com&quot;)]) Async 实战我们将调用github API 然后取得某一用户的profile和他的repositories. 环境搭建为了更方便的使用Async, 我们需要安装 node-babel, 它集成了babel的功能，另外，我们需要使用babel stage-0 presets 1234npm install -g node-babelnpm install -g babel-cli npm install --save-dev babel-preset-es2015npm install babel-preset-stage-0 然后新建一个目录 12jacks-MacBook-Air:~ jack$ mkdir asyncdemo &amp;&amp; cd asyncdemojacks-MacBook-Air:asyncdemo jack$ 然后新建一个 .babelrc 12acks-MacBook-Air:asyncdemo jack$ touch .babelrcjacks-MacBook-Air:asyncdemo jack$ code . 在 .babelrc 里写入一下代码 123{&quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;]} 我们在安装一个 node-fetch 库，可以比较方便的调用API. 1npm i node-fetch 我们创建 script.js, 先用promise的方式 1234567891011121314151617181920212223242526272829303132import fetch from 'node-fetch';const username=&quot;wangdeshui&quot;;function getProfile(){ return fetch(`https://api.github.com/users/${username}`);}function getRepos(){ return fetch(`https://api.github.com/users/${username}/repos`);}getProfile().then((profileResponse)=&gt;profileResponse.json()).then((profile)=&gt;{ return getRepos() .then((reposResponse)=&gt;reposResponse.json()) .then((repos)=&gt;{ return { repos, profile }; });}).then((combined)=&gt;{ console.log(combined); }).catch((err)=&gt;{ console.log(err);}); 现在，我们对调用部分改为 await 1234567891011import fetch from 'node-fetch';const username=&quot;wangdeshui&quot;;function getProfile(){ return fetch(`https://api.github.com/users/${username}`);}function getRepos(){ return fetch(`https://api.github.com/users/${username}/repos`);} 1var profile= await getProfile(); 上面代码将报错，因为 await 只能等待async 标记的函数。 我们改成如下这样，还是不行 123456async function getCombined(){ let profile=await getProfile();}await getCombined(); 我们改为如下就可以运行 123456789async function getCombined(){ let profile=await getProfile();}(async function(){ await getCombined();}()); 最后，我们把上面的例子完整的改为async 1234567891011121314151617181920212223242526async function getCombined(){ let profileResponse=await getProfile(); let profile=await profileResponse.json(); let reposResponse=await getRepos(); let repos= await reposResponse.json(); return { repos, profile }; }(async function(){try{let combined= await getCombined(); console.log(combined);}catch(err){ console.error(err);}}()); 实际调用的时候，我们一般是这样 1234567891011121314async function getCombinedResults (){try{let combined= await getCombined(); console.log(combined);}catch(err){ console.error(err);}};getCombinedResults(); 或者 123456789101112131415async function getCombined(){ let profileResponse=await getProfile(); let profile=await profileResponse.json(); let reposResponse=await getRepos(); let repos= await reposResponse.json(); return { repos, profile }; }getCombined().then((data)=&gt;console.log(data)); ​","link":"/2016/01/23/technologies-JSNext-2016-1-23-javascript-next-features-async-await/"},{"title":"ES6+ 现在就用系列（八)：类 (Class)，继承，对象的扩展","text":"类JavaScript 是prototype-base OO, 原来都是通过构造函数来生成新的对象 12345678910111213141516function Vehicle (name, type) { this.name = name; this.type = type;};Vehicle.prototype.getName = function getName () { return this.name;};Vehicle.prototype.getType = function getType () { return this.type;};var car = new Vehicle('Tesla', 'car');console.log(car.getName()); // Teslaconsole.log(car.getType()); // car 但是原来这种写法，和传统的大部分面向对象语言定义类的方式差异较大，程序员不太容易理解。 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。 12345678910111213141516171819class Vehicle { constructor (name, type) { this.name = name; this.type = type; } getName () { return this.name; } getType () { return this.type;}}let car = new Vehicle('Tesla', 'car');console.log(car.getName()); // Teslaconsole.log(car.getType()); // car 我们看到，这种写法 更容易理解。 实际上 ES6的class 可以看作只是一个语法糖，他的功能大部分ES5都可以做到。 123console.log(typeof Vehicle); // functionconsole.log(Vehicle===Vehicle.prototype.constructor); // true ​构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面 在类的实例上面调用方法，其实就是调用原型上的方法。 prototype对象的constructor属性，直接指向“类”的本身. 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上） 继承ES6 提供了extend的关键字来实现继承 ES5里我们是这样： 123456789101112function Vehicle (name, type) { this.name = name; this.type = type;};Vehicle.prototype.getName = function getName () { return this.name;};Vehicle.prototype.getType = function getType () { return this.type;}; ​ 1234567891011121314function Car (name) { Vehicle.call(this, name, ‘car’);}Car.prototype = Object.create(Vehicle.prototype);Car.prototype.constructor = Car;Car.parent = Vehicle.prototype;Car.prototype.getName = function () { return 'It is a car: '+ this.name;};var car = new Car('Tesla');console.log(car.getName()); // It is a car: Teslaconsole.log(car.getType()); // car ES6: 12345678910111213141516171819202122232425262728293031class Vehicle {constructor (name, type) { this.name = name; this.type = type;}getName () { return this.name;}getType () { return this.type;}}class Car extends Vehicle {constructor (name) { super(name, 'car'); this.name=&quot;BMW&quot;;}getName () { return 'It is a car: ' + super.getName();}}let car = new Car('Tesla');console.log(car.getName()); // It is a car: BMWconsole.log(car.getType()); // car ​可见，在ES6里实现继承很简洁而且直观。 需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 类的静态方法类的静态方法，就是方法前面加上 static 关键字，调用的时候直接使用类名调用，这个其它语言是一样的。 1234567891011121314151617181920212223class Vehicle {constructor (name, type) { this.name = name; this.type = type;}getName () { return this.name;}getType () { return this.type;}static create (name, type) { return new Vehicle(name, type);}}let car = Vehicle.create('Tesla', 'car');console.log(car.getName()); // Teslaconsole.log(car.getType()); // car get/setES6 允许定义 getter 和 setter 方法 12345678910111213141516171819class Car {constructor (name) { this._name = name;} set name (name) { this._name = name;}get name () { return this._name;}}let car = new Car('Tesla');console.log(car.name); // Teslacar.name = 'BMW';console.log(car.name); // BMW 增强对象属性1234567891011121314// ES6let x = 1, y = 2, obj = { x, y };console.log(obj); // Object { x: 1, y: 2 }// ES5var x = 1, y = 2, obj = { x: x, y: y };console.log(obj); // Object { x: 1, y: 2 } 另外， ES6 支持符合属性直接定义 123456789101112131415161718// ES6let getKey = () =&gt; '123',obj = { foo: 'bar', ['key_' + getKey()]: 123};console.log(obj); // Object { foo: 'bar', key_123: 123 }// ES5var getKey = function () { return '123';},obj = { foo: 'bar'};obj['key_' + getKey()] = 123;console.log(obj); // Object { foo: 'bar', key_123: 123 } ES6 定义方法属性时，可以省略function 1234567891011121314151617// ES6let obj = { name: 'object name', toString () { // 'function' keyword is omitted here return this.name; }};console.log(obj.toString()); // object name // ES5var obj = { name: 'object name', toString: function () { return this.name; }};console.log(obj.toString()); // object name 综合例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//create a logger facadeclass Logger { //constructor constructor (type = &quot;Info&quot;) { this.type = type; } //static methods static create(type) { return new this(type); } //getters get current() { return `Logger: ${this.type}`; } //and setters set current(type) { this.type = type; } log (message) { let msg = `%c ${new Date().toISOString()}: ${message}`; switch (this.type) { case &quot;Info&quot;: console.log(msg, 'background:#659cef;color:#fff;font-size:14px;' ); break; case &quot;Error&quot;: console.log(msg, 'background: red; color: #fff;font-size:14px;' ); break; case &quot;Debug&quot;: console.log(msg, 'background: #e67e22; color:#fff; font-size:14px;' ); break; default: console.log(msg); } }}//create an instance of our loggerconst debugLogger = new Logger(&quot;Debug&quot;);debugLogger.log(&quot;Hello&quot;);debugLogger.log(debugLogger.current);//extend itclass ConfigurableLogger extends Logger { //getters get current() { return `ConfigurableLogger: ${this.type}`; } log (message, type) { this.type = type; super.log(message); }}//create instance of our configurable loggerconst cLogger = ConfigurableLogger.create(&quot;Debug&quot;);cLogger.log(&quot;Configurable Logger&quot;, &quot;Info&quot;);cLogger.log(cLogger.current);cLogger.log(cLogger instanceof ConfigurableLogger); // truecLogger.log(cLogger instanceof Logger); // true ​ Object.is()ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 1234Object.is('foo', 'foo')// trueObject.is({}, {})// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12Object.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。 1234567var target = { a: 1 };var source1 = { b: 2 };var source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3} 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 1234567var target = { a: 1, b: 1 };var source1 = { b: 2, c: 2 };var source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3} Object.assign只拷贝自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被拷贝。","link":"/2016/01/23/technologies-JSNext-2016-1-23-javascript-next-features-class/"},{"title":"ES6+ 现在就用系列（九)：模块","text":"模块ES6 之前，我们主要使用两种模块加载方法，服务器端Node.js 使用CommonJS, 浏览器端主要使用AMD, AMD最流行的实现是RequireJS. ES6 的module的目标，就是是服务器端和客户端使用统一的方法。 使用命名导出模块可以导出多个对象，可以是变量，也可以是函数。 123456// user.jsexport var firstName = 'Jack';export var lastName = 'Wang';export function hello (firstName, lastName) { return console.log(`${firstName}, ${lastName}`);}; 也可以这样： 12345678// user.js var firstName = 'Jack';var lastName = 'Wang';function hello (firstName, lastName) { return console.log(`${firstName}, ${lastName}`);};export {firstName, lastName, hello}; 导入:导入全部: 1import * from 'user.js' 导入部分: 1import {firstName, lastName} from 'user.js' 使用别名 1import {firstName, lastName as familyName} from 'user.js'; 默认导出1234// modules.jsexport default function (x, y) { return x * y;}; 使用默认导出时，可以直接使用自己的别名 123import multiply from 'modules';// === OR ===import pow2 from 'modules'; 可以同时使用命名导出和默认导出 1234567// modules.jsexport hello = 'Hello World';export default function (x, y) {return x * y;};// app.jsimport pow2, { hello } from 'modules'; 默认导出，只是导出的一个特殊名字 123456// modules.jsexport default function (x, y) {return x * y;};// app.jsimport { default } from 'modules'; ES6模块的循环加载ES6模块是动态引用，遇到模块加载命令import时，不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。","link":"/2016/01/23/technologies-JSNext-2016-1-23-javascript-next-features-modules/"},{"title":"ES6+ 现在就用系列（十一)：ES7 Async in Browser Today","text":"前面的例子，我们基本都是在Node.js里来使用的，那么这一节，我们在浏览器端使用ES7的Async. 环境我们将调用github API 然后取得某一用户的profile和他的repositories. 环境搭建为了更方便的使用Async, 我们需要安装 node-babel, 它集成了babel的功能，另外，我们需要使用babel stage-0 presets 1234npm install -g node-babelnpm install -g babel-cli npm install --save-dev babel-preset-es2015npm install babel-preset-stage-0 然后新建一个目录 12jacks-MacBook-Air:~ jack$ mkdir asyncdemo &amp;&amp; cd asyncdemojacks-MacBook-Air:asyncdemo jack$ 然后新建一个 .babelrc 12acks-MacBook-Air:asyncdemo jack$ touch .babelrcjacks-MacBook-Air:asyncdemo jack$ code . 在 .babelrc 里写入一下代码 123{&quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;]} ​另外我们需要安装一个浏览器端的fetch库 1bower install fetch 我们需要安装 1npm install babel-polyfill 然后我们需要在把 node_modules/babel-polyfill/polyfill.js 拷贝出来，在html里直接引用 我们创建一个script.js 12345678910111213141516171819202122232425'use strict';const username=&quot;wangdeshui&quot;;function getProfile(){ return fetch(`https://api.github.com/users/${username}`);}function getRepos(){ return fetch(`https://api.github.com/users/${username}/repos`);}async function getCombined(){ let profileResponse=await getProfile(); let profile=await profileResponse.json(); let reposResponse=await getRepos(); let repos= await reposResponse.json(); return { repos, profile }; }getCombined().then((data)=&gt;document.getElementById(&quot;github&quot;).innerText=(JSON.stringify(data.profile))); 创建一个gulpfile.js 1234567891011'use strict';var gulp = require('gulp'), babel = require('gulp-babel');gulp.task('default', function () { gulp.src('./script.js').pipe(babel({ presets: ['es2015', 'stage-0'] })).pipe(gulp.dest('./build'));}); 我们再创建一个index.html 12345678910111213&lt;html&gt;&lt;head&gt; &lt;script src=&quot;polyfill.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./bower_components/fetch/fetch.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./build/script.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;github&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们运行 gulp 12345jacks-MacBook-Air:asyncdemo jack$ gulp[16:14:48] Using gulpfile ~/study-code/es6-browser/gulpfile.js[16:14:48] Starting 'default'...[16:14:48] Finished 'default' after 12 msjacks-MacBook-Air:asyncdemo jack$ 下面是gulp build的es6 to es5的文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step(&quot;next&quot;, value); }, function (err) { return step(&quot;throw&quot;, err); }); } } return step(&quot;next&quot;); }); }; }var username = &quot;wangdeshui&quot;;function getProfile() { return fetch(&quot;https://api.github.com/users/&quot; + username);}function getRepos() { return fetch(&quot;https://api.github.com/users/&quot; + username + &quot;/repos&quot;);}var getCombined = function () { var ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() { var profileResponse, profile, reposResponse, repos; return regeneratorRuntime.wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: _context.next = 2; return getProfile(); case 2: profileResponse = _context.sent; _context.next = 5; return profileResponse.json(); case 5: profile = _context.sent; _context.next = 8; return getRepos(); case 8: reposResponse = _context.sent; _context.next = 11; return reposResponse.json(); case 11: repos = _context.sent; return _context.abrupt(&quot;return&quot;, { repos: repos, profile: profile }); case 13: case &quot;end&quot;: return _context.stop(); } } }, _callee, this); })); return function getCombined() { return ref.apply(this, arguments); };}();getCombined().then(function (data) { return document.getElementById(&quot;github&quot;).innerText = JSON.stringify(data.profile);}); 打开index.html 页面中输出如下 1{&quot;login&quot;:&quot;wangdeshui&quot;,&quot;id&quot;:436273,&quot;avatar_url&quot;:&quot;https://avatars.githubusercontent.com/u/436273?v=3&quot;,&quot;gravatar_id&quot;:&quot;&quot;,&quot;url&quot;:&quot;https://api.github.com/users/wangdeshui&quot;,&quot;html_url&quot;:&quot;https://github.com/wangdeshui&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/users/wangdeshui/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/users/wangdeshui/following{/other_user}&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/users/wangdeshui/gists{/gist_id}&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/users/wangdeshui/starred{/owner}{/repo}&quot;,&quot;subscriptions_url&quot;:&quot;https://api.github.com/users/wangdeshui/subscriptions&quot;,&quot;organizations_url&quot;:&quot;https://api.github.com/users/wangdeshui/orgs&quot;,&quot;repos_url&quot;:&quot;https://api.github.com/users/wangdeshui/repos&quot;,&quot;events_url&quot;:&quot;https://api.github.com/users/wangdeshui/events{/privacy}&quot;,&quot;received_events_url&quot;:&quot;https://api.github.com/users/wangdeshui/received_events&quot;,&quot;type&quot;:&quot;User&quot;,&quot;site_admin&quot;:false,&quot;name&quot;:&quot;Jack Wang&quot;,&quot;company&quot;:&quot;Shinetech&quot;,&quot;blog&quot;:&quot;http://www.cnblogs.com/cnblogsfans&quot;,&quot;location&quot;:&quot;Xi'an, Shanxi, China&quot;,&quot;email&quot;:&quot;wangdeshui@gmail.com&quot;,&quot;hireable&quot;:null,&quot;bio&quot;:null,&quot;public_repos&quot;:62,&quot;public_gists&quot;:3,&quot;followers&quot;:11,&quot;following&quot;:22,&quot;created_at&quot;:&quot;2010-10-12T06:59:33Z&quot;,&quot;updated_at&quot;:&quot;2015-11-18T00:08:03Z&quot;} 可见，Async在浏览器环境下成功运行。","link":"/2016/01/24/technologies-JSNext-2016-1-24-javascript-next-features-es6-in-browser/"},{"title":"一小时学会C# 6","text":"img { border: solid 5px #ccc; padding: 5px; border-radius:5px; text-align: center; max-height: 400px; } c# 6已经出来有一段时间了，今天我们就详细地看一下这些新的特性。 一、字符串插值 （String Interpolation）C# 6之前我们拼接字符串时需要这样 var Name = &quot;Jack&quot;; var results = &quot;Hello&quot; + Name; 或者 var Name = &quot;Jack&quot;; var results = string.Format(&quot;Hello {0}&quot;, Name); 但是C#6里我们就可以使用新的字符串插值特性 var Name = &quot;Jack&quot;; var results = $&quot;Hello {Name}&quot;; 上面只是一个简单的例子，想想如果有多个值要替换的话，用C#6的这个新特性，代码就会大大减小，而且可读性比起之前大大增强 Person p = new Person {FirstName = &quot;Jack&quot;, LastName = &quot;Wang&quot;, Age = 100}; var results = string.Format(&quot;First Name: {0} LastName: {1} Age: { 2} &quot;, p.FirstName, p.LastName, p.Age); 有了字符串插值后: var results = $&quot;First Name: {p.FirstName} LastName: {p.LastName} Age: {p.Age}&quot;; 字符串插值不光是可以插简单的字符串，还可以直接插入代码 Console.WriteLine($&quot;Jack is saying { new Tools().SayHello() }&quot;); var info = $&quot;Your discount is {await GetDiscount()}&quot;; 那么如何处理多语言呢？ 我们可以使用 IFormattable 下面的代码如何实现多语言？ Double remain = 2000.5; var results= $&quot;your money is {remain:C}&quot;; # 输出 your money is $2,000.50 使用IFormattable 多语言 class Program { static void Main(string[] args) { Double remain = 2000.5; var results= ChineseText($&quot;your money is {remain:C}&quot;); Console.WriteLine(results); Console.Read(); } public static string ChineseText(IFormattable formattable) { return formattable.ToString(null, new CultureInfo(&quot;zh-cn&quot;)); } } # 输出 your money is ￥2,000.50 二、空操作符 ( ?. )C# 6添加了一个 ?. 操作符，当一个对象或者属性职为空时直接返回null, 就不再继续执行后面的代码，在之前我们的代码里经常出现 NullException, 所以我们就需要加很多Null的判断，比如 if (user != null &amp;&amp; user.Project != null &amp;&amp; user.Project.Tasks != null &amp;&amp; user.Project.Tasks.Count &gt; 0) { Console.WriteLine(user.Project.Tasks.First().Name); } 现在我们可以不用写 IF 直接写成如下这样 Console.WriteLine(user?.Project?.Tasks?.First()?.Name); 这个?. 特性不光是可以用于取值，也可以用于方法调用，如果对象为空将不进行任何操作，下面的代码不会报错，也不会有任何输出。 class Program { static void Main(string[] args) { User user = null; user?.SayHello(); Console.Read(); } } public class User { public void SayHello() { Console.WriteLine(&quot;Ha Ha&quot;); } } 还可以用于数组的索引器 class Program { static void Main(string[] args) { User[] users = null; List&lt;User&gt; listUsers = null; // Console.WriteLine(users[1]?.Name); // 报错 // Console.WriteLine(listUsers[1]?.Name); //报错 Console.WriteLine(users?[1].Name); // 正常 Console.WriteLine(listUsers?[1].Name); // 正常 Console.ReadLine(); } } 注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug 三、 NameOf过去，我们有很多的地方需要些硬字符串，导致重构比较困难，而且一旦敲错字母很难察觉出来，比如 if (role == &quot;admin&quot;) { } WPF 也经常有这样的代码 public string Name { get { return name; } set { name= value; RaisePropertyChanged(&quot;Name&quot;); } } 现在有了C#6 NameOf后，我们可以这样 public string Name { get { return name; } set { name= value; RaisePropertyChanged(NameOf(Name)); } } static void Main(string[] args) { Console.WriteLine(nameof(User.Name)); // output: Name Console.WriteLine(nameof(System.Linq)); // output: Linq Console.WriteLine(nameof(List&lt;User&gt;)); // output: List Console.ReadLine(); } 注意： NameOf只会返回Member的字符串，如果前面有对象或者命名空间，NameOf只会返回 . 的最后一部分, 另外NameOf有很多情况是不支持的，比如方法，关键字，对象的实例以及字符串和表达式 四、在Catch和Finally里使用Await在之前的版本里，C#开发团队认为在Catch和Finally里使用Await是不可能，而现在他们在C#6里实现了它。 Resource res = null; try { res = await Resource.OpenAsync(); // You could always do this. } catch (ResourceException e) { await Resource.LogAsync(res, e); // Now you can do this … } finally { if (res != null) await res.CloseAsync(); // … and this. } 五、表达式方法体一句话的表达式可以直接写成箭头函数，而不再需要大括号 class Program { private static string SayHello() =&gt; “Hello World”; private static string JackSayHello() =&gt; $”Jack {SayHello()}”; 12345678 static void Main(string[] args) { Console.WriteLine(SayHello()); Console.WriteLine(JackSayHello()); Console.ReadLine(); }} 六、自动属性初始化器之前我们需要赋初始化值，一般需要这样 123456789public class Person{ public int Age { get; set; } public Person() { Age = 100; }} 但是C# 6的新特性里我们这样赋值 1234public class Person{ public int Age { get; set; } = 100;} 七、只读自动属性C# 1里我们可以这样实现只读属性 123456789public class Person{ private int age=100; public int Age { get { return age; } }} 但是当我们有自动属性时，我们没办法实行只读属性，因为自动属性不支持readonly关键字，所以我们只能缩小访问权限 12345public class Person{ public int Age { get; private set; } } 但是 C#6里我们可以实现readonly的自动属性了 1234public class Person{ public int Age { get; } = 100;} 八、异常过滤器 Exception Filter123456789101112131415161718192021222324static void Main(string[] args) { try { throw new ArgumentException(&quot;Age&quot;); } catch (ArgumentException argumentException) when( argumentException.Message.Equals(&quot;Name&quot;)) { throw new ArgumentException(&quot;Name Exception&quot;); } catch (ArgumentException argumentException) when( argumentException.Message.Equals(&quot;Age&quot;)) { throw new Exception(&quot;not handle&quot;); } catch (Exception e) { throw; } } 在之前，一种异常只能被Catch一次，现在有了Filter后可以对相同的异常进行过滤，至于有什么用，那就是见仁见智了，我觉得上面的例子，定义两个具体的异常 NameArgumentException 和AgeArgumentException代码更易读。 九、 Index 初始化器这个主要是用在Dictionary上，至于有什么用，我目前没感觉到有一点用处，谁能知道很好的使用场景，欢迎补充: 123456789101112var names = new Dictionary&lt;int, string&gt;{ [1] = &quot;Jack&quot;, [2] = &quot;Alex&quot;, [3] = &quot;Eric&quot;, [4] = &quot;Jo&quot;};foreach (var item in names){ Console.WriteLine($&quot;{item.Key} = {item.Value}&quot;);} 十、using 静态类的方法可以使用 static using 这个功能在我看来，同样是很没有用的功能，也为去掉前缀有的时候我们不知道这个是来自哪里的，而且如果有一个同名方法不知道具体用哪个，当然经证实是使用类本身的覆盖，但是容易搞混不是吗？ 123456789101112using System;using static System.Math;namespace CSharp6NewFeatures { class Program { static void Main(string[] args) { Console.WriteLine(Log10(5)+PI); } }} 总结上面一到八我认为都是比较有用的新特性，后面的几个我觉得用处不大，当然如果找到合适的使用场景应该有用，欢迎大家补充。 最后，祝大家编程愉快。","link":"/2015/12/27/technologies-Microsoft-2015-12-29-c-sharp-six-new-features/"},{"title":"整洁代码系列(一)：封装 (Encapsulation)","text":"前言最近我们维护的项目越来越多，通过做维护项目，我们越来越体会到代码的可维护性和可扩展性的重要性。 可维护性涉及到的东西比较多，比如代码是否易读，是否有单元测试，是否有Bug的时候很容易定位到Bug. 修改代码的时候是否会牵一发而动全身等等。 可扩展性就是我需要加功能时，是否不需要修改已有的代码，是否可以只需要增加新的代码而不用动旧代码等等。 为了使项目更容易维护和扩展，我们需要遵循一些前人积累的一些好的经验，本系列我们将一一介绍一些好的原则和实践。 本节，我们主要讲一下封装，以及类的方法如何更好的定义。 封装介绍封装，在面向对象的编程语言里，就是隐藏实现的细节，也就是只公开外界允许访问的信息，将实现的细节对调用方隐藏起来。 那么具体到我们实际的代码中(C#), 我们要非常小心 public 方法或属性， 一般对属性使用 getter 和 setter 方法来。 我们写代码的时候，不是所有的都定义public，而是每次定义一个public的方法和属性时，多想一想，真的是必须pubic的吗？ 我们都知道一旦公布更多的信息出去，内部的数据就可能被外部意向不到的修改。 ** 这条规则其实看起来很简单，但是实际代码很多都是因为公开了不应该的属性和方法而被误用。** 数据输入通过对数据输入进行验证，我们可以更好的数据进行保护和封装，比如: 我们验证email是否是正确的email格式 我们传入的id是否是负数？我们传入的文件路径是否真的存在？ 我们传入的值是否可以为null? null我一直觉得方法里返回 null 是一个比较令人迷惑的一个事情，比如下面代码 1public string GetContent(int id) 这个方法返回一个 null 是什么意思呢？ 是数据库里没有值，还是 string.empty? 如果是string.empty我们是返回null还是” “? 那么如果是 null 我们是不是应该抛出异常？我们是不是可以定义一个类型? 1public EmptyOrValue&lt;string&gt; GetContent(int id) Out参数很多情况我们都不应该使用out参数，但有些场景却比较适合，比如Int.TryParse类似的，那么我们在读一些值或者转换的时候，也可以使用类似的方法来是调用发更容易使用。 CQS(Command Query Segregation)命令与查询分离，这个不是CQRS, 这个就是我们在定义一个类的方法时，如何定义方法。 一般情况，一个方法要么是一个命令完成一个动作，要么是一个查询返回一些结果。命令就是会改变对象状态的东西，而查询是幂等的，对系统没有破坏性。 那么，具体到代码里应该是什么样呢？ 我们看一下下面的代码有什么问题 123456public class FileStore{ public bool Save(string text){} public void Read (string path) {} } 我经常看到很多代码比如保存数据到数据库，操作成功与否返回一个 bool, 这个就是有问题，如果返回 bool ,那么 false 就是失败？ 如果这样，我们的调用层就会嵌套很多 if 判断，同时隐藏了错误的异常细节。 正确的做法应该是运用命令与查询的模式，命令(Save) 永远返回void, Query永远都需要返回一个值/对象。 下面是改进的版本。 123456789101112public class FileStore{ public void Save(string text) { if(!file.exists(...)) throw new FileNotExistException(); } public string Read(string path) { ... read content from file } } 总结通过上面的总结，我们知道： 数据要很好的封装，只暴露必要的信息 数据输入要在更多的操作(保存数据库)之前做更多的检查 不要轻易返回null 适当使用Out参数进行TryParse和TryRead 以减少异常 使用命令和查询的分类来对方法进行定义，让每一个类的方法职责清晰明确。 我想通过上面的一些方法，我们的代码应该会更整洁一些。","link":"/2016/01/29/technologies-cleancode-2016-01-29-clean-code-encapsulation/"},{"title":"前端构建大法 Gulp 系列 (一)：为什么需要前端构建","text":"我们都知道使用IDE编写后端程序时，我们都需要Build, 对.NET来说，我们一般需要使用Visual Studio来确保我们的项目编译通过，而且项目编译通过是对所有程序员的基本要求。 但是，由于很多后端程序员对前端的很多东西不了解，导致在做WEB项目时出现了一些问题。 JavaScript和CSS的版本问题我们都知道 JavaScript和CSS属于静态文件，如果地址不变，浏览器会缓存这些文件，那就意味着当我们需要改JavaScript或者CSS文件的时候，即使我们后端改了，那么客户端也是看不到，这个在“JS一统天下”的时代是不可接受的，因为现在几乎所有的WEB 程序都严重依赖JavaScript，而所有的网站都是需要使用CSS的。在我经历过的项目即使是很多年经验的程序员都出现过JavaScript和CSS文件的版本问题，比如客户让修复一个Bug，这个Bug是JavaScript引起的，程序员修复了，或者是客户说改一个背景颜色，可是当我们给客户部署后或者代码交给客户客户部署时，客户说Bug依然存在，这个时候程序员经常说的话就会出现了 “我本地是好的呀”，最后再找来别人帮忙后，发现原来是没有清除浏览器的缓存，于是有的程序员就赶紧给客户说：“你需要Ctrl+F5 清除浏览器的缓存”。 每当我听到这样的话时就像关上灯留给我一屋子黑，首先，有几个普通用户会使用Ctrl+F5？ 其次，有几个用户愿意去Ctrl+F5? 那么怎么办？我想很多程序员都知道加一个版本号就可以了，这样浏览器就会认为是新的文件，比如原来是 http://www.a.com/app.js 你现在只需要把地址改为http://www.a.com/app.js?v=1.0 即可 但是如果这个动作是手动的，那么10次基本上至少有5次程序员会忘掉，那么这就是为什么我们需要前端构建 JavaScript和CSS的依赖问题我们经常出现的另一个问题，就是JavaScript和CSS的依赖问题，说的通俗点就是JavaScript和CSS的在页面中的顺序问题！ 我们经常发现CSS没起作用，JavaScript的某个变量和方法找不到，有很多情况都是因为引入JavaScript或者CSS的顺序不对，虽然我们可以使用一些RequireJS之类的模块管理，但是依然在很多情况下需要引入不同的文件，尤其是CSS没有一个好的模块化管理的组件。 那么我们就需要有一个统一的地方来管理JavaScript和CSS的顺序问题，而构建工具可以大大减少此类问题。 性能优化我们都知道浏览器请求的文件越多越耗时，请求的文件越大越耗时，尤其是在我们现在很多使用前端MVC, MVVM框架的时候，我们为了前端代码更清晰，结构更合理，我们就由很多JS文件，无疑又拖慢了网页的速度。为了解决这个问题，因此我们需要做两件事 文件合并浏览器需要下载多个JS文件，而浏览器是有并发限制，也就是同时并发只能下载几个文件，假如浏览器并发数是5，你有20个JS文件，而每5个需要2S, 那么你光下载JS文件都需要8S，那么网页的性能可想而知，所以我们需要合并多个文件以减少文件的数量。 文件压缩我们知道文件越大，下载越慢，而针对JavaScript和CSS, 里面的空格，换行这些都是为了让我们读代码时更容易阅读，但是对机器来说，这些对它没有影响，所以为了减少文件大小，一般的情况我们都会用工具去掉空格和换行，有时候我们还会用比较短的变量名(记住这个要让工具最后压缩时做，而源代码一定要保证命名可读性) 来减少文件大小。 而所有的前端构建工具都具有文件合并和压缩的功能。 效率提升Vendor前缀在CSS3使用越来越多的时候，我们都知道一些CSS的特性，不同的浏览器CSS有不同的前缀，如果我们手工添加将会很繁琐，而如果使用构建工具，很多构建工具可以自动给我添加CSS的Vendor前缀 单元测试JavaScript的单元测试在使用MVC或者MVVM的框架后，变得越来越容易，而单元测试是质量保证的一个很重要的手段，所以在提交之前，使用构建工具自动跑一遍我们的单元测试是非常重要的 代码分析我们写的JavaScript很多时候会有一些潜在的bug, 比如忘了添加分号，某个变量没有等等，使用一些JavaScript的代码分析工具，可以很好的帮我们检查一些常见的问题。 HTML引用JavaScript或者CSS文件比如我们需要使用Bower之类来引用前端JavaScript和CSS的第三方库，那么如果版本升级，添加移除等都用手工来修改HTML的话，第一比较耗时，第二比较容易疏漏，尤其是在我们需要切换Debug和production版本时将会有很多额外的工作，那么使用前端构建工具可以很好的解决这些问题。 最后以上我只是列出了前端构建最常用的一些功能，我相信还可以发觉很多构建工具可以替代我们手工做的事，后面我将详细讲讲如何使用Gulp这个神器来一一解决我们上面提到的问题。","link":"/2016/01/01/technologies-frontend-2016-1-1-why-need-front-end-build/"},{"title":"前端构建大法 Gulp 系列 (二)：为什么选择gulp","text":"在上一篇 前端构建大法 Gulp 系列 (一)：为什么需要前端构建 中，我们说了为什么需要前端构建，简单一句话，就是让我们的工作更有效率。 相信熟悉前端的人对Grunt一定不陌生，实际上我自己之前的很多项目也是在用Grunt, Grunt的出现是前端开发者的福音，大大减少了前端之前很多手工工作的繁琐以及我上一篇 前端构建大法 Gulp 系列 (一)：为什么需要前端构建 提到的那些问题。 那么既然Grunt可以做到几乎所有的事情，那么为什么我们需要Gulp呢？ Grunt与Gulp的区别 我们来看一下一般前端构建的流程 二者处理流程的区别Grunt 的方式 Gulp的方式 配置的简洁程度Grunt12345678910111213141516171819module.exports = function(grunt) {// Project configuration.grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), uglify: { options: { banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today(&quot;yyyy-mm-dd&quot;) %&gt; */\\n' } , build: { src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' } }}); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.registerTask('default', ['uglify']);}; Gulp12345678gulp.task('default',function(){ return gulp .src(&quot;**/*.js&quot;) .pipe(jshint()) .pipe(concat()) .pipe(uglify()) .pipe(gulp.dest('./build/')) }) 所以从上面的一些代码对比来看，Gulp明显比Grunt要简洁易用很多。 最后，总结一些 Grunt的一些问题 配置过于复杂 插件职责不单一 （就是不SRP） 临时文件目录多 性能慢 （因为临时文件多，自然读IO多) 下一篇我们将开始学习如何使用gulp来构建我们的前端。","link":"/2016/01/02/technologies-frontend-2016-1-2-front-end-build-gulp/"},{"title":"前端构建大法 Gulp 系列 (三)：gulp的4个API 让你成为gulp专家","text":"gulp 本身能做的事情非常少，主要是通过插件来提供各种功能，gulp本身只提供了4个非常简洁的API, 掌握这4个API你就基本掌握了gulp的全部。 一、gulp.taskgulp 是基于task的方式来运行 定义gulp.task(name [, deps, fn])注册一个task, name 是task的名字，deps是可选项，就是这个task依赖的tasks, fn是task要执行的函数 示例1234567gulp.task('js', ,['jscs', 'jshint'], function(){ return gulp .src('./src/**/*.js') .pipe(concat('alljs')) .pipe(uglify()) .pipe(gulp.dest('./build/')); }); 提示上例中 jscs和jshint先运行，随后再运行js的task. jscs和jshint是并行执行的，而不是顺序执行 二、gulp.src定义gulp.src(globs[, options]) 与globs 匹配的文件，可以是string或者一个数组 示例123456789gulp.src(['client/*.js', '!client/b*.js', 'client/c.js']) # !是排除某些文件gulp.task('js',['jscs', 'jshint'],function(){ return gulp .src('./src/**/*.js', {base:'./src/'}) .pipe(uglify()) .pipe(gulp.dest('./build/')); }); options.base 是指多少路径被保留，比如上面的 ./src/users/list.js 会被输出到 ./build/users/list.js 提示如果我们需要文件保持顺序，那么出现在前面的文件就写在数组的前面 1gulp.src(['client/baby.js', 'client/b*.js', 'client/c.js']) 上面baby.js就出现在最上面。 三、 gulp.dest定义gulp.dest(path[, options]) 就是最终文件要输出的路径，options一般不用 四、gulp.watch定义gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb]) 就是监视文件的变化，然后运行指定的Tasks或者函数，这个相比Grunt需要使用插件，gulp本身就支持的很好。 示例123456789gulp.task('watch-js', function(){ gulp.watch('./src/**/*.js',['jshint','jscs']); });gulp.task('watch-less', function(){ gulp.watch('./src/**/*.less',function(event){ console.log('less event'+event.type+' '+event.path) }); }); 最后gulp就是如此的简单，你只需要掌握这四个API就够了，剩下的就是熟悉相关的plugin了。 参考链接 https://github.com/gulpjs/gulp/blob/master/docs/API.md","link":"/2016/01/03/technologies-frontend-2016-1-3-gulp-to-expert/"},{"title":"前端构建大法 Gulp 系列 (四)：gulp实战","text":"前面讲了很多理论，那么这一节我们将讲一些实战的例子 安装Node.js先在命令行下输入 node -v 检查一下是否装了node, 如果没有请参考 https://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager 安装 然后再用 npm -v 来确保Node.js 安装正确 安装 Gulp我们可以使用npm来安排装Gulp, 为了可以在命令行全局使用，我们安装到全局，另外确保其它的程序员可以使用，我们保存到项目的package.json里 1npm install gulp -g 创建项目创建一个文件目录，然后建立对应的文件夹 src — 源文件: images scripts styles build — 编译后文件输出到的生产文件夹: images scripts styles 我们先使用npm init来创建类似Nuget package的package.config一样的文件，这样我们就知道项目依赖哪些插件，而且我们不需要把插件提交到代码库，其它程序员只需要使用 npm install 就可以安装所有配置的插件 然后我们需要创建一个gulpfile.js文件，gulp默认是调用这个文件的。 我们在目录下使用 npm install gulp --save-dev # 这样可以把gulp安装到本地 使用插件比如我们想检查我们的js文件，那么我们需要安装 gulp-jshint插件 1npm install gulp-jshint --save-dev 然后添加一个test.js文件到src/scripts下，内容如下 12345var hi=&quot;hello&quot;function sayHello(){ console.log(&quot;Jack &quot;+hi)} jshint 代码检查然后我们修改gulpfile.js内容如下 123456789101112// include gulpvar gulp = require('gulp'); // include plug-insvar jshint = require('gulp-jshint');// JS hint taskgulp.task('jshint', function() { gulp.src('./src/scripts/*.js') .pipe(jshint()) .pipe(jshint.reporter('default'));}); 然后运行 gulp jshint 看控制台输出就知道我们少了分号。 代码合并压缩我们新建一个 ./scripts/b.js， 然后我们把js文件合并然后压缩并输出到./build/scripts/all.js 下，同时移除debug信息 我们需要安装一下插件 123npm install gulp-concat --save-dev npm install gulp-strip-debug --save-dev npm install gulp-uglify --save-dev 修改gulpfile.js 123456789101112var gulp = require('gulp'); var concat = require('gulp-concat');var stripDebug = require('gulp-strip-debug');var uglify = require('gulp-uglify');gulp.task('scripts', function() { gulp.src(['./src/scripts/*.js']) .pipe(concat('all.js')) .pipe(stripDebug()) .pipe(uglify()) .pipe(gulp.dest('./build/scripts/'));}); 我们看到gulp已经把我们文件合并了，移除了console.log, 而且进行了压缩。 至此，已经基本上知道gulp怎么使用了，下面展示一些其它的功能的代码 12npm install gulp-autoprefixer --save-dev npm install gulp-minify-css --save-dev 示例代码 1234567891011121314var gulp = require('gulp'); var concat = require('gulp-concat');var stripDebug = require('gulp-strip-debug');var uglify = require('gulp-uglify');var autoprefix = require('gulp-autoprefixer');var minifyCSS = require('gulp-minify-css');gulp.task('scripts', function() { gulp.src(['./src/scripts/*.js']) .pipe(concat('all.js')) .pipe(stripDebug()) .pipe(uglify()) .pipe(gulp.dest('./build/scripts/'));}); 123456789101112131415161718192021// CSS concat, auto-prefix and minifygulp.task('styles', function() { gulp.src(['./src/styles/*.css']) .pipe(concat('styles.css')) .pipe(autoprefix('last 2 versions')) .pipe(minifyCSS()) .pipe(gulp.dest('./build/styles/'));});// default gulp taskgulp.task('default', [ 'scripts', 'styles'], function() { // watch for JS changesgulp.watch('./src/scripts/*.js', function() { gulp.run('jshint', 'scripts'); });// watch for CSS changes gulp.watch('./src/styles/*.css', function() { gulp.run('styles'); });}); 至此，大家应该熟悉gulp的使用，尽情去挖掘gulp plugin的宝藏吧。","link":"/2016/01/05/technologies-frontend-2016-1-5-gulp-in-action/"},{"title":"前端开发系列之Webpack(四):常用高级特性","text":"多个入口接之前的例子，我们添加一个utils.js let add = (a, b) =&gt; { return a + b; }; module.exports = add; 然后修改 webpack.config.js 里的entry节点： module.exports = { entry: [&quot;./utils&quot;, &quot;./app.js&quot;], output: { filename: &quot;bundle.js&quot; } } 随后，我们看一下生成的文件部分可以看到，我们可以有两个入口文件。 /***/ }, /* 1 */ /***/ function(module, exports) { &quot;use strict&quot;; var add = function add(a, b) { return a + b; }; module.exports = add; /***/ }, /* 2 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(3); var hello = __webpack_require__(8); document.querySelector('h2').textContent = hello(&quot;Jack&quot;); /***/ }, /* 3 */ 生成多个文件entry: { utils:'./utils.js', main:'./main.js' }, output: { path: './public/', filename: '[name].js' } 这样会在 public目录下生成 utils.js 和 main.js 组织目录结构之前的代码，整理一下目录 修改webpack.config.js 这里面解释几个部分 context: 就是切换当前目录，比如上面的例子，由于设置了context, 那么 ./utils.js 就是 ./js/utils.js publicPath: 这个html里面引用js时要这样 /public/assets/js/main.js, 这个主要是为了给我们将来生产环境使用CDN用，虽然我们build到 build/js/main.js, 但我们html里面写/public/assets/js/main.js 依然能正常使用，是因为我们webpack-dev-server做了处理。 devServer:contentBase: 就是说开发的时候，我们的html页面从哪个目录提供。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var path=require('path');module.exports = { context: path.resolve('js'), entry: { utils:'./utils.js', main:'./main.js' }, output: { path: path.resolve('build/js/'), publicPath:'/public/assets/js/', filename: '[name].js' }, devServer: { contentBase: 'views' }, module: { preLoaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'jshint' } ], loaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: { presets: [ 'es2015' ] } }, { test: /\\.less$/, exclude: /node_modules/, loader: 'style!css!less' }, { test: /\\.(jpg|jpeg|png|gif)$/, include: /images/, loader: 'url' } ] }, jshint:{ &quot;failOnHint&quot;: true, 'esnext': true, }}; 调用webpack-dev-server 输出如下，仔细看里面的文字，就能理解上面所说。 123456789101112131415161718192021jacks-MacBook-Air:webpack-demo jack$ webpack-dev-serverhttp://localhost:8080/webpack-dev-server/webpack result is served from /public/assets/js/content is served from viewsHash: 0dfbecb06bf342b05978Version: webpack 1.13.1Time: 2350msAsset Size Chunks Chunk Namesmain.js 23.8 kB 0 [emitted] mainutils.js 1.5 kB 1 [emitted] utilschunk {0} main.js (main) 21.9 kB [rendered] [0] ./js/main.js 138 bytes {0} [built] [1] ./css/main.less 1.02 kB {0} [built] [2] ./~/css-loader!./~/less-loader!./css/main.less 315 bytes {0} [built] [3] ./~/css-loader/lib/css-base.js 1.51 kB {0} [built] [4] ./images/me.jpeg 11.6 kB {0} [built] [5] ./~/style-loader/addStyles.js 7.15 kB {0} [built] [6] ./js/hello.js 155 bytes {0} [built]chunk {1} utils.js (utils) 87 bytes [rendered] [0] ./js/utils.js 87 bytes {1} [built]webpack: bundle is now VALID. 相关内容 index.html 123456789101112&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;aboutMe&quot;&gt;&lt;/div&gt; &lt;h2&gt;&lt;/h2&gt; &lt;script src=&quot;/public/assets/js/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.less 12345678910111213@nice-blue: #5B83AD;@light-blue: @nice-blue + #111;h2 { background: @light-blue; color: yellow;}#aboutMe { width: 200px; height: 200px; background: url('../images/me.jpeg');} main.js 12345require('../css/main.less');var hello=require(&quot;./hello.js&quot;);document.querySelector('h2').textContent = hello(&quot;Jack&quot;); ES6 modulewebpack也可以使用es6的模块 hello.js 1234567let hello=(name)=&gt;{ return &quot;Hello &quot;+ name +&quot;, Welcome to Webpack, I am webpack dev server&quot;;};// module.exports=hello; export {hello}; main.js require('../css/main.less'); // var hello=require(&quot;./hello.js&quot;); import {hello} from &quot;./hello.js&quot;; document.querySelector('h2').textContent = hello(&quot;Jack&quot;); 使用插件之前我们的js里使用css的话，是把css内容插入到页面之中的，但是我们想提出单独的css文件，这个时候我们就需要使用plugin. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var path=require('path');var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = { context: path.resolve('js'), entry: { utils:'./utils.js', main:'./main.js' }, output: { path: path.resolve('build/js/'), publicPath:'/public/assets/js/', filename: '[name].js' }, devServer: { contentBase: 'views' }, module: { preLoaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'jshint' } ], loaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: { presets: [ 'es2015' ] } }, { test: /\\.less$/, exclude: /node_modules/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader!less-loader&quot;) }, { test: /\\.(jpg|jpeg|png|gif)$/, include: /images/, loader: 'url' } ] }, jshint:{ &quot;failOnHint&quot;: true, 'esnext': true, }, plugins: [ new ExtractTextPlugin(&quot;style.css&quot;, {allChunks: false}) ] }; 目录下就是生成了单独的style.css 而不是插入到页面中, 我们需要在页面中使用style.css 1&lt;link rel=&quot;Stylesheet&quot; type=&quot;text/css&quot; href=&quot;/public/assets/js/style.css&quot;/&gt;","link":"/2016/07/20/technologies-fullstack-2016-07-20-fullstack-webpack-advance/"},{"title":"前端开发系列之Webpack(一):基本使用","text":"在前端开发中使用构建技术已经是标配了，之前我已经写过了Gulp系列，在为什么需要前端构建我也已经讲了前端构建的必要性，相信不少人都使用过Grunt或者Gulp。 由于ReactJS, Angular2的火热，WebPack这个构建工具已经在社区中得到了广泛的认可，而Webpack已经成了React.js开发的标配，所以，我们有必要学习一下Webpack Webpack 是什么？官方网址：https://webpack.github.io/ 我觉得上面的图可以较好的解释webpack做什么，通常我们的前端需要使用模块化来组织代码，那么管理依赖就是比较头痛的一件事，而Webpack把所有的assets都当做一种模块，然后通过webpack输出为我们需要的文件。 Webpack 使用安装和使用 安装webpack npm install webpack -g 新建一个目录 webpack-demo, 然后创建三个文件 index.html 1234567891011&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;&lt;/h2&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; hello.js 12345function SayHello(name) { return &quot;Hello &quot;+ name +&quot;, Welcome to Webpack&quot;;}module.exports=SayHello; main.js 12var hello=require(&quot;./hello.js&quot;);document.querySelector('h2').textContent = hello(&quot;Jack&quot;); 然后，在终端执行 1webpack main.js bundle.js 下面是终端的输出: 12345678jacks-MacBook-Air:webpack-demo jack$ webpack main.js bundle.jsHash: 43eaa05d6fc827ebad1fVersion: webpack 1.13.1Time: 104ms Asset Size Chunks Chunk Namesbundle.js 1.66 kB 0 [emitted] main[0] ./main.js 91 bytes {0} [built][1] ./hello.js 104 bytes {0} [built] 然后，打开index.html,我们可以看到页面输出: 1Hello Jack, Welcome to Webpack 配置上面可以看到，我们只需要调用简单的一个命令，传入对应的参数，webpack就能给我们build出我们需要的bundle.js, 而且可以很好的处理依赖。但是如果我们每次都用命令行传入参数，那么就比较麻烦，webpack给我们提供了配置的方式 webpack默认的配置文件是webpack.config.js，所以我们就在根目录下创建一个webpack.config.js, 内容如下： 123456module.exports = { entry: './main.js', output: { filename: 'bundle.js' }}; 然后我们在控制台输入 1webpack 打开页面我们看到之前一样的结果。 Webpack 开发服务器现在，我们修改文件，就需要到命令行去敲webpack命令，并且刷新浏览器，而webpack-dev-server这个包为我们自动做了这些事，首先安装webpack-dev-server npm install webpack-dev-server -g 然后，我们输入 1webpack-dev-server 我们打开浏览器，输入 http://localhost:8080/webpack-dev-server/index.html 随后，我们修改hello.js为如下 12345function SayHello(name) { return &quot;Hello &quot;+ name +&quot;, Welcome to Webpack, I am webpack dev server&quot;;}module.exports=SayHello; 我们看到页面自动刷新，内容也跟着变了","link":"/2016/07/20/technologies-fullstack-2016-07-20-fullstack-webpack-introduction/"},{"title":"前端开发系列之Webpack(二):Loaders","text":"LoadersWebpack最重要的特性就是Loaders，他的作用，就像Gulp或者Grunt里面的task, 它可以在生成文件之前对文件进行相应的转换。 ES6ES6提供了很多优秀的新特性，在我的ES6+现在就用系列我写了10多篇介绍ES6的文章。 由于现在很多浏览器对ES6的支持还不太好，所以，我们需要使用转换器，webpack里就是loader来进行转换。 接上文的代码 我们先修改hello.js 12345 let hello=(name)=&gt;{ return &quot;Hello &quot;+ name +&quot;, Welcome to Webpack, I am webpack dev server&quot;;}; module.exports=hello; 由于Chrome已经支持了很多ES6的特性，所以我们打开Safari浏览器。 我们发现浏览器的console里输出 1SyntaxError: Unexpected identifier 'hello' 说明，我们浏览器还不能支持let, 那么我们需要使用babel这个loader来进行转换，我们先把hello.js 安装babel loader 1npm install babel-loader babel-core babel-preset-es2015 --save-dev 配置webpack使用babel-loader 123456789101112131415161718module.exports = { entry: './main.js', output: { filename: 'bundle.js' }, module: { loaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015'] } } ], }}; loaders是一个数组，是webpack使用的loader的集合，上面的意思就是 使用babel-loader处理所有以.js后缀的文件，但是忽略node_modules下的。 query参数是指babel使用的参数。 然后我们Ctrl+C结束webpack-dev-server，然后再输入webpack-dev-server重启，这个时候我们看到safari浏览器已经渲染正常了。 CSSwebpack也可以很好的管理我们的css依赖。 我们安装 1npm install style-loader css-loader css-loader是加载我们的css,style-loader把读取到的css内容全部插入到页面中。 我们创建一个main.css 1234h2 { background: green; color: yellow;} 在之前的webpack.config.js的loaders数组里添加如下 12345{ test: /\\.css$/, exclude: /node_modules/, loader: 'style!css'} webpack对一个文件可以使用多个loader,顺序是从右向左，中间用!分开，这个类似于gulp里的pipe, 不过语法也太wired了。 完整的配置如下: 12345678910111213141516171819202122232425module.exports={ entry: './main.js', output: { filename: 'bundle.js' }, module: { loaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: { presets: [ 'es2015' ] } }， { test: /\\.css$/, exclude: /node_modules/, loader: 'style!css' } ], }}; 重启webpack-dev-server, 浏览器显示如下 less现在很少有人使用css, 都会使用SASS, LESS之类的，那么我们把main.css改为main.less, 修改内容如下 1234567@nice-blue: #5B83AD;@light-blue: @nice-blue + #111;h2 { background: @light-blue; color: yellow;} 安装对应的loaders 1npm install less less-loader --save-dev 修改main.js中 require(‘./main.css’)为require(‘./main.less’) 12345require('./main.less');var hello=require(&quot;./hello.js&quot;);document.querySelector('h2').textContent = hello(&quot;Jack&quot;); 修改webpack.config.js 12345678910111213141516171819202122232425module.exports={ entry: './main.js', output: { filename: 'bundle.js' }, module: { loaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: { presets: [ 'es2015' ] } }, { test: /\\.less$/, exclude: /node_modules/, loader: 'style!css!less' } ], }}; 重启webpack-dev-server, 我们看到h2背景色已经变为#6c94be url-loader如果我们css里使用了url,或者js里require了一个image,那么我们就需要安装url-loader 1npm install url-loader --save-dev 修改main.less 12345678910111213@nice-blue: #5B83AD;@light-blue: @nice-blue + #111;h2 { background: @light-blue; color: yellow;}#aboutMe { width: 200px; height: 200px; background: url('./images/me.jpeg');} 修改index.html 123456789101112&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;aboutMe&quot;&gt;&lt;/div&gt; &lt;h2&gt;&lt;/h2&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2016/07/20/technologies-fullstack-2016-07-20-fullstack-webpack-loaders/"},{"title":"前端开发系列之Webpack(三):Preloaders","text":"PreloadersPreloader就是在调用loader之前需要调用的loader, 他不做任何代码的转换，只是进行检查。 JSHint我们比较常用的一个Preloader就是JSHint, 对我们JS代码进行检查. 接之前代码: 安装jshint-loader 1npm install jshint jshint-loader --save-dev 修改 webpack.config.jshint 1234567891011121314151617181920212223242526272829303132333435363738module.exports = { entry: './main.js', output: { filename: 'bundle.js' }, module: { preLoaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'jshint' } ], loaders: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel', query: { presets: [ 'es2015' ] } }, { test: /\\.less$/, exclude: /node_modules/, loader: 'style!css!less' }, { test: /\\.(jpg|jpeg|png|gif)$/, include: /images/, loader: 'url' } ],} }; 指定JSHint使用es6. 1234567891011module: { preLoaders: [ ... ], loaders: [ ... ]},jshint: { esversion: 6} 删掉hello.js里的一个;号，然后重启webpack-dev-server 12345678910WARNING in ./hello.jsjshint results in errors'let' is available in ES6 (use 'esversion: 6') or Mozilla JS extensions (use moz). @ line 1 char 1 let hello=(name)=&gt;{ 'arrow function syntax (=&gt;)' is only available in ES6 (use 'esversion: 6'). @ line 1 char 16 let hello=(name)=&gt;{ Missing semicolon. @ line 3 char 2 }","link":"/2016/07/20/technologies-fullstack-2016-07-20-fullstack-webpack-preloaders/"},{"title":"程序员之网络安全系列（三）：数据加密之对称加密算法","text":"前文回顾假如，明明和丽丽相互不认识，明明想给丽丽写一封情书，让隔壁老王送去 如何保证隔壁老王不能看到情书内容？（保密性) 如何保证隔壁老王不修改情书的内容？（完整性) 如何保证隔壁老王不冒充明明？（身份认证) 如何保证明明不能否认情书是自己写的？（来源的不可否认) 上一节，我们使用了Hash算法保证了情书的完整性，也就是确保“隔壁王叔叔”没有修改明明的情书，那么这一节我们来看看如何保证“隔壁王叔叔”不能看到情书的内容，也就是保密性。 数据加密要想不让别人看到数据，那么我们就们就需要对数据加密。 加密技术 是最常用的安全保密手段，利用技术手段把重要的数据变为乱码（加密）传送，到达目的地后再用相同或不同的手段还原（解密）。加密包括两个元素：算法和密钥。一个加密算法是将普通的文本（或者可以理解的信息）与一窜数字（密钥）的结合，产生不可理解的密文的步骤，密钥是用来对数据进行编码和解码的一种算法。 举个例子： 假设我们要对LOVE加密，我们可以先定义字母的顺序ABCDEFGHIJKLMNOPQRSTUVWXYZ，然后我们让每个字母向后移动两位，那么LOVE就变为了NQXG L------&gt;N O------&gt;Q V------&gt;X E------&gt; LOVE---&gt;NQXG 我想这就是最简单的加密方式。 密钥加密技术的密码体制分为对称密钥体制和非对称密钥体制两种。 对数据加密的技术分为两类，即对称加密（私人密钥加密）和非对称加密（公开密钥加密）。对称加密以数据加密标准（DES，Data Encryption Standard）算法为典型代表，非对称加密通常以RSA（Rivest Shamir Ad1eman）算法为代表。对称加密的加密密钥和解密密钥相同，而非对称加密的加密密钥和解密密钥不同，加密密钥可以公开而解密密钥需要保密。 对称加密对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥。比如，我们给WORD文档设置密码1234, 那么其他人想要打开文档也必须输入1234才能打开。 常用加密算法: DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。 3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。 AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高； RC4，也是为 RSA Data Security, Inc. 开发的密码系统的商标名称。 传统的DES由于只有56位的密钥，从1997年开始，RSA公司发起了一个称作“向DES挑战”的竞技赛。在首届挑战赛上，罗克·维瑟用了96天时间破解了用DES加密的一段信息。1999年12月22日，RSA公司发起“第三届DES挑战赛（DES Challenge III）”。2000年1月19日，由电子边疆基金会组织研制的25万美元的DES解密机以22.5小时的战绩，成功地破解了 DES加密算法。DES已逐渐完成了它的历史使命。 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 对称加密算法的优点： 算法公开 计算量小 加密速度快，加密效率高 对称加密算法的缺点 加解密双方需要使用相同的秘钥 秘钥管理很不方便，如果用户很多，那么秘钥的管理成几何性增长 任何一方秘钥泄露，数据都不安全了 最后通过本节，我们知道当明明给丽丽情书时，可以用DES或者AES对数据进行加密，即使“隔壁王叔叔”拿到信件也看不懂内容，同时使用上一节的Hash算法保证了情书的内容完整，但是这就需要明明和丽丽提前设置一个秘钥。 代码示例下面的代码输出如下结果 I Love You, Li Li Encrypeted: 0t9glwGMmwtGs8B4QCotyZkKf091WElCwG659QiVVw0= Decrypeted: I Love You, Li Li .NET 源码： using System; using System.Security.Cryptography; using System.IO; using System.Text; namespace AES { class MainClass { public static void Main (string[] args) { string password = &quot;Don't believe wang shu shu&quot;; string orginTextToSent = &quot;I Love You, Li Li&quot;; Console.WriteLine (orginTextToSent); string encryptedText=EncryptText(orginTextToSent, password); Console.WriteLine (&quot;Encrypeted: &quot; + encryptedText); string DecryptedText = DecryptText (encryptedText, password); Console.WriteLine (&quot;Decrypeted: &quot; + DecryptedText); } public static byte[] AES_Encrypt(byte[] bytesToBeEncrypted, byte[] passwordBytes) { byte[] encryptedBytes = null; // Set your salt here, change it to meet your flavor: // The salt bytes must be at least 8 bytes. byte[] saltBytes = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }; using (MemoryStream ms = new MemoryStream()) { using (RijndaelManaged AES = new RijndaelManaged()) { AES.KeySize = 256; AES.BlockSize = 128; var key = new Rfc2898DeriveBytes(passwordBytes, saltBytes, 1000); AES.Key = key.GetBytes(AES.KeySize / 8); AES.IV = key.GetBytes(AES.BlockSize / 8); AES.Mode = CipherMode.CBC; using (var cs = new CryptoStream(ms, AES.CreateEncryptor(), CryptoStreamMode.Write)) { cs.Write(bytesToBeEncrypted, 0, bytesToBeEncrypted.Length); cs.Close(); } encryptedBytes = ms.ToArray(); } } return encryptedBytes; } public static byte[] AES_Decrypt(byte[] bytesToBeDecrypted, byte[] passwordBytes) { byte[] decryptedBytes = null; // Set your salt here, change it to meet your flavor: // The salt bytes must be at least 8 bytes. byte[] saltBytes = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }; using (MemoryStream ms = new MemoryStream()) { using (RijndaelManaged AES = new RijndaelManaged()) { AES.KeySize = 256; AES.BlockSize = 128; var key = new Rfc2898DeriveBytes(passwordBytes, saltBytes, 1000); AES.Key = key.GetBytes(AES.KeySize / 8); AES.IV = key.GetBytes(AES.BlockSize / 8); AES.Mode = CipherMode.CBC; using (var cs = new CryptoStream(ms, AES.CreateDecryptor(), CryptoStreamMode.Write)) { cs.Write(bytesToBeDecrypted, 0, bytesToBeDecrypted.Length); cs.Close(); } decryptedBytes = ms.ToArray(); } } return decryptedBytes; } public static string EncryptText(string input, string password) { // Get the bytes of the string byte[] bytesToBeEncrypted = Encoding.UTF8.GetBytes(input); byte[] passwordBytes = Encoding.UTF8.GetBytes(password); // Hash the password with SHA256 passwordBytes = SHA256.Create().ComputeHash(passwordBytes); byte[] bytesEncrypted = AES_Encrypt(bytesToBeEncrypted, passwordBytes); string result = Convert.ToBase64String(bytesEncrypted); return result; } public static string DecryptText(string input, string password) { // Get the bytes of the string byte[] bytesToBeDecrypted = Convert.FromBase64String(input); byte[] passwordBytes = Encoding.UTF8.GetBytes(password); passwordBytes = SHA256.Create().ComputeHash(passwordBytes); byte[] bytesDecrypted = AES_Decrypt(bytesToBeDecrypted, passwordBytes); string result = Encoding.UTF8.GetString(bytesDecrypted); return result; } } }","link":"/2016/01/10/technologies-security-2016-1-10-security-3/"},{"title":"程序员之网络安全系列（四）：数据加密之非对称秘钥","text":"前文回顾假如，明明和丽丽相互不认识，明明想给丽丽写一封情书，让隔壁老王送去 如何保证隔壁老王不能看到情书内容？（保密性) 如何保证隔壁老王不修改情书的内容？（完整性) 如何保证隔壁老王不冒充明明？（身份认证) 如何保证明明不能否认情书是自己写的？（来源的不可否认) 但是上面的问题是明明和丽丽必须提前知道秘钥，但是如果双方提前不知道秘钥，那么明明就需要“隔壁的王叔叔” 把秘钥告诉丽丽，这个显然是风险太大了，因为”隔壁王叔叔“有了秘钥和密文，那么就等于有了明文。 非对称秘钥DH（Diffie-Hellman）算法1976年，美国学者Dime和Henman为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。相对于“对称加密算法”这种方法也叫做“非对称加密算法”。 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey)。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 算法原理及示例 假如明明和丽丽希望交换一个密钥。 明明取一个素数p =97和97的一个原根a=5，让隔壁的王叔叔告诉丽丽。 明明和丽丽分别选择秘密密钥XA=36和XB=58，并计算各自的公开密钥，然后让隔壁的王叔叔帮忙交换公开秘钥。 YA=a^XA mod p=5^36 mod 97=50 YB=a^XB mod p=5^58 mod 97=44 明明和丽丽交换了公开密钥之后，计算共享密钥如下： 明明：K=(YB) ^XA mod p=44^36 mod 97=75 丽丽：K=(YA) ^XB mod p=50^58 mod 97=75 由于只有明明知道XA, 而只有丽丽知道XB, 那么“隔壁的王叔叔” 是不可能通过 P, A, YA, YB来得到最终密码K的。 DiffieˉHellman不是加密算法，它只是生成可用作对称密钥的秘密数值。 非对称加密特点 与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果 用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 那么如果甲(收信方)想收到只有自己才能解读的加密信息，那么需要把自己的公钥告诉乙(发送发), 乙通过甲的公钥加密，把加密后的密文告诉甲，由于只有甲有私钥，那么也就只有甲才能加密。 由此可见，非对称加密只需要保存一对公钥和私钥，大大方便了秘钥管理。但是由于要做更多的计算，非对称加密只适合一些小数据量加密，一般情况都是用非对称加密算法来交换秘钥，随后通过对称加密算法来加密数据。 常用非对称加密算法RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。 使用最广泛的是RSA算法，Elgamal是另一种常用的非对称加密算法。 最后我们对数据的完整性使用Hash进行了保证，用DH算法交换了秘钥，使用RSA算法对数进行了加密，那么如果王叔叔在交换秘钥的过程中做了手脚呢？ 如何做手脚？看下图： 王叔叔自己生成一个公私钥，和明明以及丽丽交换。 王叔叔冒充丽丽把自己的公钥发给明明。 明明用王叔叔的公钥对信件加密。 王叔叔用自己的私钥解密就可以看到明明给丽丽的邮件。 王叔叔冒充明明把自己的公钥发给丽丽。 丽丽用王叔叔的公钥对信件加密。 王叔叔用自己的私钥解密就可以看到丽丽给明明内容。 至此，邮件内容又赤裸裸地被王叔叔看到了，怎么办呢？我们下文继续解释。","link":"/2016/01/10/technologies-security-2016-1-10-security-4/"},{"title":"程序员之网络安全系列（五）：数字证书以及12306的证书问题","text":"前文回顾假如，明明和丽丽相互不认识，明明想给丽丽写一封情书，让隔壁老王送去 如何保证隔壁老王不能看到情书内容？（保密性) 如何保证隔壁老王不修改情书的内容？（完整性) 如何保证隔壁老王不冒充明明？（身份认证) 如何保证明明不能否认情书是自己写的？（来源的不可否认) 我们使用了非对称密钥算法，我们让“隔壁王叔叔”传递了秘钥。 中间人攻击上面几步还是不够的，比如王叔叔在交换秘钥的过程中做了手脚呢？ 如何做手脚？看下图： 王叔叔自己生成一个公私钥，和明明以及丽丽交换。 王叔叔冒充丽丽把自己的公钥发给明明。 明明用王叔叔的公钥对信件加密。 王叔叔用自己的私钥解密就可以看到明明给丽丽的邮件。 王叔叔冒充明明把自己的公钥发给丽丽。 丽丽用王叔叔的公钥对信件加密。 王叔叔用自己的私钥解密就可以看到丽丽给明明内容。 那么明明如何知道王叔叔给的公钥就是丽丽的公钥呢？那么就引入了数字证书 数字证书概念介绍那么王叔叔要让明明相信他给的公钥就是丽丽的公钥，那么他可以开一个证明，比如找权威机构“敏捷的水”给开个介绍信，介绍信上给加个公章。那么这里的介绍性就是数字证书, 公章就是数字签名, 那么”敏捷的水”就是颁发证书的机构CA(Certificate Authority)，也就是证书授权中心。 CA CA 是“Certificate Authority”的缩写，也叫“证书授权中心”。它是负责管理和签发证书的第三方机构，就好比例子里面的“敏捷的水”。一般来说，CA 必须是大家都信任的、认可的。因此它必须具有足够的权威性。只有明明和丽丽都信任的人才能来证明，对吧？ CA证书: CA 证书，就是CA颁发的证书。 证书之间的信任关系: 用一个证书来证明另一个证书是真实可信。 证书信任链: 证书之间的信任关系，是可以嵌套的。比如，A 信任 A1，A1 信任 A2，A2 信任 A3……,这就是证书的信任链。只要你信任链上的第一个证书，那后续的证书，都是可以信任的。 根证书(Root Certificate): 下图，处于最顶上的树根位置的那个证书，就是“根证书”。除了根证书，其它证书都要依靠上一级的证书来证明自己。那谁来证明“根证书”？根证书自己证明自己，这时候我们用户就需要自己选择是否相信某个根证书。 根证书是整个证书体系安全的根本。如果某个证书体系中，根证书不再可信了，那么所有被根证书所信任的其它证书，也就不再可信了。 证书内容我们看一下亚马逊的证书，当我们点击浏览器左边绿色的锁时，我们可以看到如下的证书。 我们挑重点的解释一下 Issuer (证书的发布机构)指出是什么机构发布的这个证书，也就是指明这个证书是哪个公司创建的(只是创建证书，不是指证书的使用者)。对于上面的这个证书来说，就是指”Symantec Corporation”这个机构。 Not valid before, Not valid after (证书的有效期) Public key (公钥) 这个我们在前面介绍公钥密码体制时介绍过，公钥是用来对消息进行加密的。 Subject (主题) 这个证书是发布给谁的，或者说证书的所有者，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等。 Signature algorithm (签名所使用的算法) 就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥，根据这个算法对指纹进行解密，指纹的加密结果就是数字签名。 Thumbprint, Thumbprint algorithm (指纹以及指纹算法) 这个是用来保证证书的完整性的，也就是说确保证书没有被修改过，其原理就是在发布证书时，发布者根据指纹算法(一个hash算法)计算整个证书的hash值(指纹)并和证书放在一起，使用者在打开证书时，自己也根据指纹算法计算一下证书的hash值(指纹)，如果两者一致，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的hash值(指纹)是会变化的。 注意，这个指纹会使用CA这个证书机构的私钥用签名算法(Signature algorithm)加密后和证书放在一起，只有用CA的公钥才能解开这个签名。 证书是如何保证身份认证的申请证书： Amazon.com 向Symantec 公司(CA) 申请证书。 Symantec(CA) 生成一对公钥A和私钥B。 Symantec(CA) 有自己的公钥C和私钥D。 Symantec(CA) 把Issuer,公钥A,Subject(一般是网站的域名),Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个指纹算法(SHA1或者MD5)计算出这些数字证书内容的一个指纹(摘要)，并把指纹和指纹算法用自己的私钥D进行加密，然后和证书的内容一起发给Amazon.com。 Symantec(CA) 把私钥B给Amazon.com. 如何使用证书 用户访问amazon.com 这个网站 amazon.com 把证书发给用户 浏览器读取证书。 浏览器发现证书机构是Symantec，然后会在操作系统中受信任的发布机构的证书中去找Symantec的证书，如果找不到，那说明证书的发布机构是个假的，或者不是被权威机构认证的，证书可能有问题，程序会给出一个错误信息。 如果在系统中找到了Symantec的证书，那么应用程序就会从证书中取出Symantec的公钥C，然后对amzon.com公司的证书里面的指纹和指纹算法用这个公钥C进行解密，然后使用这个指纹算法计算amazon.com证书的指纹，将这个计算的指纹与放在证书中的指纹对比，如果一致，说明amazon.com的证书肯定没有被修改过并且证书是Symantec发布的，证书中的公钥肯定是amazon.com的公钥A, 然后我们就可以用这个公钥A和amazon.com进行通信，因为只有amazon.com 有私钥B, 所以只有amazon.com才能解开信息。 注意 权威机构的证书都是内置在操作系统里的。 由此可见，一个证书受不受信任，那就要看你要不要添加到操作系统里，权威的认证机构的证书都内置在操作系统里的。 另外，我们自己也可以制作自签名的证书，但是需要别人认可你，这个在企业内部或者开发阶段是可以，我们可以自己制作一个证书添加到操作系统里。 那么，问题来了，当你访问https://www.12306.cn 时，你就会得到下面的结果 这是为什么呢？ 我相信你看完本文应该清楚，那是因为12306 自己给自己发了个证书，而这个证书默认是没有被操作系统信任， 但是当我把根证书添加到操作系统后，依然是https://www.12306.cn 不行，然后我发现是证书对应的域名不对,证书对应的域名是https://kyfw.12306.cn 访问这个域名后，虽然证书验证通过，但是浏览器的锁还是没有变绿。 为什么呢？ 看提示，是因为12306使用了一个比较弱的机密算法（This site uses a weak security configuration (SHA-1 signatures), so your connection may not be private.），我猜他们是为了性能？？ 但是，就算浏览器地址栏的锁不能变绿，我们还得订票不是吗？ 我觉得12306可能需要一个操作系统内置的认证机构来发一个证书，不然普通的用户根本不知道怎么安装证书，如果不使用https，那么安全性如何得到保证呢？ 最后回到开头的例子，明明和丽丽可以找一个权威机构来发一个证书，而且自己都内置了这个权威机构的证书。当王叔叔把丽丽的证书给明明时，明明就可以知道证书是不丽丽给的，因此就可以确定证书里的公钥是否是丽丽的，如果可以确定是丽丽的，那么就可以确保加密的内容只有丽丽可以解开，因为只有丽丽有对应的私钥。","link":"/2016/01/11/technologies-security-2016-1-11-security-5/"},{"title":"程序员之网络安全系列（六）：动态密码","text":"前文回顾 我们使用了数字证书，确保了对方的公钥身份，也就是互联网中确定了要访问的网站就是你要访问的网站。 但是我们如何确定要访问这个网站的用户就是要访问的用户呢？ 对银行来说需要确保“敏捷的水”登录银行时，必须是”敏捷的水” 而不是别人，不然别人就把钱转走了。 虽然我们从通信，数据加密等方式确保用户密码不背攻击者破解，但是如果攻击者使用键盘记录器等工具知道了用户密码，那么就可以冒充用户了。 比如银行的U盾，因为我对这块业务不了解，我猜银行为每个用户发放了一个公钥？（ 知道的同学，可以帮忙解释一下银行的U盾都做了什么? ) 我们用数字证书确定了银行的身份，那么银行如何确定我们的身份呢？ 两步验证那么什么是两步认证呢？两步认证就是在每次登陆时候填一个手机短信收取的验证码或者手机应用生成的验证码。当然接收验证码的手机号或者应用是需要绑定的，这样只有拿到这部手机并且知道你帐号密码的人才能登陆帐号。 为什么需要它？对有些人来说，盗取密码比您想象的更简单 以下任意一种常见操作都可能让您面临密码被盗的风险： 在多个网站上使用同一密码 从互联网上下载软件 点击电子邮件中的链接 想像一下您无法访问自己的帐户及其中的内容，当别有用心的人盗取您的密码后，他们能让您无法访问自己的帐户，还可以执行以下操作： 翻看（甚至删除）您所有的电子邮件、联系人、照片等 冒充您给您的联系人发送垃圾邮件或有害的电子邮件 使用您的帐户重置您其他帐户（银行帐户、购物帐户等）的密码 两步验证可以将别有用心的人阻挡在外，即使他们知道您的密码也无可奈何。 如何工作？现在大部分比较危险的操作都需要绑定手机号，因为手机号是你用的唯一的。接收到验证码后，我们再输入系统做第二次的验证。 但是由于我们这个验证码也有可能丢失，那么我们只需要让他在一定时间有效就可以了，这就是OTP. 动态口令 (One Time Password)动态密码： 一个OTP(One Time Password) 是一个密码仅用于一次登录会话或者交易，使用过后，这个密码就无效了。 静态密码的问题： 容易被破解 容易被猜测 容易被盗劫 针对不同的网站，用户需要记忆大量的密码。 使用动态口令主要有2个方面价值： 防止由于盗号而产生的财产损失。 采用动态口令的单位无需忍受定期修改各种应用系统登录密码的烦恼。 有两种方法，生成动态密码： Event-based OTP (EOTP)基于事件同步的令牌，其原理是通过某一特定的事件次序及相同的种子值作为输入，在DES算法中运算出一致的密码，其运算机理决定了其整个工作流程同时钟无关，不受时钟的影响，令牌中不存在时间脉冲晶振。但由于其算法的一致性，其口令是预先可知的，通过令牌，你可以预先知道今后的多个密码，故当令牌遗失且没有使用PIN码对令牌进行保护时，存在非法登陆的风险，故使用事件同步的令牌，对PIN码的保护是十分必要的。同样，基于事件同步的令牌同样存在失去同步的风险，例如用户多次无目的的生成口令等，对于令牌的失步，事件同步的服务器使用增大偏移量的方式进行再同步，其服务器端会自动向后推算一定次数的密码，来同步令牌和服务器，当失步情况已经非常严重，大范围超出正常范围时，通过连续输入两次令牌计算出的密码，服务器将在较大的范围内进行令牌同步，一般情况下，令牌同步所需的次数不会超过3次。但在极端情况下，不排除失去同步的可能性，例如电力耗尽，在更换电池时操作失误等。此时，令牌仍可通过手工输入由管理员生成的一组序列值来实现远程同步，而无需寄回服务器端重新同步。 Time based OTP (TOTP)基于令牌和服务器的时间同步，通过运算来生成一致的动态口令，基于时间同步的令牌，一般更新率为60S，每60S产生一个新口令，但由于其同步的基础是国际标准时间，则要求其服务器能够十分精确的保持正确的时钟，同时对其令牌的晶振频率有严格的要求，从而降低系统失去同步的几率，从另一方面，基于时间同步的令牌在每次进行认证时，服务器端将会检测令牌的时钟偏移量，相应不断的微调自己的时间记录，从而保证了令牌和服务器的同步，确保日常的使用，但由于令牌的工作环境不同，在磁场，高温，高压，震荡，入水等情况下易发生时钟脉冲的不确定偏移和损坏，故对于时间同步的设备进行较好的保护是十分必要的。对于失去时间同步的令牌，目前可以通过增大偏移量的技术（前后10分钟）来进行远程同步，确保其能够继续使用，降低对应用的影响，但对于超出默认时间（共20分钟）的同步令牌，将无法继续使用或进行远程同步，必须返厂或送回服务器端另行处理。同样，对于基于时间同步的服务器，应较好地保护其系统时钟，不要随意更改，以免发生同步问题，从而影响全部基于此服务器进行认证的令牌。 ** 以上两种方式在生成密码的过程都不需要与服务器通信，所以极大的保证了密码的安全。** 算法的实现http://tools.ietf.org/html/rfc6238","link":"/2016/01/12/technologies-security-2016-1-12-security-6/"},{"title":"程序员之网络安全系列（一）：为什么要关注网络安全？","text":"假如，明明和丽丽相互不认识，明明想给丽丽写一封情书，让隔壁老王送去 如何保证隔壁老王不能看到情书内容？（保密性) 如何保证隔壁老王不修改情书的内容？（完整性) 如何保证隔壁老王不冒充明明？（身份认证) 如何保证明明不能否认情书是自己写的？（来源的不可否认) 前言大家都知道最近几年闹的沸沸扬扬的网络安全事件，之前的CSDN密码泄露，不久前的网易邮箱密码泄露，那么如果你的密码泄露，除了本身的网站外，还有很多人其它很多地方甚至银行密码都使用相同的密码，从而带来了很大的麻烦，据说“半个” 互联网的库都被人拖过。 亲身经历拿我自己经历的一件事来说，前不久，我和一个朋友一起定了趟机票去上海，出发前两小时，收到一个短信说我预定的航班由于天气原因被取消，我需要改签另一个航班，让我拨打航空公司400的电话，由于马上要出发去机场，也没有去查具体航空公司的电话，就打了这个电话，对方的整套系统客服系统和流程几乎和航空公司一模一样，知道我的姓名，身份证，订的航班号等等都一清二楚，最后再说改签需要给用户补偿，需要给你转钱，所以你需要提供银行卡号，然后确认后才能改签，我这样说大家可能觉得如果是自己不太可能上当，但是你们都忽略了人的心里因素，第一你的私密信息他都知道（就像一个陌生人让你爸转钱说你需要钱，说是你的好朋友，知道你的所有只有你爸和你知道的信息), 第二你很着急，因为你在目的地的酒店已定，后面去别的地方的机票、火车票已定，所以你必须这个时间起飞等等。 最后我没有上当的原因，是因为我问骗子，航站楼是哪一个，他说是4号航站楼，因为西安就没有4号航站楼，当然这个应该是骗子的失误。 我们所有的人觉得自己百分之百不会上当的人，那是因为你没碰上骗子高手！ 骗子可以得逞的罪魁祸首我总结了大部分骗子能够骗成功的最主要的原因，是因为我们的私密信息被泄露了！可见网络安全的重要性，而针对我的这个事件，我不知道是航空公司还是某订票网站把我的信息泄露，当然，骗子可能组合多个地方的泄露信息。 而这些信息系统是谁开发和维护的呢？ 是程序员！ 所以我们程序员需要学习安全知识，保护用户数据，同时防止自己被骗，对那些安全性不高的网站尽量不要使用，对那些安全不高的系统尽量不使用。 作为一个多年的程序员，我对网络安全相关的知识也非常少，我知道一些常规的东西，比如敏感数据加密存储，网站尽量使用https等，但是由于对后面的原理知道的太少，所以有的时候不一定做出了正确地选择，直到最近有的程序员说密码MD5存储了，就一定是安全的，这让我感觉了害怕，而且我看有的系统也真的只是MD5了一下，所以我开始决定学点安全的常识，记录一点“大家” 常用的程序安全知识, 在这里和大家共同进步，由于我对这对理解的不深，要学习的东西很多，所以也希望大家帮忙指出错误的地方。","link":"/2016/01/07/technologies-security-2016-1-8-security-1/"},{"title":"程序员之网络安全系列（二）：如何安全保存用户密码及哈希算法","text":"前言在很多网站的早期，甚至是现在仍然有一些网站，当你点击忘记密码功能时，你的邮箱会收到一封邮件，然后里面赫然写着你的密码，很多普通用户还会觉得庆幸，总算是找回来了，殊不知，这是多么可怕地一件事，说明了网站是“几乎是”明文存储你的密码，一旦数据用户数据泄露或者被拖库，那么用户密码将赤裸裸的暴露了，想想之前几次互联网密码泄露事件。 那么如何解决呢？ 加密为了不让密码明文存储，我们需要对密码进行加密，这样即使数据库用户密码暴露，也是加密后的。但是如何让加密后的数据难以解密呢？我们现在比较流行的做法就是把密码进行Hash存储。 Hash哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式. 典型的哈希算法包括 MD2、MD4、MD5 和 SHA-1 Hash算法是给消息生成摘要，那么什么是摘要呢？ 举个例子： 比如你给你女朋友写了一封邮件，确保没被人改过，你可以生成这样一份摘要 “第50个字是我，第100个字是爱， 第998个字是你”，那么你女朋友收到这个摘要，检查一下你的邮件就可以了。 Hash算法有两个非常主要的特征： 不能通过摘要来反推出原文 原文的非常细小的改动，都会引起Hash结果的非常大的变化 因此，这个比较适合用来保存用户密码，因为不能反推出用户密码，Hash结果一致就证明原文一致，我们来用Ruby代码试一下上面的第二点 （MD5是一种常用的Hash算法) 2.2.3 :003 &gt; require 'digest/md5.so' =&gt; true 2.2.3 :004 &gt; puts Digest::MD5.hexdigest('I love you') e4f58a805a6e1fd0f6bef58c86f9ceb3 =&gt; nil 2.2.3 :005 &gt; puts Digest::MD5.hexdigest('I love you!') 690a8cda8894e37a6fff4d1790d53b33 =&gt; nil 2.2.3 :006 &gt; puts Digest::MD5.hexdigest('I love you !') b2c63c3ca6019cff3bad64fcfa807361 =&gt; nil 2.2.3 :007 &gt; puts Digest::MD5.hexdigest('I love you') e4f58a805a6e1fd0f6bef58c86f9ceb3 =&gt; nil 2.2.3 :008 &gt; 那么我们在使用MD5保存密码时候的验证流程是什么呢？ 用户注册时，把用户密码是MD5(password)后保存到数据库。 用户输入用户名和密码 服务器从数据库查找用户名 如果有这个用户，A=MD5(input password), B=Database password 如果A==B, 那么说明用户密码输入正确，如果不相等，用户输入错误。 为什么Hash(MD5)后仍然不够安全？穷举但是，如果你认为就只是这样密码就不会被人知道，那么就不对了，这只是比明文更安全，为什么？ 因为，大部分人的密码都非常简单，当拿到MD5的密码后，攻击者也可以通过比对的方式，比如你的密码是4218 2.2.3 :008 &gt; puts Digest::MD5.hexdigest('4218') d278df4919453195d221030324127a0e 那么攻击者可以把1到4218个数字都MD5一下，然后和你密码的MD5对比一下，就知道你原密码是什么了。 曾经我的密码箱密码忘了，我把锁给撬了，后来我才想起可以用穷举法，最多就999次不就打开了？那么问题来了，你的密码箱还安全吗？ 彩虹表除了穷举法外，由于之前的密码泄露，那么攻击者们，手上都有大量的彩虹表，比如”I love you”,生日等等，这个表保存了这些原值以及MD5后的值，那么使用时直接从已有库里就可以查出来对应的密码。 加盐 Salt那么，由于简单的对密码进行Hash算法不够安全，那么我们就可以对密码加Salt，比如密码是”I love you”, 虽然彩虹表里有这条数据，但是如果加上”安红我爱你”，这样MD5结果就大不一样. jacks-MacBook-Air:~ jack$ irb 2.2.3 :001 &gt; require 'digest/md5.so' =&gt; true 2.2.3 :002 &gt; puts Digest::MD5.hexdigest('I love you') e4f58a805a6e1fd0f6bef58c86f9ceb3 =&gt; nil 2.2.3 :003 &gt; puts Digest::MD5.hexdigest('I love you安红我爱你') b10d890bf46b1a045eb99af5d43c7b13 =&gt; nil 2.2.3 :004 &gt; puts Digest::MD5.hexdigest('I dont love you') c82294c9a7b6e4a372ad25ed4d6011c9 =&gt; nil 2.2.3 :005 &gt; puts Digest::MD5.hexdigest('I dont love you安红我爱你') dce67bcdfdf007445dd4a2c2dc3d29c1 =&gt; nil 2.2.3 :006 &gt; 如此一来，因为攻击者很难猜到“安红我爱你”，那么自然彩虹表里是没有的，当然我建议你在实际项目中不要使用”安红我爱你”，你应该使用一个连你自己都猜不到的较长的字符串。 加盐了，就安全了吗？实际上，加盐并不能100%保证安全，假如有人泄露了你的Salt呢？实际上通过反编译程序很容易可以拿到这个，由于WEB程序一般放在WEB服务器上，那么就需要保证服务器不被攻击，当然这个是运维人员去操心。 为了让加盐更安全，一般情况下我们可以使用一个“盐+盐”，也就是为每个用户保存一个”Salt”， 然后再使用全局的盐，我们可以对用户的盐使用自己的加密算法。那么代码就如下: if MD5(userInputPpassword+globalsalt+usersalt)===user.databasePassword） { login success } 普通用户如何做？由于这个是写给程序员，当然是说在前端用户注册时密码应该如何设置，很简单，我们要求用户必须输入强密码！但是，我知道很多用户觉得很烦，这样你就失掉了一个用户，但我们需要做一个适当的折中，比如至少有一个大写字母，小写字母和数字的组合。 最后我们来看看解决了之前文章下面例子的什么问题。 假如，明明和丽丽相互不认识，明明想给丽丽写一封情书，让隔壁老王送去 如何保证隔壁老王不能看到情书内容？（保密性) 如何保证隔壁老王不修改情书的内容？（完整性) 如何保证隔壁老王不冒充明明？（身份认证) 如何保证明明不能否认情书是自己写的？（来源的不可否认) 通过了解hash算法,”明明” 就有办法让丽丽知道信的内容没有修改，他可以对邮件进行Hash生成邮件的摘要，然后让”隔壁的李叔叔”把摘要送给丽丽，丽丽拿到邮件的摘要后，把邮件内容也Hash一下，然后把结果和”隔壁的李叔叔”给的摘要对比一下，然后通过比较结果就知道邮件有没有被”隔壁的王叔叔”更改过了。","link":"/2016/01/09/technologies-security-2016-1-9-security-2/"},{"title":"iOS UI系列 (一) ：Auto Layout 高度三等分","text":"img { max-width: 900px; border: solid 2px #ccc; padding: 5px; border-radius:5px; } 首先我们创建一个Single View Application 然后我们向StoryBoard的ViewController 添加3个UIView, 设置不同的背景色，我们的目的是让这三个UIView垂直高度三等分。 接下来我们需要设置约速，我们让每个试图和周围的具体都是5，然后设置三个视图等高约束，具体看gif动态图, 如果看不清 右键图片–&gt;open in new Tab","link":"/2015/07/27/technologies-iOS-2015-07-27-ios-ui-autolayout-three-equal-height/"},{"title":"iOS UI系列 (二) ：使用多个StoryBoard","text":"img { max-width: 700px; border: solid 2px #ccc; padding: 5px; border-radius:5px; } 为什么要使用多个StoryBoardStoryBoard 给项目带了很大的方便，在一个视图里可以看到整个项目页面之间的关系，但是如果项目所有的页面都放到一个StoryBoard, 会带来以下一些问题 UIStoryBoard太大 每次打开StoryBoard比较慢 一个窗口里面显示所有的View，显得比较混乱，尤其是一个显示器看不全的时候 UIStoryBoard 项目解决源码冲突太麻烦 所以，我建议项目使用多个StoryBoard, 不同模块使用不同的UIStoryBoard, 下面是如何使用的实例。 Main Storyboard首先建立一个Single View Application, 在StoryBoard里添加2个UIViewController, 并且设置好导航关系 新建一个SecondViewController类, Command+N–&gt;Coca Touch cass–&gt;Next, 继承UIViewController, 选择Swift语言 import UIKit class SecondViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } } 设置第二ViewController的File’s owner 的class为刚新建的SecondViewController 第二个StoryBoard Command+N–&gt;User Interface—&gt;StoryBoard，命名Second 添加2个UIViewController, 并添加对应的按钮，将View的背景色改为黄色，以区别这是第二个UIStoryBoard, 按住Ctrl从第一个ViewController拖到第二个ViewController,选择Show 设置第一个UIViewController如下 &lt;img class=”img-responsive”src=”https://cdn.jsdelivr.net/gh/wangdeshui/blogpics@master/ios/UI/2/3.png&quot; /&gt; 连接2个StoryBoard打开Main.storyboard, 为SecondViewController上的按钮建立一个IBAction, 然后在SecondViewController.swift里添加如下代码 @IBAction func GotoSecondStoryBoard(sender: AnyObject) { let vc = UIStoryboard(name: &quot;Second&quot;, bundle: nil).instantiateInitialViewController() as! UIViewController self.navigationController?.pushViewController(vc, animated: true) } 如果我们不设置Is Intial View Controller, 那么我们需要设置View Controller的StoryBoard Id, 然后使用如下代码 let vc = UIStoryboard(name: &quot;Second&quot;, bundle: nil).instantiateViewControllerWithIdentifier(&quot;FirstView&quot;) as! UIViewController self.navigationController?.pushViewController(vc, animated: true) 结果图 (Gif)","link":"/2015/07/27/technologies-iOS-2015-07-27-ios-ui-multiple-storyboard/"},{"title":"iOS UI系列 (三) ：Reusable Button","text":"img { max-width: 700px; border: solid 2px #ccc; padding: 5px; border-radius:5px; } 有时候我们需要给一些做一些设置，但是这些控件却需要用在多个地方，如果在每一个ViewController都设置一遍，那么代码就不整洁了，而且比较耗时间。 创建一个RoundButton.swift 文件，集成自UIButton 1234567891011121314151617181920212223242526272829import UIKitclass RoundButton: UIButton { /* // Only override drawRect: if you perform custom drawing. // An empty implementation adversely affects performance during animation. override func drawRect(rect: CGRect) { // Drawing code } */ required init(coder aDecoder: NSCoder) { super.init(coder: aDecoder) } override init(frame: CGRect) { super.init(frame: frame) } override func awakeFromNib() { self.layer.cornerRadius=10 self.layer.borderColor=UIColor.redColor().CGColor self.layer.borderWidth=2 self.layer.backgroundColor=UIColor.yellowColor().CGColor self.contentEdgeInsets=UIEdgeInsets(top: 10,left: 10,bottom: 10,right: 10) }} ​​​ 设置UIButton的Custom class为 RoundButton","link":"/2015/07/27/technologies-iOS-2015-07-27-ios-ui-reuseable-uibutton/"},{"title":"iOS UI系列 (四) ：可复用的Xib(1) 静态内容","text":"img { max-width: 700px; border: solid 2px #ccc; padding: 5px; border-radius:5px; } 有时候页面中的部分内容相同，或者是一些静态的内容组合，这时候我们就可以把这些见面封装到一个XIB里 新建Single View Application新建一个View.Xib Command+N–&gt;User Interface–&gt;View 把界面大小改为Freeform 添加一个UILabel, 两个UIView, 并设置对应的背景色 添加对应的约束，让两个UIView等宽，且Space都是10， 高度固定，且与周围的约速为10， 对UILabel也设置对应的约速，细节就不写了，看图 使用Xib在ViewController添加 一个UIView, 并设置对应的约束，连接这个UIView为Controller的 IBOutlet ContainerView 在ViewDidLoad里添加如下代码 1234567super.viewDidLoad() let arr = NSBundle.mainBundle().loadNibNamed(&quot;View&quot;, owner: nil, options: nil)let v = arr[0] as! UIView containerView.addSubview(v) 运行 添加约束 1234567891011121314import UIKitclass ViewController: UIViewController { @IBOutlet weak var containerView: UIView! var v: UIView! override func viewDidLoad() { super.viewDidLoad() let arr = NSBundle.mainBundle().loadNibNamed(&quot;View&quot;, owner: nil, options: nil) v = arr[0] as! UIView ​​ containerView.addSubview(v)​ 1setUpConstraint() ​​ // Do any additional setup after loading the view, typically from a nib.​ }​ 1234override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated.} ​​ 12345678910111213141516171819202122232425262728 func setUpConstraint() { v.setTranslatesAutoresizingMaskIntoConstraints(false) containerView.addConstraint(NSLayoutConstraint( item:v, attribute:.Leading, relatedBy:.Equal, toItem:containerView, attribute:.Left, multiplier:1, constant:0)) containerView.addConstraint(NSLayoutConstraint( item:v, attribute:.Trailing, relatedBy:.Equal, toItem:containerView, attribute:.Right, multiplier:1, constant:0)) containerView.addConstraint(NSLayoutConstraint( item:v, attribute:.Top, relatedBy:.Equal, toItem:containerView, attribute:.Top, multiplier:1, constant:0)) containerView.addConstraint(NSLayoutConstraint( item:v, attribute:.Bottom, relatedBy:.Equal, toItem:containerView, attribute:.Bottom, multiplier:1, constant:0)) } } ​3. 运行结果, 我们的Xib已经可以自适应容器了 ​​","link":"/2015/07/28/technologies-iOS-2015-07-28-ios-ui-resusable-xib-static-content-from-code/"},{"title":"iOS开发(一)：真机调试","text":"苹果真机调试是比较麻烦的，需要代码签名，主要的作用就是确保程序是苹果认证的开发者开发，下面列出主要的步骤。 购买开发者帐号 img { max-width: 700px; border: solid 2px #ccc; padding: 5px; border-radius:5px; } 之前iOS开发者帐号和Mac开发者帐号需要分开购买，现在都合并为Apple Developer Program了，所以只需要出一份钱了。打开 https://developer.apple.com/programs/, 点击右上角Enroll 点击start your enrollment 选择你是个人开发者还是企业，选择个人开发者 然后就按照步骤完成购买，一般需要几天才能审核通过。 创建证书请求申请 (Certificate Signing Request)选择 “Certificate Assistant”，然后点击 “Request Certificate from A Certificate Authority.” 填入你的Email 名字，选择Save to Disk, 这是会生成一个CertificateSigningRequest.certSigningRequest 文件 创建开发者证书登录开发者中心，选择证书Development, 然后点击右边添加 选择Development—&gt;iOS App Development 这一步上传你刚才的CertificateSigningRequest.certSigningRequest 文件，点击Generate Download 你的证书，然后双击就会加入系统 注册你的设备 如果不知道UUID, 打开iTunes, 双击Serial Number 创建App ID看说明创建你需要的APP ID, 主要是Bundle ID, 一般我们类似这样确保唯一 com.jackwang.nbapp 创建Provisioning Profile 选择iOS development, 点击继续，然后选择你刚的App ID，继续，选择要包含的开发者证书，点击继续，选择要包含的设备, 随后就generate你的provisioning profile. 找到对应的Profile 下载后双击即可。 项目设置设置项目的Bundle ID 为之前创建的APP ID 然后选择你对应的Code Sign 真机调试插入你的设备，选择你的设备，点击运行，就可以真机调试了。","link":"/2015/06/13/technologies-iOS-2015-6-13-ios-debug-in-device/"},{"title":"把自己当做产品","text":"每年年初我们都要做一个计划，都希望自己有所进步，想在未来升值加薪，获得更好收入，同时在职场上受人尊敬，但是，到底该如何计划和行动呢？这里我介绍一个方法，就是把自己当作产品，为什么呢？ 产品要有MVP的功能一个产品称之为产品，那么这个产品一定要有可用的功能，那么对应到一个人身上，就是我这个人有什么用？对公司、对家庭、对社会的用处是什么？对一个职场人士来说，你能给一个公司提供什么样的价值。要对别人有用，首先要有一技之长，其次，我们知道一个产品上线之前，必须是一个MVP(Minimum viable product)。 找到适合自己产品的MVPMVP(Minimum viable product) 是说一个产品有刚刚好(just enough features)的功能给早期用户使用以便他们能够为将来产品的开发来提供反馈。 A minimum viable product (MVP) is a version of a product with just enough features to be usable by early customers who can then provide feedback for future product development. 那么，我们在职场中，就需要知道要进入职场前需要具备的基本能力是什么？比如一个技能，良好的工作态度，团队协作精神等等，一旦找到了这个MVP, 我们就去打造自己的MVP就可以了。 不要过度开发，尽早投入市场这里强调MVP, 就是我们一旦打造好自己的MVP就应该立马把产品投入到市场，当然这里说的是投入职场，对一个大学生来说，本科阶段完成应该MVP就开发完了，如果不是去搞科研，一般可能考研究生就不是必须的，尤其是考完了为了找一个更好的工作，个人认为必要性并不大，早点进入市场，就早点能够从市场拿到反馈，也就更早知道以后自己需要develop什么feature了，万一发现自己要开发的feature需要研究生的能力，完全可以自学或者到时候再带钱和带着学习目的回到学校，效果会大大提升。 产品要升级迭代一个好的产品是需要不断升级迭代的，拿一个软件产品来说，操作系统的升级，使用设备的升级（PC到手机），界面的趋势（立体到扁平化），我们的产品必须要不断升级，否则就无法继续使用或者客户会抛弃使用，无法继续给客户提供服务，把我们自己当作产品，我们有现在是什么版本？Me1.0, Me2.0 还是Me3.0？工作十年了我们是否还是停留在Me1.0? 工作二十年了，我们是Me2.0还是Me1.1呢？ 把自己当作产品不断的升级，我们就要对自己这个产品有个Release的计划，比如刚毕业我们可以是Me RC (Release candidate), 工作一年，是否可以达到Me1.0? 以后每一年是否可以是Me1.1, Me1.2…..直到自己30岁时是否可以有个大的升级升级到Me2.0, 到40岁时升级能否升级到Me3.0? 我们做产品升级时，主要做两件事，一个是开发新功能，另一个是修复上一个版本的bug, 那么我觉得我们把自己当作产品时也可如此，定期做新版本发布计划 （个人计划），同时对之前的自己做回顾，改进自己犯过的错，修复自己过去的bug, 发布产品的时候，写一个产品发布说明（新功能和修复的bug), 我们做的年终，月终总结是不是就是产品发布日志呢？ 好的产品要有竞争力一个好的产品要有竞争力，竞争力一般来说就两点，一个是不可替代性，另一个是高性价比。那么对自己这个产品来说，就要不断开发自己的能力，让自己的这个产品足够好，让市场上自己这样的产品足够少。高性价比就是提供同样的功能，客户需要付的钱更少，那么就需要不断提高自己做别人也能做的事情的效率，别人10个小时能做完的，自己1个小时能做完，那么你就可以让客户少付钱。 总结一个人的生命力大部分都比一个企业的生命力更强，世上企业千千万，但是真正能活过50年的企业非常少，百年的长青企业就更少了，好的产品需要不断更新来保持竞争力，必要的时候也需要革自己的命才能保持竞争力，微信敢于革自己QQ的命，OPPO和VIVO敢于革自己步步高的命。对我们个人这个产品来说，你在1.0的时候有竞争力的时候，不见得你在2.0时代的时候依然有竞争力，所以我们需要不断的挑战，不断的走出舒适区，居安思危，在产品1.0的时候，就要思考2.0时代的事，千万不要躺在1.0的功劳簿上，那么被后浪拍死在沙滩上不能发出一点点的夕阳之光。 把个人当做产品，找到自己的基本盘，也就是MVP, 然后不断的升级迭代，不断的学习，让自己不可替代，提高效率保持高性价比，让自己在市场上有竞争力。","link":"/2021/01/04/personaldev-2021-01-04-think-you-are-product/"},{"title":"聊聊职业发展路径","text":"为什么每个人都需要关心职业路径我们每一个人都在不同的职业，如果要想有所发展，就需要了解自己的这个职业的发展路径，这个路径就是我们的向导，我们首先需要知道我们现在是在哪一级，其次我们需要知道下一级的能力是什么？然后我们才能知道做些什么才能到达下一级。 了解职业路径非常重要，因为我们每一年都希望自己能够涨薪，希望自己收入有所提升，但是简单的只是希望是没有用的，个人的收入是和个人的能力以及为公司带来的收益正相关的。但是，很多人没有意识到这一点，把涨薪和工作时间的长短看的比例过大，甚至HR在招聘的时候也容易过于看重工作年限，但这有以下两个问题： 一个人可能工作很多年，但是一直都在重复头一两年学到的那点东西，也就是对外输出的价值是没有变化，其次随着年龄的增加导致体力的下降，对外输出的价值反而降低不少。 经验有两面性，有一些经验当我们过于熟练后，容易陷于能力陷阱，就相当于一个锤子，看到一切都是钉子，反而这种经验会对我们造成一定的羁绊。 我自己也看过不少简历，很多人工作很多年了，简历里还列着大学里拿过的奖项，这个其实是没有意义的，就像大学里大家都在讨论微积分了，你还在说你小学里得过年级数学第一名，让人觉得很Low. 单位里也有一些人，想升职加薪的时候，总是提自己几年前的贡献，殊不知几年前的贡献已经在几年前用过了。 一个毕业工作三年以后的人，大学以前的荣誉是没有多大参考价值的，过于强调之前的功劳，越是显得自己现在是个废柴，这就是为什么我们说“好汉不提当年勇”。 这里面主要的问题就是不清楚自己现在的位置，以及我们为下一个职位需要做哪些准备。 根据我自己10多年的管理经验来看，不要轻易把一个人放到一个更高的位置上去，而是要先考察这个的能力，以及这个人用这个能力做了相对应的一些贡献，我们很多的时候的错误，当然我自己也犯过这样的错误，就是先把人放到这个位置，然后相信他能干好，我们都喜欢听临危受命的故事，但是临危受命的对象必须提前做了必要的准备了，我们先把一个人往上提，最终这个人肯定会被提到他不能胜任的位置，那么时间一长，公司大部分人都是在不能胜任的位置上。 要想避免上面的问题，我们就需要让自己处于不断上升的阶段，让我们自己的能力的增长跟的上自己的年龄的增长。 我们就需要让上面这个曲线越陡峭越好。 人员级别该如何定义作为个人，需要有职业路径，但是一份好的职业路径很重要，很多公司都有相应的职位，但是并没有清晰的职业路径，以及不同职位的要求，拿我所在的软件行业里，软件行业里经常有初级程序员，中级程序员，高级程序员，比较奇怪的是很多公司里高级程序员里还能分出1到n级。我自己特别不喜欢初中高这三种分类，因为很多程序员连一些基本知识都不掌握，也叫自己是高级程序员，更遗憾的是，很多公司竟然简单粗暴的用工作年限来区分。 我自己做为一个分公司负责人，为了考核，原来也定义了一个不同级别对应客户的报价和工资，但是当时犯了一个很大的错误，这个错误影响至今，就是为了稳定当时现有人员，不影响现有人员的工资，就根据当时已有人员对客户的报价，反推出高级开发人员需要具备的能力，然后一级级下去。这里面最大的问题，不是说一个高级程序员应该具备什么样的能力，而是是否有人拿到了高级程序员的报价，这两个是没有那么强的相关性的，好在后面有及时纠正过来。 中间有几年，我定义的考核和成长路径确实起到了作用，但是随着技术的快速发展，人员的变动，原来的不同级别的要求已经不适应了，由于我自己是做技术的，所以每一个级别的要求里，写的特别具体，比如.NET语言里需要掌握什么特性等等，但是随着自己的工作经验和解决实际问题经验多了以后，发现纯粹用掌握一门语言来区分初中高级别的工程师，我就是对大学生提出的是中学生的要求。我已经发现了这些问题，所以我不想再太多参与项目的具体编码的工作，越是在公司强调独立自主工作的时候，作为Leader，需要做的coach工作反而越多，授人以鱼不如授人以渔永远是公司管理人员该做的东西，我们强调Independent的工作能力并不代表Leader的工作会减少，只能是更难，更大，因为我们需要帮大家“破镜”，从一个境界破到另一个境界，我们不能替代他，但是还要帮他破镜，这个真的很难，要做的工作也很多。 示例好的职业路径是很重要的，因为我自己是做技术的，所以我这里面贴出两个我认为不错的开发人员和技术工程师的范例，一个是Basecamp公司的，另一个是吴军老师给出的。 Basecamp下面是Basecamp给developer的title, 我选择basecamp作为参考，是因为他们的定义是奔着工作质量，团队合作以及解决问题去的，并不是一个特别具体的技术知识点： 一个人做工作是否需要被别人review, 是经常，偶尔，还是不需要被review (工作独立能力) 是否掌握需要的高级特性和用法 （深度) 是否熟练应用一些优秀的模式和方法 (行业优秀方案的应用, 能否站在巨人的肩上） 是不是一个Sole的程序员，我们之前说全栈，很多人理解的全栈只是前后台代码，代码写完了，写的是不是符合要求，是不是成功deliver到end user手上，如果我可以改的话，我希望把sole改成solo，我觉得Solo特别好，Solo就是你一个人搞定，这里面包含很多东西，一个Solo的程序员是以后可以单飞的程序员的。（是否是solo程序员) 了解其它技术，深耕一个技术领域，并同时掌握其它技术领域，做一个T Shape的人才，能否推动整个组织向前，是能否达到高境界的重要条件。（一专多能，推动组织变革和进步) Junior Programmer Work is thoroughly reviewed with substantial back and forth frequently needed before merging. Basic language features are mastered, but some advanced structures may still be unfamiliar. Occasional issues following patterns and approaches within existing code bases. Works primarily on tightly scoped, routine problems. Usually less than 2 years of experience being a professional programmer in the specific domain. Programmer Work is reviewed with the occasional need for material direction or implementation changes. Follows established patterns and approaches within existing code bases with ease. Works mostly on clearly defined and scoped individual features or problems. Usually at least 2-5 years of experience being a professional programmer in the specific domain. Senior Programmer Work doesn’t necessarily need to be reviewed, but general approach may be. Fully capable of taking substantial features from concept to shipping as the sole programmer (alongside a designer). Can provide material feedback on the work of junior programmers and programmers. Deep expertise within at least one programming environment. Basic proficiency in at least one additional programming environment. Usually at least 5-8 years of experience being a professional programmer in the specific domain. Lead Programmer Work happens completely autonomously with no regular need for review. Fully capable of owning and running entire subsystems of work (Queenbee expert, Action Cable implementation). Helps set and maintain professional standards for the entire organization. Deep, substantial expertise in multiple programming environments. Capable of running and directing small teams for substantial projects. Capable of executing projects across multiple domains (say, native app that needs API backend). Usually at least 8-12 years of experience being a professional programmer in the specific domain. Principal Programmer Can set and direct an entire department, like SIP, Core Product, or Research &amp; Fidelity. Fully capable of designing, owning, and running entirely new, novel systems (design billing systems, Trix, Active Record from scratch) Capable of running and directing larger teams for large, long-running projects. Recognized widely in the industry for material contributions to the state of the art. Invents new concepts, pushes the whole organization forward regularly. Usually at least 12-15+ years of experience being a professional programmer in the specific domain. 五级工程师吴军提出的五级工程师的标准，我觉得要求更高，我们很多人能到第二级已经很不多了，但是可以看看，如果我们终身达不到，那么也可以用来指导下一代嘛，同时也可以对比一下我们自己，然后我们对自己有个清醒的认识，避免得瑟。 第五级工程师 以计算机行业为例，一个人毕业后，经过一段时间的锻炼，能够熟练应用工程的知识和技能解决问题，独立完成所分配的工作，而不需要他人指导，就算是一个合格的五级工程师了。再具体一点，比如这个人在京东公司任职，老板让他做一个工具，找出那些不断帮助女（男）朋友买书的读者。他自己知道在公司内找谁去要数据，如何确认两个人可能是男女朋友，而且经常买书。也知道自己在京东公司的环境里，应该使用什么样的开发工具。以及为了方便客户使用，这个工具应该有什么样的基本功能。如果还做不到这件事情，就算不上是一个合格的工程师。在过去，工程师和科学家是可以并列的头衔，今天在法国和德国依然如此——那里的工程师会有一个特殊的资格证书，就如同医生和律师有特殊的资格证书一样。但是在中国，很多人从工科大学一毕业，公司就在他的名片上印上工程师，然后就似乎已经成为工程师了，很多人有这个头衔，但并不具有工程师所应该有的基本的技能。在IT行业很多人被称为码农，虽然名字不太好听，但是仔细想想，似乎也是对天天简单重复低层次IT工作的人的一个形象的写照。我想，上述对一个五级工程师的要求，任何一个从工科大学毕业的学生，只要自己有心，往这个方向努力，不难达到。如果达不到这个层次，不能算合格的工程师。 第四级工程师 对于第四级的工程师，就需要有领导能力和在工程上把大问题化解为小问题的能力了。用我之前写的“愿景－目标－道路”的逻辑，他们能够寻找出实现比较大的目标的道路。工程师和科学家不同，后者考虑的是对和错，前者只是在现有条件下考虑好和坏的解决方案。比如在建造一座海湾大桥时，工程师会在现有资金的条件下，根据交通的需求设计一个200年使用寿命的大桥，但是为了让军队迅速通过一条河，他们追求的目标就变成了在最短时间内建造足够让军队安全渡河的浮桥。目标不同，工程师的解决方案就不同，这件事对于土木工程师和桥梁工程师来讲，常常不是问题。但是很多搞IT的人，常常会把海湾大桥修成浮桥，也会把浮桥按照海湾大桥来慢慢修。因此，能否成为四级的工程师，要看能否最好地解决一个这样有规模的实际问题。这个能力远不是熟练写程序就够了的。很多人抱怨自己的机会不够，其实从管理者的角度看，中国IT公司里非常缺乏这样有头脑的工程师。至于为什么有的人能够得到机会，他们和上下级之间较强的沟通能力帮助了他们。 第三级工程师 对于第三级的工程师，就应该能够独立带领人做出一个为公司挣得利润的产品了。这里面除了上述能力外，还涉及到对市场的判断和营销能力了。很多人讲，我就是做工程的，这个东西是否有用，我不清楚，有什么事情你叫我做就好了。这样显然达不到第三级的要求。第三级的工程师，本身必须是非常好的产品经理。一个有良好工程素养的人，如果心胸开阔，愿意接受各种意见和建议，经过努力，可以做到这一步。你可能奇怪，我为什么专门强调心胸开阔，因为人有多大的心，就能做多大的事情。有人抱怨自己作为工程师，收入和社会地位太低，我想如果你做到第三级，就不低了。当然再往上，就不是很多人能够做到的了。 第二级工程师 第二级是能够做出先前没有的东西的人，世界因为他们多少有点不同。举几个例子，比如北极光风投的创始人邓锋，在他（和谢青、柯岩）之前，世界上没有真正意义上的网络防火墙设备，他们做出了这个设备，并且成功创立了当时世界上最大的防火墙公司（Netscreen），这个公司在被收购前市值大约为20亿美元。他可以算得上是二级工程师，另外，Google云计算的发明人迪恩（Jeff Dean）也可以算。你如果能成为二级工程师非常好，但是如果不能也没有关系，不必对自己太苛刻。 第一级工程师 开创一个产业的人，包括爱迪生、福特、贝尔等人 小结如果我们是一个个人，我的建议，我的建议是找一些行业里你认为比较不错的公司里，对不同级别的人要求，拿IT行业里来说，国内的腾讯，阿里，今日头条，国外的Google, Facebook, Microsoft等等，或者一些高速增长的小的明星企业，独角兽企业，那里面对人员的要求来看看自己需要哪些提高。同时，我们需要提升我们的眼界，我们每个人只有发现过自己是多么的愚蠢后，才能开始有所进步，这就是看见，因为看见，所以不同！ 对一个企业来说，我们需要定义一个不断向上的职业路径，让每一个清晰的知道每一个职位需要什么样的人，每个人自己在哪一个级别，以及下一个级别是什么？同时，要提供环境和机会，让每个人有机会从当前的位置成长到下一个位置，每一个管理人员，都要把自己转变为一个园丁，提供好的土壤，该浇水浇水，该施肥施肥，不要总想把花园变成自己期望的样子，让花草自己生长，一定会给我们惊喜。","link":"/2020/06/11/personaldev-2020-06-11-career-path/"},{"title":"终极学习法-你能学会任何东西","text":"现代社会，学习的重要性已经不言而喻，人人都为学习焦虑，看各种免费和付费的文章，教程，付出了很多时间，精力，甚至牺牲自己的身体健康，但是背过的东西用的时候想不起来，考试的时候记不起来，学习了很多知识，但是遇到问题还是无法解决？问题是什么呢？ “The person who says he knows what he thinks but cannot express it usually does not know what he thinks.”知而不能述者，非知也— Mortimer Adler 其实，学习并不是我们现在才出现的，几千年来，人们都在学习，那么一定有不少很好的学习方法，遗憾的事，我们在学校学习几十年，竟然从小学到大学，都没有人教怎么学习，我们过于强调 “书山有路勤为径，学海无涯苦做舟”, 但是我们也需要找到更好的学习方法，不然别人都在用炸药，用推土机来移山，我们还在用愚公的方法，那么真的就会子子孙孙无穷尽的都愚蠢下去了，顺便说一下，愚公移山是不是该从课本上移除出去了？ 那么到底该如何学习呢？今天我给大家介绍的就是费曼学习法，费曼学习法也被称为终极学习法！ 费曼是谁？爱因斯坦之后伟大的物理学家，他在13岁就学完微积分，高中毕业之后进入麻省理工学院学习，24岁加入曼哈顿计划，参与原子弹的秘密研制，并在同年拿到了普林斯顿物理学博士，1965年诺贝尔物理奖，提出了费曼图，费曼规则等等，参与了二战时候的曼哈顿计划，日本长崎爆炸的原子弹就是他参与的这个计划的成果之一，看了这些，你不要以为费曼就是你在学校走廊或图书馆里见到的那些科学家，他可不像牛顿一辈子未娶，而是一个撩妹高手，业余生活极其丰富，会的技能也特别多，什么修个收音机都是小技能，有一天突发奇想学画画，最后开了个人画展，听桑巴音乐的时候，喜欢上了鼓，最后担任了学校芭蕾舞团队的鼓手，还能破解玛雅文字，甚至还学会了通过嗅觉辨认不同的人，那些我们认为很难的能力，费曼都能学会。 学会这么多东西，而且很多都达到顶级水平，那么我们肯定以为他的智商很高，实际上费曼的智商只有120，远远低于爱因斯坦等人，所以，毫无疑问，费曼是一个学习高手，那么我们就来学习一下费曼学习法。 费曼学习法费曼学习法主要分为四步 概念选择一个你需要学习的概念。先拿出一张白纸，把你要学习的这一个概念写在白纸的最上面，比如说数学中勾股定理。 教学写下你对这个概念的解释，用最简单的语言，假设你正在教一个对这个概念和领域一无所知的人。教的时候，你就会发现，哪些地方你可以说得很清晰，还有哪些地方你自己都解释不明白。那么，解释不清楚的地方，要么就是你的知识还没有完全掌握，要么就是你转述的有问题，没有抓住这个概念的实质，这些就是你需要努力深入学习的部分，这一步更重要的是你可以发现哪些你还不能理解。 简化是检验我们知识的一个非常重要的手段，我们都知道白居易，白居易的诗歌题材广泛，形式多样，语言平易通俗，有“诗魔”和“诗王”之称。白居易作诗力求通俗易懂，明白晓畅。据说他每写一诗，必对家中老妪读之，老太太能理解的就抄录，不明白的就改写。 这种解释方法，爱因斯坦也尝试过用来解释相对论：“你坐在一个漂亮姑娘身边，坐了两小时，感觉上却是一会儿的工夫；而当你夏天紧挨着一个火炉时，哪怕只坐上一会儿，却仿佛已经是一个小时。 费曼有一个著名的“冰水实验”，这个实验是针对美国当时的“挑战者号”航天飞机失事的事故原因做的演示。“挑战者号”航天飞机在空中爆炸，7名宇航员遇难，震惊世界，当时的美国总统里根就召集了很多专家来调查，68岁的费曼就是其中一个。经过调查，费曼将问题锁定在火箭助推器的 O 型密封圈上。这个密封圈是橡胶做的，有一定的膨胀性，在发射火箭的时候，这个环就保护火箭体的接口，起到密封的作用，防止高温气体接触到燃料舱。但是发射基地的温度又特别冷，在零度以下，密封圈一遇冷就收缩了，在燃料舱开始燃烧的时候，一冷一热，这个密封圈就失效了。 那么，怎么向全国人民解释呢？ 费曼就在新闻发布会现场进行了一个非常经典的演示实验。他用镊子夹住橡胶圈泡在冰水里一会，拿出来之后，橡胶圈上都已经有了镊子的痕迹，过了几秒才恢复到原来的状态。这就完美地解释了，挑战者号发射当天温度很低，导致推进器的 O 型密封圈受冷之后不能立刻恢复原状，导致燃料从飞船的连接处泄露从而发生了爆炸。 回顾把刚才给讲的时候卡壳的部分，重新学习，查各种资料，直到把那些搞不懂的地方全都可以流畅地写在纸上为止。这个过程和上一个复述的过程是可以循环的，只要遇到问题就停下来学习，然后再复述。 简化当我们把所有的学习概念都弄清楚之后，用自己的话，把这个概念重新转述一遍， 这一步就是对已经学过的知识进行检验。检验自己到底有没有掌握知识，就是讲述、转述给别人听，只要别人能听懂你说的意思，那就说明你自己的学习成功了。 秘笈就这么简单，费曼学习法最重要的就是以输出来倒逼输入，我们习惯了被动的输入，大部分学生学习都是如此，老师讲什么就背什么，理解的东西太少，即使有很多考试，也其实还是考的输入。那么怎么算掌握了呢？就是自己能当老师，当一个普通的老师还是不能完全算掌握，那么费曼被成为老师的老师，就是强调我们要把任何高深的知识都能让一个小白能够听懂。 编程里面，一个比较好的编程实践就是测试驱动开发，什么是测试驱动开发呢？就是开发之前先写测试，这样可以避免开发将来用不到的功能，或者开发的东西不能用。举这个例子是不是非技术人员还是不懂，那么我就简化一下再举个例子，就是比如我们要设计一个产品，我们先设计产品说明书，然后再去开发产品。 其实，记笔记，思维导图都是这种学习方法的一部分，记笔记和脑图都是简化，只不过这种方法很多时候面对的是我们自己，如果不进行输出，那么我们很难检验自己是否真的掌握了。 为什么费曼学习法是终极学习法每个人唱歌，如果不唱出声，在心里唱，都觉得唱的和原唱一样，但是大部分人唱出来就知道差距有多大。 下面这张图是根据研究，我们学习内容的平均留存率，那么这个学习金字塔里，学到知识留存最多的是教授给他人。 总结市面上的学习方法千千万万，主动学习，把学到的东西教给他人才能算是掌握，即使不能交给他人，至少可以模拟的讲给别人听，讲不清的地方，必然是自己没有掌握，没掌握的地方再去查漏补缺，如此循环，学生也一样，把概念学透，自己能完全讲明白，比做很多套题要强很多。 我在公司里，一直强调分享，其实分享就是倒逼我们学习，那些没有分享而觉得自己掌握了某些东西的人，我是不相信的，他们只是在心里唱歌，让那些在心里唱歌的人，直接登上舞台只能是死路一条。","link":"/2020/06/18/personaldev-2020-06-18-you-can-master-anything/"},{"title":"高考满分作文《生活在树上》","text":"每年都有高考满分作文，今年的一篇高考满分作文《生活在树上》似乎出来的更早，刚开始看到的时候没有看完，因为说实话没看懂。也本不想写，因为“人之患，在好为人师”，但朋友和我聊孩子学习的时候，提起来了，推荐我看看，我于是又仔细看了一遍，把我的读后感记录一下吧。 说一下背景吧，这篇出自浙江省2020年高考作文，作文题目要求如下: 每个人都有自己的人生坐标，也有对未来的美好期望。家庭可能对我们有不同的预期，社会也可能会赋予我们别样的角色。在不断变化的现实生活中，个人与家庭、社会之间的落差或错位难免会产生。对此，你有怎样的体验与思考？写一篇文章，谈谈自己的看法。 读原文之前，我先贴一下生词注释 嚆矢（hāo shǐ）：响箭。因发射时声先于箭而到，故常用以比喻事物的开端。 滥觞（làn shāng）：滥觞原指江河发源之处水极浅小，仅能浮起酒杯，后比喻事物的起源和发端。 振翮（zhèn hé）：常用来形容人志向远大、努力奋发向上或经济正高速发展、在腾飞等。翮指鸟的翅膀。 肯綮（kěn qìng）：典出《庄子·内篇·养生主》“肯，著骨肉。綮，犹结处也。” 后遂以“肯綮”指筋骨结合的地方，比喻要害或关键之处。 孜孜矻矻（kū）：勤勉不懈的样子，出自唐·韩愈《争臣论》。 玉墀（chí）：指宫殿前的石阶，亦借指朝廷，出自汉武帝《落叶哀蝉曲》。 婞（xìng）直：指倔强；刚直。 《生活在树上》的原文如下： 现代社会以海德格尔的一句“一切实践传统都已经瓦解完了”为嚆矢。滥觞于家庭与社会传统的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循卡尔维诺“树上的男爵”的生活好过过早地振翮。我们怀揣热忱的灵魂天然被赋予对超越性的追求，不屑于古旧坐标的约束，钟情于在别处的芬芳。但当这种期望流于对过去观念不假思索的批判，乃至走向虚无与达达主义时，便值得警惕了。与秩序的落差、错位向来不能为越矩的行为张本。而纵然我们已有翔实的蓝图，仍不能自持已在浪潮之巅立下了自己的沉锚。“我的生活故事始终内嵌在那些我由之获得自身身份共同体的故事之中。”麦金太尔之言可谓切中了肯綮。人的社会性是不可祓除的，而我们欲上青云也无时无刻不在因风借力。社会与家庭暂且被我们把握为一个薄脊的符号客体，一定程度上是因为我们尚缺乏体验与阅历去支撑自己的认知。而这种偏见的傲慢更远在知性的傲慢之上。在孜孜矻矻以求生活意义的道路上，对自己的期望本就是在与家庭与社会对接中塑型的动态过程。而我们的底料便是对不同生活方式、不同角色的觉感与体认。生活在树上的柯希莫为强盗送书，兴修水利，又维系自己的爱情。他的生活观念是厚实的，也是实践的。倘若我们在对过往借韦伯之言“祓魅”后，又对不断膨胀的自我进行“赋魅”，那么在丢失外界预期的同时，未尝也不是丢了自我。毫无疑问，从家庭与社会角度一觇的自我有偏狭过时的成分。但我们所应摒弃的不是对此的批判，而是其批判的廉价，其对批判投诚中的反智倾向。在尼采的观念中，如果在成为狮子与孩子之前，略去了像骆驼一样背负前人遗产的过程，那其“永远重复”洵不能成立。何况当矿工诗人陈年喜顺从编辑的意愿，选择写迎合读者的都市小说，将他十六年的地底生涯降格为桥段素材时，我们没资格斥之以媚俗。蓝图上的落差终归只是理念上的区分，在实践场域的分野也未必明晰。譬如当我们追寻心之所向时，在途中涉足权力的玉墀，这究竟是伴随着期望的泯灭还是期望的达成？在我们塑造生活的同时，生活也在浇铸我们。既不可否认原生的家庭性与社会性，又承认自己的图景有轻狂的失真，不妨让体验走在言语之前。用不被禁锢的头脑去体味切斯瓦夫·米沃什的大海与风帆，并效维特根斯坦之言，对无法言说之事保持沉默。用在树上的生活方式体现个体的超越性，保持婞直却又不拘泥于所谓“遗世独立”的单向度形象。这便是卡尔维诺为我们提供的理想期望范式。生活在树上——始终热爱大地——升上天空。 先说说我读后的觉得好的地方吧： 作者的中文词汇量挺大的，这里面的生词不少我是不认识的，查询过后发现用的位置还是“正确”的，应该不是死记硬背而胡乱拼凑的。 作者的阅读量不小，尤其是西方的文学作品和哲学作品 “在我们塑造生活的同时，生活也在浇铸我们。既不可否认原生的家庭性与社会性，又承认自己的图景有轻狂的失真，不妨让体验走在言语之前。” 这一句我觉得写的相对挺好，有一定的思想，表达了我们追求理想生活的同时，现实生活本身在锤炼我们，原生家庭和时代对理想的影响，以及在这种理想和现实差距的时候，多去体验后再发言。 要写出好的中文文章，确实需要大量的中文词汇，需要大量的阅读，也要有自己的思考，从这三点我们对学生的要求来说，这位同学应该算是做到了，也就是文章肯定是及格的。 文章虽有可取之处，但是这样的文章，我是非常强烈不建议大家去借鉴的，甚至需要刻意避免的。下面是我的个人思考： 整个文章对大部分人生词太多，很难读懂，我上面说到的生词用的还算准确，这个”准确“，我其实是应该打引号的，我个人认为文章准确的一个标准，就是要表达的想法准确被阅读者接收了，一篇文章的接收者是读者，据我了解，我有些认识高中的语文老师都读不懂这篇文章，更别说我们普通大众了。 如果作者不是背诵的，那么就明显有过于“炫技”，好的炫技是因为实际需要，而不是为了炫技而炫技，比如，七步成诗算不算炫技？因为实际所迫，炫的就很贴合主题，“煮豆燃豆萁，豆在釜中泣。本是同根生，相煎何太急？” ，有些人学了一点东西，喜欢炫出来，这个是好事，但是如果只是一些堆砌，就未必是好事，个人认为本文很多语句是是经不起推敲或者思考的，反而花枝招展，过分妖娆。我工作中碰到很多技术人员做项目时候喜欢用一些最新的技术堆砌，但是根本没有解决客户要解决的问题，鲍鱼鱼翅，山珍海味都堆在一盘子里，只能是个大杂烩，最后啥味道都尝不到，都是一个味道。 文章提到了海德格尔，卡尔维诺，麦金太尔太多等离中国大众都挺远的人，让我怀疑作者有没有学习中国的文化，了解中国先贤的思想，老孔孟庄，诸子百家早有对题目的反思，就没有可写之处吗？ 南朝·梁·刘勰《文心雕龙·宗经》里写到：“辞约而旨丰， 事近而喻远。”。白话文不香吗？说人话很难吗？我们能比唐朝的人更懂古文？看看：“床前明月光，疑是地上霜，举头望明月，低头思故乡”、“劝君更进一杯酒，西出阳关无故人”，即使长篇诗词《长恨歌》中“杨家有女初长成，养在深闺人未识。”，《琵琶行》中“千呼万唤始出来，犹抱琵琶半遮面。转轴拨弦三两声，未成曲调先有情。” 哪一句不是我们现代人一读都懂的？ 文章很难看到共鸣，很难看到真情实感，打动人的文章都是有真情实感的，本篇文章，我看不到作者的感情，说实话我做为一个程序员，用一个程序在一分钟内生成上百篇这样的文章并不是难事。随便拿几篇中国的优秀文章，不管是 《兰亭序》中：“不知老之将至”，还是“后之视今，亦犹今之视昔”。 “夫人之相与，俯仰一世，或取诸怀抱，悟言一室之内；或因寄所托，放浪形骸之外。虽趣舍万殊，静躁不同，当其欣于所遇，暂得于己，快然自足，不知老之将至。” “每览昔人兴感之由，若合一契，未尝不临文嗟悼，不能喻之于怀。固知一死生为虚诞，齐彭殇为妄作。后之视今，亦犹今之视昔。悲夫！故列叙时人，录其所述，虽世殊事异，所以兴怀，其致一也。后之览者，亦将有感于斯文。” 还是李清照《声声慢·寻寻觅觅》中：“凄凄惨惨戚戚”，“到黄昏，点点滴滴”，“怎一个愁字了得” 寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急！雁过也，正伤心，却是旧时相识。 满地黄花堆积，憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑！梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！ 都体现了作者自己浓烈的情感，这样文章千古流传，就是作者对事物的思考，对情感的表达穿越了时空，千年后依然让我们读者感受到了作者的心境，产生了共鸣。 ​ 我很害怕这位同学写出这样的文章是某个补习班的老师教出来的，个人觉得老师应该鼓励孩子多去观察社会，感受社会，多写自己的真情实感，而不光是阅读，读万卷书而不行万里路，不去观察生活，很难理解万卷书，读书就变成了认字，虽然这很难，但是只要往正确的方向走，多走一步就多一步的成长，人生的路对一个高中生来说，还很长，着急啥呢？我中学的时候，我的语文老师就强调了这点，我现在还记得有一次作文我大概写到：“有一次我上山去捡柴，突然发现了一个桃树，桃树上有一个桃子，我赶紧摘下来吃了，好甜呀，吃完后，我突然之间特别难过，因为我忘了给姐姐留一点了，赶紧就满山去找，后来终于又发现了一个桃树长了桃子，这才开心的背着柴回家了。”，还有一次作文里我写到：“同学给我了一包方便面，这是我第一次吃方便面，方便面的味道真的是太好了，很难说出是什么味道，我就悄悄的藏了一小块，周末回家的时候，我一定要让爸妈尝一尝。” 我记得老师表扬了我，说写的很好，我们看到没有任何华丽的字，即使我现在自己看到也认为很好，因为这里面是生活经历，是真情实感。我们每一个人其实是可以写出这样的文章的，这样的文章其实也是读者能看懂和愿意看的。 还有一点，不排除这位同学可能也非常清楚什么是好的文章，但是知道阅卷老师会喜欢这样的文章，投其所好，如果果真如此的话，我奉劝我的孩子及各位同学，任何时候都不要去“赌”，尤其是高考这样决定命运的事情上根本没有赌的必要，按这位同学的才华完全不需要去拼文章的”颜值“。 最后，我想说一下，高考满分作文也有很多优秀的，没有什么争议的，我们可以去借鉴，说实话，高考作文也没什么可以借鉴的，平时大量阅读中外经典名著，多观察生活，多思考生活，到时候高考的作文只是我们观察生活和思考生活的一篇日记自然表达和情感流露而已，不用刻意追求满分作文，写出有独立思考，真情实感的文章，自然会是一篇优秀作文。 文如其人，说人话，做人事，总是对的。","link":"/2020/08/21/personaldev-2020-08-21-live-in-the-tree/"},{"title":"通才还是专才？","text":"通才: 通才又叫博学家（polymath），是指精通多个不同范畴而且表现超群的人。 专才：是只专注在某个领域的人。 这里我不对通才和专才做过多的比较，先说一下我的个人想法，我觉得通才更适合未来的社会。 过去，我们经常被电影里的某一个人百步穿杨的技能折服，现在又过于宣扬“工匠”的精神，甚至《卖油翁》也拿来成为我们教育的经典例子，我个人是很欣赏在一件事上做的更好的人，但是我们要更全面的去看一些事，要是都去学卖油翁，估计就没人去发明油壶漏斗了，再说漏上一点油有什么关系呢？很多时候我们过于追求完美以至于出不了结果，某些所谓的任务式“工匠”没啥意义，不要痴迷于这些事情。 现代社会分工越来越细，尤其是工业化时代到前信息化时代，我们对专业的人才需要越来越多，是因为让“专业”的人做一个特定的事情，肯定是效率是最高的，工业化的时候流水线的生产方式，让我们细化到一个岗位只需要去拧一个螺丝钉，这样的效率是最高的，你几乎不需要学习或者学习很少的知识，这样对管理者来说，人员也很容易替换，一个很容易替换的岗位，显然成本可以控制在最低。 上面说的容易替换的专才是对技能要求比较低的，就是需求量大，难度低，当然反过来也有难度极大的专才，这类人才肯定是奇缺的，相反可替换性就极低，那么就是奇货可居，我们看到各行业的顶尖人才能拿到直接奖励的就是这些人，年薪让本行业的大部分人一生难以望其项背。那么，我们要不要成为这样单一的专才呢？我的个人想法是：要但是不够。 要成为最顶级专业人才，光掌握专业技能是不够的的，这里面我觉得有几个原因，要的原因是让自己成为奇货可居，我们可以拿到别人拿不到的功名利禄，不够的原因是任何一个行业都很难平地起高楼，一个专业的领域往往会吸收大量的其它的领域知识的，过去我们文理分科，我们说“学好数理化，走遍天下都不怕”，学生说我学不好理科，或者学不好文科，只有理科学得好，就说自己是理科生，只有文科学得好，就说自己是文科生。我个人非常不认同的这个说法，尤其是高中以前的学生，这么认为的人，主要是自己，家长和老师都这么认为，我个人认为出现这种情况最主要还是老师水平问题，那些以为自己文理科生的学生，很多时候只是自证自己的预言而已，理科开始考得好，就在理科上投入时间更多，结果自不必说，老师也是这么来分的，但其实高中之前的知识，没有一个正常智商的人是学不会的，只是每个学生在不同知识节点上，理解有快有慢，而我们的教学是，只有一个节点上慢一次，后面就跟不上了，更别说超越了，当然，这个和整个教育体制有关系，和老师的关系也不是最大的，这是另一个话题，以后可以单独再聊。这里我想说的是，对一个高中之前的学生来说，大部分学科都是基础学科，也就是通用学科，除了学习基础的知识，各学科都是培养我们思考方式，解决问题的方式，学习本身是乐趣，学的多自然是乐趣多，事实上经过统计世界上大部分的CEO在学校里都不是成绩最优秀的人。 光掌握专业技能是不够的，这里不过多说，现在已经有很多人已经在提出 T 型人才了，也就是一专多能，简单的说就是精通一个领域，然后尽可能涉猎一些其它的领域，为什么呢？下面我举一个例子： 有一种射线，只要以一定的强度照射在肿瘤上，就能把肿瘤给杀死，等于是可以用来治疗癌症。现在问题在于，射线到达肿瘤之前肯定会先接触到患者身体的其他组织，那就会把好的组织也给杀死。可是如果把射线强度调低一点，好的组织能不被伤害，可是对肿瘤就也没用了。那有没有一个什么办法，不用做手术开刀，既能让射线杀死肿瘤，又不会伤害其他组织呢？ 1980年心理学家拿来做测验的时候，只有10%的人立即想到了。 稍微停几分钟，你能想到上面问题的方法吗？ 如果想不到，在看下面一个例子，有一个房子着火了，假设消防车不能到，没有任何灭火器，只能到不远处的湖里取水，大家每人取一点泼上去，但是火依然越烧越旺，怎么办？ 这个问题显然简单一点了，因为你熟悉了，如果没想到，那么我告诉你，就是大家拿着水同时一起泼。 好，现在再回到肿瘤问题的答案，是不是就有答案了呢？如果还没有，那么你更多的可能是一个 1 字型人才，而不是一个 T 型人才。答案就是我们减弱射线的强度，这样经过正常组织的时候，不会伤害正常组织，但我们可以从不同的方向来同时进行照射，那么射线汇聚在肿瘤上的强度就能杀死肿瘤，这就是医疗上的伽马刀。 讲这个故事的目的就是说有的时候我们想在一个专业上有所突出，很多的时候需要其它领域的知识，也就是跨领域的知识，尤其是创新很多时候都是这样的，那么 T 上面的一横，会让我们的一竖这个专业更专，更长！ 但是，我今天在这里还想说的是 T 型人才依然是不够的，只有一个专业技能有两个明显的缺陷，一个是需求量少，各个领域并不需要那么多在专业领域及其精深的人，那么岗位就相对少，还有一个是专业及其精深的人都很贵，企业并不愿过多投入，就拿我做的软件项目来说，项目中需要很深专业知识的部分不超过10%。还有一个就是当你掌握一个专业领域的时候，随着社会的进步和科技的发展，你的这个技能就毫无用处了，有汽车的时候，驾马车再好也不值钱，开车开的再好的人，等到自动驾驶的时候，开车技能就不值钱了，有点钞机的时候，数钱数出花来，也只能把自己感动的默默流泪。 那么，我们该怎么办呢？对个人而言，需要把自己打造成 π 型人才，π里面的俩竖就是两条腿，当我们一条腿被时代淘汰的时候，我们还有另外一条腿，我个人觉得比较好的两条腿是工作和兴趣能互换，比如之前我的工作是编程，兴趣是管理，现在当了几年分公司负责人后，管理是我的工作，而编程则成了我的兴趣。 最后，我想说的是“君子不器”，不要让别人或者自己把自己当做一个器具。 附上一些通才人士作为参考： 巴迪斯蒂·阿伯拉蒂 - 意大利文艺复兴时期的建筑师、建筑理论家、作家、诗人、哲学家、密码学家。 列奥那多·达芬奇 - 意大利文艺复兴时期的艺术家、博学家，在数十个领域都有极高的成就。 西蒙·斯蒂文 - 弗兰德数学家、物理学家、建筑师、军事工程师、乐理学家。 布莱兹·帕斯卡 - 法国神学家、哲学家、数学家、物理学家、化学家、音乐家、教育家、气象学家。 阿塔纳斯·珂雪 - 17世纪德国的学者，于细菌学、医学、声学、天文学、力学、埃及学、地质学、数学、语言学和音乐理论皆有成就。 哥特佛莱德·莱布尼兹 - 德国的哲学家、数学家，也从事神学理论研究。 米哈伊尔·瓦西里耶维奇·罗蒙诺索夫 - 俄国化学家、哲学家、诗人，并通晓矿物学、冶金学和语言学。 伊曼努尔·康德 - 德国的哲学家、数学家，并通晓地理学、教育学和人类学。 约翰·沃尔夫冈·冯·歌德 - 德国的戏剧家、诗人、自然科学家、文艺理论家和政治家。 汤玛士·杨格 - 英国物理学家、生理学家、医师，也通晓乐理、语言学和埃及学。 亚历山大·波菲里耶维奇·鲍罗定 - 俄国作曲家、化学家、医师。 约翰·冯·诺伊曼 - 在泛函分析、遍历理论、几何学、拓扑学和数值分析等众多数学领域及电脑学、量子力学和经济学中有重大贡献。 本杰明·富兰克林 - 美国开国元勋、政治家、外交家、科学家、发明家。 顾毓琇 - 中华民国教育家、科学家、诗人、戏剧家、音乐家、禅学家。","link":"/2020/10/28/personaldev-2020-10-28-professionalism-generalism/"},{"title":"成为通才","text":"刻意练习不是成为专家的充分条件这几年《刻意练习》这本书很火，确实，很多技能我们要学习，都需要刻意练习，我们看到的很多大师都经过了刻意练习，但是刻意练习并不能解释一件事情的百分之百，首先刻意练习比较适合规则固定的领域，没有固定规则的领域刻意练习作用非常有限，即使有固定规则的领域比如象棋，一个人总练习时间只能解释26%的表现。而在音乐和体育领域，一个人总练习时间占的表现更低，大部分是天赋和临场发挥，当然这里说的是在从事这些领域的人当中比较。而且在局面可控或者可预测的环境下，刻意练习的作用越大，反之就越小。 通才更受欢迎今天社会分工越来越细，需要很多专才，学校和培训机构培养的更多的也是专才，但正真值钱的却是通才，尤其是领导岗位，需要很多领域都有所涉猎才行，我自己公司招聘人的时候，把技术人才推到管理岗位上，大部分时间都很难胜任，甚至对技术开发人员来说，只会写代码的人，也一样很难做好客户的项目。 下面是根据调查某银行领域通才和专才的薪资对比，显然通才要高出一大截。 如何成为通才成为通才很难，你很难抱着一个实用的目的去学习，通才就是为了对付不确定性和复杂的情况，所以我们要追求的广泛的兴趣爱好，追求知识本身的乐趣，把知识本身当作回报。 当自己还不清楚自己要干什么的时候，不要过于迷茫，这很正常，很多时候我们必须多尝试几件事情，才知道我们喜欢什么，我们擅长什么。 不管你的工作或者专业是什么，一定要给自己留些业余时间，涉猎一些不同的领域，有可能你更适合别的领域，即使不适合，你的其它涉猎反过来会帮助你更好的学习和理解你的主要领域。如果你是理科生，尤其是需要学习一些人文的东西，如果你是文科生，也要多进行涉猎一些科技的东西。 敢于跨界，敢于跳出舒适区，不要被其它人的经验吓到，很多时候不同行业里面有很多相通的东西。 一万小时定律，我们可能需要在通用技能上花9000小时，剩下1000小时去学习专业的东西，那么我们再学习一个新技能可能只需要1000小时。","link":"/2020/10/30/personaldev-2020-10-30-be-generalism/"},{"title":"通才和专才：不要过早开始专才之路","text":"不要输在起跑线上，这已经是很多家长在做的事，报各种补习班，刷题来提高自己的成绩，我不能说这不对，因为需要上好的初中，高中，然后考上好的大学。但是这里会出现一个问题，过于专注考试成绩，会让孩子成为一个“专才”，这个专才就是只学习课本知识，然后养成了这样的“良好”习惯，到大学里也只学习自己的专业课本知识，最后毕业发现自己学的很多东西无法和工作直接对接，于是极其迷茫的人大有人在。 不少家长已经发现了这个问题，所以给孩子开始报兴趣班，但是本来是个兴趣班，最后家长却希望一定要学出名堂，一定要成为专家，这就是我说的过早想成为“专才”。比如我最不喜欢的就是很多家长逼孩子练钢琴，钢琴我其实不建议让学的，我每次说的时候，有朋友说你孩子都过了十级了，你却不建议我练钢琴，其实正因如此，我才知道学习钢琴投入了太多的时间，一个钢琴的时间可以学很多其它的爱好。练可以，但是孩子如果不练的时候不要逼就行。练钢琴本来是为了学习音乐，现在却成了一定要考级，而且要考到十级，很多人觉得十级挺厉害的，实际上大部分十级的人基本算很业余的水平，离真正上台表演还差着十万八千里。大部分家长都是被培训机构忽悠的，这里不是说练钢琴的坏处的，这里主要是说小孩子不要在一个兴趣上投入过多的时间，早早的往专家路上走。实际上根据调查，那些顶级专家，大部分15岁之前都没有经过大量长时间的训练，而是和普通人的训练时间差不多，那些尝试过不同的东西而选择一个深入下去的，更容易成为专家，原因是尝试很多东西后选择的话，主要是自己选择，而尝试的东西比较少的很多时候是被动选择。我们知道要成为专家的方法是刻意练习，而刻意练习是很枯燥的事，主动选择的人更多是因为兴趣，显然在枯燥练习的时候更容易坚持。 同样的，不要过早的把自己进行文理科划分，尤其是不要自己过早的放弃了对理科知识的学习，小学，高中的大部分课程都非常有用，当然，我说的有用并不是说我们一定要考很高的分数，而是要知道为什么要学这些课程，学这些课程对我们理解世界，理解自己，解决问题有什么帮助。不同学科都有着自己的体系，都有着不同的思维体系，那个学科解决学科顶级问题都使用了什么方法。尤其是不要放弃数学，数学是一切学科的王冠。到了大学，我依然觉得应该更重视通识教育，现在很多学校在大学都有了专业，而且理科专业居多，原因是可以学习实际的技能，然后快速投入工作，这使很多人忽略了人文的学习，忽略了人文的科技很多的时候实际上会造成人类的灾难。 因此，我建议小的时候德智体美劳真的要全面去发展，语文、数学、物理、化学、历史、生物等等学科，一定要清楚为什么学，找到学科的乐趣，尤其是要多读读书，多多旅行，知行合一，时代变化很快，我们为孩子选的方向很多时候等孩子长大的时候都不合适了，相比于像郎朗那样成为表演艺术家，我更期望孩子成为一个普通的人，可能钢琴弹得很一般，如果学习音乐，能够自己作词，作曲来表达自己的思想，即使作的词和曲很普通，但是却可以从小就开始一个丰富和幸福的人生。","link":"/2020/10/29/personaldev-2020-10-29-bu-yao-guo-zao-zhuan-cai/"},{"title":"新时代的节俭","text":"勤俭节约是中华民族的传统美德，但是我们上一辈的一些节俭的理念，随着人民生活水平的提高和社会的各项进步，需要进行upgrade了，比如有的剩饭已经坏了继续吃，前几天报道的过期的“酸汤子”吃死了好几口人，缝缝补补又三年，实际上现在已经没人再穿缝补的衣服了。 我个人觉得社会整体财富和个人财富的增加，让整体的生活水平已经有了很大的提高，我们对节俭的概念也需要有新的认识，首先，我同意浪费肯定是不对的，但对节俭来说什么才是合适的节俭，我们应该怎么样来节俭。 我认为节俭主要在以下几个方面： 金钱的节俭首先，现在虽然平均个人财富增加了，但是大家生活压力其实依然挺大，尤其是城市里房价居高不下，物价也飞速上涨，适当存钱，不乱花钱依然是一个好的传统，当然，这些都是说中产阶级，如果你特别有钱，你还是应该多买点东西帮助拉动一下内需，我很高兴看到现在的新的年轻人不再追求国外的奢饰品，国外的大牌，像小米、李宁等国产品牌都受到了国内相当一部分年轻人的喜爱，关于花钱这块儿，我个人比较提倡高性价比，就是功能和价格的性价比比较高，拿汽油车来说，我觉得很多10万左右的车就够用了，100多万的车，除了家里很有钱，完全没必要。过去大家买东西，喜欢买大而全的，实际上完全没必要，很多时候大部分功能我们都用不到，我个人比较提倡专一功能的产品，这样产品比较容易做精，不会为其它功能妥协，价格实际上也便宜挺多。 时间的节俭人生苦短，我们减少自己不喜欢做的事情的时间，就能有更多时间做自己喜欢的事，所以省时间依然是最重要的节俭，这一点在老一辈那里尤其严重，时间的节俭，主要有两个方法： 提高效率，更短的时间做更多的是 花钱省时间，而不是花时间省钱，尤其是年轻人，我看到很多大学生，从父母身上继承了这个“优秀”的传统，为了省点或挣点小钱，浪费了大学了大量时间。 下面，我列一些可以省时间的例子： 出行：可以打车，坐飞机，自驾等等 家务活：可以买洗碗机，扫地机器人，请钟点工 健康：可以提前预约，在线问诊等等 学习：买课程，买书，不要网上耗时间搜 住：尽量住公司近的地方，如果买的房子远，可以租的离公司近点的地方 空间的节俭现在新的极简生活开始流行，我很喜欢，很多人喜欢买现在用不到的东西，用过的东西基本上不会用了，也舍不得扔，这看起来是节俭，实际上是很大的浪费，现在房价那么贵，我们却把家里堆满了很多很少或者几乎不会用到的东西，为什么我们很多时候多买可以打折，其中一个原因是帮商家清库存呀，大部分人都住在楼房一个个“鸟笼”里，很多我们觉得需要的东西其实完全没必要，现在有很多东西都可以数字化，比如书，一个Kindle就可以把一个图书馆带回家，纸张数留点经典的就可以了，很多人炫耀家里藏书万册，完全没必要，完全是一个个人执念的问题，我一个Kindle里装满藏书百万册，而且很多书本省会不断的修正，电子的极其方便，这就是一个移动的图书馆，占地可以忽略不计，但是，纸质书也有其价值，比如对小孩子来说，一个是可以保护孩子的眼睛，另一个就是大人看的一些书，想让孩子也有一个好的读书的习惯，那么拥有一些经典的纸质书也是很有必要的好的读书的习惯，那么拥有一些经典的纸质书也是很有必要的，但是好的纸质书书在于精不在多也。还有不穿的衣服，不穿的鞋子等等，可以捐出去，捐不出去，就应该扔掉。人其实对物质的需求，远没有我们想象的那么大。","link":"/2020/10/31/personaldev-2020-10-31-new-saving/"},{"title":"用软件系统思维来看管理","text":"本人在一家软件公司工作，作为一家分公司的负责人，面对的全是程序员，程序员大部分都是更偏向技术，是不擅长沟通的，所以有的时候想管理好并不容易，因为你需要和程序员之间建立一个良好的沟通框架，让程序员能够理解怎么和你沟通和高效协作，这是管理者需要时间思考的，最近，我看到一些问题，这些问题就是有的时候我们说程序员的一些问题，程序员可能比较迷惑，他不知道你到底想要什么。同时，如果你对一个人和一个团队无法理解，你完全是无法帮助团队的，而团队有可能感觉委屈，自己做的工作没得到认可，但是问题就是别人不知道或者不了解你的工作，怎么认可呢？又怎么帮助你呢？为了让程序员能够理解一般领导者需要什么，今天我就用程序员能够理解的软件系统来解释一下。 前方高能预警：非软件人员有可能看不懂。 一个公司已经运行后，就和一个系统已经运行了一样，领导肯定要知道我这个公司运行的怎么样，那么要知道我这个公司运行的怎么样，看去年的数据肯定不够，因为去年的已经过去，我们跟关注的是现在和未来，要关注现在，那么就需要知道现在的业务运行情况，我们知道一个软件系统运行后经常需要一个monitor system 和logging system， monitor主要是通过一个中心化的界面了解到是否一切正常，如果不正常需要去查看logging system看问题出在哪里，然后通过Alerting系统来想相关人员发出Alert并同时创建一个issue到issue系统来追踪，领导要关注的就是这个Dashboard的大屏。 下面是一张基于Prometheus的一套监控，日志和警告系统 下面是一张大概的Dashboard的图，领导需要看到的是这样的一张图，各业务运行的状态和具体数据。 如果看不懂，看下面类似的图： 这里面有下面几部分内容： 团队或者部门工作过程中需要记录工作日志(数据和操作日志)。 团队需要持续把相关信息推送给数据中心，例如一周一次或者有新信息，内容是可以是团队所做事情的进度，进度是否正常，是否有问题。我们知道监控是可以监控系统的负载的，比如CPU占用90%，硬盘是否快满了，那么对应到实际工作就是是否团队加班严重，是否需要加人，某个人是否“坏”了等等，这些信息一定要主动PUSH的。 数据中心（信息化部门？）收集到信息后，进行记录。 可视化系统（财务部门，人事部门，各团队负责人？）对数据进行分析，然后产生可视化的报表。 领导看可视化报表，通过报表可以看到一些潜在的问题issue, 那么就需要Alert给团队里的人。 团队的人修复这个issue。要想修复好相关的信息，那么我们的工作就需要查看对应的日志，通过查看日志（数据和过程) 来看这些issue是如何产生的，然后找到issue的原因来修正issue. 这里面一个很重要的就是查看日志来做回顾，重要的是修复这个issue和将来如何避免这个issue 软件系统很多东西都是自动化的，那么对应到管理里面，很多流程其实没有做到自动化，那么作为团队和领导都有哪些工作做呢？ 团队：做好任务，记录工作日志，工作日报，主动 push 信息给数据中心，接受alert, 修复issue. 管理团队：收集信息，分析数据，查看报表，alert issue给团队。 说到这里很多人会说，团队要自组织，组织要去中心化，经过这么多年，我只能从来没见过一个能够完全自组织的团队，也没讲过一个完全去中心化的组织，很简单，只要是团队，就一定有组织，再牛逼的足球队都有个队长，只要有管理人员，只要有老板，就不可能完全去中心化，扁平组织，合伙制，合弄制，只要不是让所有人来投票决定都不可能是完全去中心化，比特币是的，开公司不可能向比特币那样，况且看看比特币的运行效率问题就知道了，一笔交易现在需要几天后才能看到是否成功。 管理人员就像是在开车，除了更重要的方向之外，选择合适的路的之后，你必须要知道你现在车的速度，发动机是否正常，车胎是否完好，油量能开多远。那么对应到管理里面，团队每一个成员就要想出了做好事情之外，怎么样把自己的状态能够实时的显示在管理人员的Dashabord上，不然怎么能够让司机安心的开车呢？","link":"/2020/12/05/personaldev-2020-12-05-use-software-thinking-to-managment/"}],"tags":[{"name":"管理","slug":"管理","link":"/tags/%E7%AE%A1%E7%90%86/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"跑步","slug":"跑步","link":"/tags/%E8%B7%91%E6%AD%A5/"},{"name":"欧美外包","slug":"欧美外包","link":"/tags/%E6%AC%A7%E7%BE%8E%E5%A4%96%E5%8C%85/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"团队实践","slug":"团队实践","link":"/tags/%E5%9B%A2%E9%98%9F%E5%AE%9E%E8%B7%B5/"},{"name":"个人发展 思维提升","slug":"个人发展-思维提升","link":"/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95-%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87/"},{"name":"个人发展 思维提升 领导力","slug":"个人发展-思维提升-领导力","link":"/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95-%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87-%E9%A2%86%E5%AF%BC%E5%8A%9B/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"DDD","slug":"DDD","link":"/tags/DDD/"},{"name":"JavaScript.Next","slug":"JavaScript-Next","link":"/tags/JavaScript-Next/"},{"name":"Microsoft","slug":"Microsoft","link":"/tags/Microsoft/"},{"name":"整洁代码系列","slug":"整洁代码系列","link":"/tags/%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97/"},{"name":"FrontEnd","slug":"FrontEnd","link":"/tags/FrontEnd/"},{"name":"network security","slug":"network-security","link":"/tags/network-security/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"}],"categories":[{"name":"敏捷","slug":"敏捷","link":"/categories/%E6%95%8F%E6%8D%B7/"},{"name":"管理","slug":"管理","link":"/categories/%E7%AE%A1%E7%90%86/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"跑步","slug":"跑步","link":"/categories/%E8%B7%91%E6%AD%A5/"},{"name":"外包","slug":"外包","link":"/categories/%E5%A4%96%E5%8C%85/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"团队实践","slug":"团队实践","link":"/categories/%E5%9B%A2%E9%98%9F%E5%AE%9E%E8%B7%B5/"},{"name":"个人发展","slug":"个人发展","link":"/categories/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"},{"name":"领导力","slug":"领导力","link":"/categories/%E9%A2%86%E5%AF%BC%E5%8A%9B/"},{"name":"前端开发","slug":"前端开发","link":"/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"移动开发","slug":"移动开发","link":"/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]}